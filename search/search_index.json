{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"**A pipeline framework for python**   <p>  []1 []13 []13 []23</p> <p>Documentation | ChangeLog | Examples | API</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Easy to use</li> <li>Nearly zero-configuration</li> <li>Nice logging</li> <li>Highly extendable</li> <li>Cloud support naively</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install -U pipen\n</code></pre>"},{"location":"#quickstart","title":"Quickstart","text":"<p><code>example.py</code></p> <pre><code>from pipen import Proc, Pipen, run\n\nclass P1(Proc):\n    \"\"\"Sort input file\"\"\"\n    input = \"infile\"\n    input_data = [\"/tmp/data.txt\"]\n    output = \"outfile:file:intermediate.txt\"\n    script = \"cat {{in.infile}} | sort &gt; {{out.outfile}}\"\n\nclass P2(Proc):\n    \"\"\"Paste line number\"\"\"\n    requires = P1\n    input = \"infile:file\"\n    output = \"outfile:file:result.txt\"\n    script = \"paste &lt;(seq 1 3) {{in.infile}} &gt; {{out.outfile}}\"\n\n# class MyPipeline(Pipen):\n#     starts = P1\n\nif __name__ == \"__main__\":\n    # MyPipeline().run()\n    run(\"MyPipeline\", starts=P1)\n</code></pre> <pre><code>&gt; echo -e \"3\\n2\\n1\" &gt; /tmp/data.txt\n&gt; python example.py\n</code></pre> <pre><code>04-17 16:19:35 I core                   _____________________________________   __\n04-17 16:19:35 I core                   ___  __ \\___  _/__  __ \\__  ____/__  | / /\n04-17 16:19:35 I core                   __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n04-17 16:19:35 I core                   _  ____/__/ /  _  ____/_  /___  _  /|  /\n04-17 16:19:35 I core                   /_/     /___/  /_/     /_____/  /_/ |_/\n04-17 16:19:35 I core\n04-17 16:19:35 I core                               version: 0.17.3\n04-17 16:19:35 I core\n04-17 16:19:35 I core    \u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 MYPIPELINE \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557\n04-17 16:19:35 I core    \u2551 My pipeline                                                       \u2551\n04-17 16:19:35 I core    \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d\n04-17 16:19:35 I core    plugins         : verbose v0.14.1\n04-17 16:19:35 I core    # procs         : 2\n04-17 16:19:35 I core    profile         : default\n04-17 16:19:35 I core    outdir          :\n                /home/pwwang/github/pipen/examples/MyPipeline-output\n04-17 16:19:35 I core    cache           : True\n04-17 16:19:35 I core    dirsig          : 1\n04-17 16:19:35 I core    error_strategy  : ignore\n04-17 16:19:35 I core    forks           : 1\n04-17 16:19:35 I core    lang            : bash\n04-17 16:19:35 I core    loglevel        : info\n04-17 16:19:35 I core    num_retries     : 3\n04-17 16:19:35 I core    scheduler       : local\n04-17 16:19:35 I core    submission_batch: 8\n04-17 16:19:35 I core    template        : liquid\n04-17 16:19:35 I core    workdir         :\n                 /home/pwwang/github/pipen/examples/.pipen/MyPipeline\n04-17 16:19:35 I core    plugin_opts     :\n04-17 16:19:35 I core    template_opts   : filters={'realpath': &lt;function realpath at\n                 0x7fc3eba12...\n04-17 16:19:35 I core                    : globals={'realpath': &lt;function realpath at\n                 0x7fc3eba12...\n04-17 16:19:35 I core    Initializing plugins ...\n04-17 16:19:36 I core\n04-17 16:19:36 I core    \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 P1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n04-17 16:19:36 I core    \u2502 Sort input file                                                   \u2502\n04-17 16:19:36 I core    \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n04-17 16:19:36 I core    P1: Workdir:\n                 '/home/pwwang/github/pipen/examples/.pipen/MyPipeline/P1'\n04-17 16:19:36 I core    P1: &lt;&lt;&lt; [START]\n04-17 16:19:36 I core    P1: &gt;&gt;&gt; ['P2']\n04-17 16:19:36 I verbose P1: in.infile: /tmp/data.txt\n04-17 16:19:36 I verbose P1: out.outfile:\n                 /home/pwwang/github/pipen/examples/.pipen/MyPipeline/P1/0/output/intermediate\n                 .txt\n04-17 16:19:38 I verbose P1: Time elapsed: 00:00:02.051s\n04-17 16:19:38 I core\n04-17 16:19:38 I core    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 P2 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n04-17 16:19:38 I core    \u2551 Paste line number                                                 \u2551\n04-17 16:19:38 I core    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n04-17 16:19:38 I core    P2: Workdir:\n                 '/home/pwwang/github/pipen/examples/.pipen/MyPipeline/P2'\n04-17 16:19:38 I core    P2: &lt;&lt;&lt; ['P1']\n04-17 16:19:38 I core    P2: &gt;&gt;&gt; [END]\n04-17 16:19:38 I verbose P2: in.infile:\n                 /home/pwwang/github/pipen/examples/.pipen/MyPipeline/P1/0/output/intermediate\n                 .txt\n04-17 16:19:38 I verbose P2: out.outfile:\n                 /home/pwwang/github/pipen/examples/MyPipeline-output/P2/result.txt\n04-17 16:19:41 I verbose P2: Time elapsed: 00:00:02.051s\n04-17 16:19:41 I core\n\n\n              MYPIPELINE: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:06&lt;00:00, 0.35 procs/s]\n</code></pre> <pre><code>&gt; cat ./MyPipeline-output/P2/result.txt\n1       1\n2       2\n3       3\n</code></pre>"},{"location":"#examples","title":"Examples","text":"<p>See more examples at <code>examples/</code> and a more realcase example at:</p> <p>https://github.com/pwwang/pipen-report/tree/master/example</p>"},{"location":"#plugin-gallery","title":"Plugin gallery","text":"<p>Plugins make <code>pipen</code> even better.</p> <ul> <li><code>pipen-annotate</code>: Use docstring to annotate pipen processes</li> <li><code>pipen-args</code>: Command line argument parser for pipen</li> <li><code>pipen-board</code>: Visualize configuration and running of pipen pipelines on the web</li> <li><code>pipen-diagram</code>: Draw pipeline diagrams for pipen</li> <li><code>pipen-dry</code>: Dry runner for pipen pipelines</li> <li><code>pipen-filters</code>: Add a set of useful filters for pipen templates.</li> <li><code>pipen-lock</code>: Process lock for pipen to prevent multiple runs at the same time.</li> <li><code>pipen-log2file</code>: Save running logs to file for pipen</li> <li><code>pipen-poplog</code>: Populate logs from jobs to running log of the pipeline</li> <li><code>pipen-report</code>: Generate report for pipen</li> <li><code>pipen-runinfo</code>: Save running information to file for pipen</li> <li><code>pipen-verbose</code>: Add verbosal information in logs for pipen.</li> <li><code>pipen-gcs</code>: A plugin for pipen to handle files in Google Cloud Storage.</li> <li><code>pipen-deprecated</code>: A pipen plugin to mark processes as deprecated.</li> <li><code>pipen-cli-init</code>: A pipen CLI plugin to create a pipen project (pipeline)</li> <li><code>pipen-cli-ref</code>: Make reference documentation for processes</li> <li><code>pipen-cli-require</code>: A pipen cli plugin check the requirements of a pipeline</li> <li><code>pipen-cli-run</code>: A pipen cli plugin to run a process or a pipeline</li> <li><code>pipen-cli-gbatch</code>: A pipen cli plugin to submit pipeline to Google Batch Jobs</li> </ul>"},{"location":"CHANGELOG/","title":"Change log","text":""},{"location":"CHANGELOG/#change-log","title":"Change Log","text":""},{"location":"CHANGELOG/#01724","title":"0.17.24","text":"<ul> <li>chore: improve error message for missing output generation</li> </ul>"},{"location":"CHANGELOG/#01723","title":"0.17.23","text":"<ul> <li>fix: update class reference for setup state to make sure on_setup hook only executes once</li> </ul>"},{"location":"CHANGELOG/#01722","title":"0.17.22","text":"<ul> <li>BREAKING: change on_setup hook parameter from config to pipen</li> <li>chore: upgrade dependencies and bump datar to 0.15.12</li> <li>chore: update README with new plugins</li> <li>ci: add python 3.13 in build workflow</li> </ul>"},{"location":"CHANGELOG/#01721","title":"0.17.21","text":"<ul> <li>chore: update fake symlink prefix to 'pipen-symlink'</li> <li>chore: update xqute version to 0.10.16</li> </ul>"},{"location":"CHANGELOG/#01720","title":"0.17.20","text":"<ul> <li>chore: remove unnecessary self argument for the plugin for xqute and the main plugin for pipen itself</li> </ul>"},{"location":"CHANGELOG/#01719","title":"0.17.19","text":"<ul> <li>chore: update xqute version to 0.10.11</li> </ul>"},{"location":"CHANGELOG/#01718","title":"0.17.18","text":"<ul> <li>chore: update xqute version to 0.10.10</li> <li>feat: add environment variables to job submission</li> </ul>"},{"location":"CHANGELOG/#01717","title":"0.17.17","text":"<ul> <li>feat: enhance argument parsing in CLI</li> </ul>"},{"location":"CHANGELOG/#01716","title":"0.17.16","text":"<ul> <li>fix: handle potential error when reading stderr file</li> <li>chore: update xqute version to 0.10.7</li> </ul>"},{"location":"CHANGELOG/#01715","title":"0.17.15","text":"<ul> <li>chore(deps): update xqute dependency version to 0.10.6 in pyproject.toml</li> <li>feat: adopt xqute 0.10.6</li> </ul>"},{"location":"CHANGELOG/#01714","title":"0.17.14","text":"<ul> <li>fix: fix scheduler_opts of processes not full inheriting from pipeline</li> <li>style: fix styles in example scripts</li> </ul>"},{"location":"CHANGELOG/#01713","title":"0.17.13","text":"<ul> <li>fix: update on_job_polling signature to include counter parameter</li> </ul>"},{"location":"CHANGELOG/#01712","title":"0.17.12","text":"<ul> <li>chore(deps): bump xqute to 0.10.4</li> </ul>"},{"location":"CHANGELOG/#01711","title":"0.17.11","text":"<ul> <li>fix: mapping the pipeline workdir for gbatch scheduler instead of process workdir to enable communications between processes</li> <li>chore: fix no argument ignore errors for path.rmtree</li> <li>tests: update gbatch scheduler volume paths</li> <li>chore(deps): bump xqute to 0.10.3</li> <li>chore: update .gitignore to include git bundle files</li> </ul>"},{"location":"CHANGELOG/#01710","title":"0.17.10","text":"<ul> <li>fix: lowercase labels in GbatchScheduler</li> </ul>"},{"location":"CHANGELOG/#0179","title":"0.17.9","text":"<ul> <li>feat: add pipeline and proc names to labels for GbatchScheduler</li> <li>chore(deps): bump xqute to 0.10.1</li> <li>chore: standardize log message for workdir</li> </ul>"},{"location":"CHANGELOG/#0178","title":"0.17.8","text":"<ul> <li>chore(deps): bump up xqute to 0.10.0</li> <li>feat: add container scheduler support for Docker/Podman/Apptainer</li> </ul>"},{"location":"CHANGELOG/#0177","title":"0.17.7","text":"<ul> <li>chore(deps): bump up xqute to 0.9.4</li> <li>fix: optimize path_is_symlink function to check fake symlink faster</li> </ul>"},{"location":"CHANGELOG/#0176","title":"0.17.6","text":"<ul> <li>style: update type hints</li> </ul>"},{"location":"CHANGELOG/#0175","title":"0.17.5","text":"<ul> <li>chore: bump xqute to 0.9.3</li> <li>fix: update mounted directory paths for GbatchScheduler</li> <li>feat: add fast_container for GbatchScheduler</li> </ul>"},{"location":"CHANGELOG/#0174","title":"0.17.4","text":"<ul> <li>chore: add ipykernel dependency for example pipelines</li> <li>chore(deps): bump datar to 0.15.9 (numpy v2)</li> <li>fix: prevent adding processes to starts if already included</li> </ul>"},{"location":"CHANGELOG/#0173","title":"0.17.3","text":"<ul> <li>chore: hide job index prefix in log messages for single-job processes</li> <li>chore(deps): update flake8 and other dependencies in pyproject.toml</li> <li>docs: fix outfile in the caching example</li> <li>docs: add example in README as an example pipeline in the examples folder</li> </ul>"},{"location":"CHANGELOG/#0172","title":"0.17.2","text":"<ul> <li>fix: handle exceptions (KeyboardInterrupt) when closing counters in progress bar (enlighten v1.14)</li> </ul>"},{"location":"CHANGELOG/#0171","title":"0.17.1","text":"<ul> <li>docs: update templating documentation to clarify job metadata paths</li> <li>fix: ensure iterables other than list/tuple are treated correctly as files/dirs</li> </ul>"},{"location":"CHANGELOG/#0170","title":"0.17.0","text":"<ul> <li>fix: handle None input case in job caching logic</li> <li>chore(deps): update liquidpy to 0.8.4</li> <li>refactor: replace DualPath with SpecPath in codebase to adopt xqute 0.9</li> </ul>"},{"location":"CHANGELOG/#0160","title":"0.16.0","text":"<ul> <li>ci: update build workflow conditions and improve dependency versions</li> <li>feat: support gbatch scheduler and cloud workdir/outdir</li> <li>refactor: replace cloudpathlib with yunpath and update related code</li> <li>refactor: adopt xqute 0.8.0</li> <li>chore: add more processes in examples/gbatch.py</li> <li>fix: make sure spec is carried for cloud output files so mtime can be check for next processes</li> <li>ci: add Google authentication step to CI workflow</li> <li>fix: fix specified path not carries to the next processes</li> <li>fix: handle missing MOUNTED_OUTDIR gracefully and remove unused test</li> <li>test: add fixture for unique ID and update cloud test to support parallel execution</li> <li>fix: remove fake symlink output when necessary</li> <li>docs: add cloud support documentation</li> <li>feat: support mounted paths (e.g. path1:path2) as input</li> <li>refactor: remove redundant validation for workdir and outdir path types</li> <li>feat: enforce GSPath type for 'gbatch' scheduler as pipeline outdir</li> <li>feat: add fast_mount option to GbatchScheduler for cloud directory mounting</li> <li>fix: update workdir path to include pipeline name in Pipen class</li> <li>chore(deps): bump python-simpleconf to v0.7</li> <li>feat: support DualPath output directory in Job class and ensure mounted directory creation</li> <li>fix: initialize cmd with a default value to prevent errors when no script is provided</li> <li>chore(deps): bump xqute to 0.8.1</li> <li>fix: only create mounted output directory when no MOUNTED_OUTDIR with scheduler</li> <li>fix: update mountPath index for taskSpec volumes in GbatchScheduler</li> <li>feat: support fast_mount to be a list for gbatch scheduler</li> </ul>"},{"location":"CHANGELOG/#0158","title":"0.15.8","text":"<ul> <li>chore(deps): update package versions for executing, and xqute</li> <li>fix: change the input/output path from resolved to absolute for symlinks</li> <li>style(tests): update imports and add noqa comment for unused variable</li> </ul>"},{"location":"CHANGELOG/#0157","title":"0.15.7","text":"<ul> <li>chore(deps): update xqute to version 0.5.5</li> <li>chore(deps): update pytest-asyncio to version 0.25.2</li> <li>chore: add logging for plugin initialization</li> </ul>"},{"location":"CHANGELOG/#0156","title":"0.15.6","text":"<ul> <li>chore(deps): bump python-varname to 0.14</li> <li>ci: update GitHub Actions to use ubuntu-24.04</li> <li>style: fix style issues in test files</li> </ul>"},{"location":"CHANGELOG/#0155","title":"0.15.5","text":"<ul> <li>fix: fix <code>kwargs</code> not updated when pipeline is a <code>Pipen</code> object in <code>utils.load_pipeline()</code></li> <li>fix: fix type checking in <code>utils.load_pipeline()</code></li> </ul>"},{"location":"CHANGELOG/#0154","title":"0.15.4","text":"<ul> <li>fix: fix Pipen object not recognized by <code>utils.load_pipeline()</code></li> <li>style: fix type annotations in Pipen class</li> <li>deps: bump argx to 0.2.11</li> </ul>"},{"location":"CHANGELOG/#0153","title":"0.15.3","text":"<ul> <li>feat: add <code>pipen.run()</code> as a function to run a pipeline</li> <li>docs: fix the decorations in the logs in README</li> </ul>"},{"location":"CHANGELOG/#0152","title":"0.15.2","text":"<ul> <li>deps: update xqute dependency to version 0.5.1</li> <li>chore: update pytest options in pyproject.toml to ignore deadlock warnings</li> <li>feat: expose on_jobcmd_* hooks for plugins to modify the job wrapper script</li> </ul>"},{"location":"CHANGELOG/#0151","title":"0.15.1","text":"<ul> <li>deps: bump xqute to 0.5.0</li> <li>xqute v0.5.0 provides 3 more hooks for the plugins to inject bash code to the job wrapper scripts.</li> <li>see https://github.com/pwwang/xqute?tab=readme-ov-file#plugins.</li> </ul>"},{"location":"CHANGELOG/#0150","title":"0.15.0","text":"<ul> <li>BREAKING: remove redundant argument <code>proc</code> for job plugin APIs</li> <li>deps: bump up dev deps</li> <li>deps: bump xqute to version 0.4.1</li> <li>refactor: remove <code>abstractproperty</code> decorator from <code>CLIPlugin</code> class</li> <li>feat: add 5 more APIs for plugins to handle files from other platforms (e.g. the cloud)</li> <li>ci: add python3.12 to CI</li> <li>test: fork each test in test_job.py</li> <li>test: fork tests in test_pipen.py and test_proc.py</li> <li>docs: correct the documentation about <code>dirsig</code></li> <li>enh: make better error message when set wrong type of starts for a pipeline</li> <li>docs: add pipen-gcs in plugin gallery</li> </ul>"},{"location":"CHANGELOG/#0146","title":"0.14.6","text":"<ul> <li>fix: fix error handling in ProcPBar class</li> <li>deps: bump up dev deps</li> </ul>"},{"location":"CHANGELOG/#0145","title":"0.14.5","text":"<ul> <li>fix: fix all plugins being disabled by default</li> </ul>"},{"location":"CHANGELOG/#0144","title":"0.14.4","text":"<ul> <li>deps: bump xqute to 0.4 (simplug to 0.4.1)</li> <li>refactor: refactor <code>pipen.plugin_context</code> due to simplug upgrade</li> <li>docs: update docs for specifiying plugins due to simplug upgrade</li> <li>examples: update examples for specifiying plugins due to simplug upgrade</li> <li>tests: add tests for plugins specification</li> <li>tests: use pytest v8</li> <li>ci: use latest actions</li> </ul>"},{"location":"CHANGELOG/#0143","title":"0.14.3","text":"<ul> <li>choir: rename argument <code>args</code> to <code>argv</code> for <code>utils.is_loading_pipeline()</code></li> </ul>"},{"location":"CHANGELOG/#0142","title":"0.14.2","text":"<ul> <li>feat: allow passing arguments to <code>utils.is_loading_pipeline()</code></li> </ul>"},{"location":"CHANGELOG/#0141","title":"0.14.1","text":"<ul> <li>feat: add flags (e.g. <code>--help</code>) to <code>utils.is_loading_pipeline</code> to check arguments in <code>sys.argv</code></li> </ul>"},{"location":"CHANGELOG/#0140","title":"0.14.0","text":"<ul> <li>deps: drop support for python 3.8</li> <li>deps: bump <code>varname</code> to 0.13</li> <li>docs: update readme for more plugins</li> </ul>"},{"location":"CHANGELOG/#0133-yanked","title":"0.13.3 (yanked)","text":"<ul> <li>deps: bump <code>varname</code> to 0.13</li> </ul>"},{"location":"CHANGELOG/#0132","title":"0.13.2","text":"<ul> <li>style: change max line length to 88</li> <li>feat: add <code>envs_depth</code> to procs to control the depth of envs to be inherited by subclasses</li> </ul>"},{"location":"CHANGELOG/#0131","title":"0.13.1","text":"<ul> <li>test: cover <code>on_job_polling</code></li> <li>fix: update envs recursively for subclasses</li> <li>test: make sure class envs kept intact when subclassed</li> </ul>"},{"location":"CHANGELOG/#0130","title":"0.13.0","text":"<ul> <li>deps: bump xqute to 0.3.1 and liquidpy to 0.8.2</li> <li>breaking: change hook <code>on_job_running</code> to <code>on_job_started</code> and add <code>on_job_polling</code></li> </ul>"},{"location":"CHANGELOG/#0125","title":"0.12.5","text":"<ul> <li>deps: bump xqute to 0.2.5</li> <li>chore: make utils._excepthook only handle KeyboardInterrupt</li> <li>chore: update examples</li> </ul>"},{"location":"CHANGELOG/#0124","title":"0.12.4","text":"<ul> <li>Modify sys.argv before the module is loaded in <code>utils.load_pipeline()</code></li> </ul>"},{"location":"CHANGELOG/#0123","title":"0.12.3","text":"<ul> <li>Change cli_args to argv0 and argv1p for utils.load_pipeline</li> </ul>"},{"location":"CHANGELOG/#0122","title":"0.12.2","text":"<ul> <li>Append <code>sys.argv[1:]</code> by default when <code>cli_args</code> is <code>None</code> in <code>utils.load_pipeline()</code></li> </ul>"},{"location":"CHANGELOG/#0121","title":"0.12.1","text":"<ul> <li>Add utils.is_loading_pipeline() to check if pipeline is loading</li> </ul>"},{"location":"CHANGELOG/#0120","title":"0.12.0","text":"<ul> <li>\u2728 Add utils.load_pipeline() to load pipeline</li> </ul>"},{"location":"CHANGELOG/#0111","title":"0.11.1","text":"<ul> <li>Dismiss warning for fillna method for pandas 2.1</li> <li>Fix channel.expand_dir() may add new column</li> </ul>"},{"location":"CHANGELOG/#0110","title":"0.11.0","text":"<ul> <li>Add Dockerfile for codesandbox</li> <li>Bump pandas to v2</li> <li>Bump argx to 0.2.10</li> </ul>"},{"location":"CHANGELOG/#0106","title":"0.10.6","text":"<ul> <li>\ud83d\udc1b Fix \"DeprecationWarning: np.find_common_type is deprecated\" from pandas (due to numpy 1.25 update)</li> </ul>"},{"location":"CHANGELOG/#0105","title":"0.10.5","text":"<ul> <li>\ud83c\udfa8 Allow starts to be set as a tuple</li> <li>\u2b06\ufe0f Bump python-simpleconf to 0.6 and other deps to latest versions</li> <li>\u2795 Add rtoml to deps (as python-simpleconf 0.6 may not depend on rtoml)</li> </ul>"},{"location":"CHANGELOG/#0104","title":"0.10.4","text":"<ul> <li>\u2b06\ufe0f Bump xqute to 0.2.3</li> </ul>"},{"location":"CHANGELOG/#0103","title":"0.10.3","text":"<ul> <li>\u2b06\ufe0f Bump xqute to 0.2.2</li> </ul>"},{"location":"CHANGELOG/#0102","title":"0.10.2","text":"<ul> <li>\ud83d\udc1b Fix exception handling in ProcPBar class update method</li> </ul>"},{"location":"CHANGELOG/#0101","title":"0.10.1","text":"<ul> <li>\u2728 Add <code>on_proc_script_computed</code> hook</li> </ul>"},{"location":"CHANGELOG/#0100","title":"0.10.0","text":"<ul> <li>\ud83d\udca5 Change hook <code>on_proc_init</code> to <code>on_proc_create</code></li> <li>\u2728 Add <code>on_proc_init</code> hook back but after the process initialized insteadl of before</li> <li>\ud83d\udc77 Add python 3.11 to CI</li> <li>\ud83d\udcdd Update documentation about updated hooks\u23ce</li> </ul>"},{"location":"CHANGELOG/#0911","title":"0.9.11","text":"<ul> <li>\ud83d\udc1b Make sure .envs of Proc subclasses are Diot objects</li> </ul>"},{"location":"CHANGELOG/#0910","title":"0.9.10","text":"<ul> <li>\ud83d\udc1b Fix <code>utils.mark</code> and <code>get_marked</code> when <code>__meta__</code> is <code>None</code></li> </ul>"},{"location":"CHANGELOG/#099","title":"0.9.9","text":"<ul> <li>\u26a1\ufe0f <code>utils.mark</code> and <code>get_marked</code> now work with <code>ProcGroup</code> and other classes</li> </ul>"},{"location":"CHANGELOG/#098","title":"0.9.8","text":"<ul> <li>\ud83d\udc1b Fix priority of core plugin</li> </ul>"},{"location":"CHANGELOG/#097","title":"0.9.7","text":"<ul> <li>\ud83d\udd27 Allow to inherit doc from base class for Pipen/Proc</li> </ul>"},{"location":"CHANGELOG/#096","title":"0.9.6","text":"<ul> <li>\ud83c\udfa8 Let plugins change and create workdir</li> <li>\ud83d\udd27 Change the default outdir suffix from <code>_results</code> to <code>-output</code></li> <li>\ud83d\udcd6 Update README file and add new plugins</li> </ul>"},{"location":"CHANGELOG/#095","title":"0.9.5","text":"<ul> <li>\ud83d\udd27 Fix workdir in log</li> </ul>"},{"location":"CHANGELOG/#094","title":"0.9.4","text":"<ul> <li>\ud83d\udc1b Use class name as pipeline name</li> </ul>"},{"location":"CHANGELOG/#093","title":"0.9.3","text":"<ul> <li>\ud83d\udc1b Set logging.lastResort to null handler</li> <li>\u2728 Allow to assign process directly to proc groups</li> <li>\ud83d\udd27 Change progress bar description length to 24</li> </ul>"},{"location":"CHANGELOG/#092","title":"0.9.2","text":"<ul> <li>\ud83c\udfa8 Rename to main plugin to core</li> <li>\ud83c\udfa8 Reformat log of pipeline info so that paths won't be truncated</li> </ul>"},{"location":"CHANGELOG/#091","title":"0.9.1","text":"<ul> <li>\u2b06\ufe0f Bump xqute to 0.2.1</li> </ul>"},{"location":"CHANGELOG/#090","title":"0.9.0","text":"<ul> <li>\u2b06\ufe0f Bump xqute to 0.2 so we can have slurm and ssh schedulers available</li> <li>\u2728 Add ssh and slurm scheduers</li> <li>\ud83c\udfa8 Improve code for dropping python 3.7</li> <li>\ud83d\udc77 Use 3.10 as main python version in CI</li> <li>\ud83d\udcdd Update docs for slurm and ssh schedulers</li> </ul>"},{"location":"CHANGELOG/#080","title":"0.8.0","text":"<ul> <li>\u2b06\ufe0f Drop support for python3.7</li> <li>\ud83c\udfa8 Don't slugify pipen or proc names anymore but require them to be valid filenames</li> <li>\ud83d\udc1b Fix process names being reused</li> <li>\ud83d\udcdd Update documentation with new job caching callback.</li> <li>\ud83c\udfa8 Move actions to on_job_cached hook for cached jobs</li> </ul>"},{"location":"CHANGELOG/#073","title":"0.7.3","text":"<ul> <li>\u2728 Add <code>--list</code> for <code>pipen profile</code> to list the names of available profiles</li> <li>\u2728 Add exception hook to show uncaught in log</li> <li>\u2728 Add <code>on_job_cached</code> hook</li> </ul>"},{"location":"CHANGELOG/#072","title":"0.7.2","text":"<ul> <li>\u2728 Add <code>utils.mark</code> and <code>get_marked</code> to mark a process     Unlike plugin_opts, template_opts or envs, these marks are not inherited in subclasses</li> </ul>"},{"location":"CHANGELOG/#071","title":"0.7.1","text":"<ul> <li>\u2b06\ufe0f Upgrade simplug to 0.2.3</li> <li>\ud83d\udcdd Add pipen-cli-config to plugin gallery</li> </ul>"},{"location":"CHANGELOG/#070","title":"0.7.0","text":"<ul> <li>\u2b06\ufe0f Update liquidpy to 0.8</li> <li>\u2728 Add <code>Proc.__meta__</code> that will not be inherited when subclassing</li> <li>\ud83c\udfa8 Put <code>procgroup</code> in <code>Proc.__meta__</code></li> <li>\u26a1\ufe0f Do not mutate <code>Proc.__doc__</code> when subclassing</li> <li>\u26a1\ufe0f Use mro to detect parent class of a Proc</li> </ul>"},{"location":"CHANGELOG/#064","title":"0.6.4","text":"<ul> <li>\ud83d\udd00 Set desc from docstring if not given for pipelines</li> </ul>"},{"location":"CHANGELOG/#063","title":"0.6.3","text":"<ul> <li>\ud83d\udd0a Trim right spaces of logs</li> </ul>"},{"location":"CHANGELOG/#062","title":"0.6.2","text":"<ul> <li>\u2b06\ufe0f Adopt xqute 0.1.5</li> </ul>"},{"location":"CHANGELOG/#061","title":"0.6.1","text":"<ul> <li>\ud83d\udc1b Fix path expansion for <code>~/.pipen.toml</code> in defaults.</li> </ul>"},{"location":"CHANGELOG/#060","title":"0.6.0","text":"<ul> <li>\u2728 Allow subclassing Pipen to create a pipeline (#151)</li> </ul>"},{"location":"CHANGELOG/#052","title":"0.5.2","text":"<ul> <li>\ud83d\udcdd Refactor codebase: unify type annotations and import future features</li> <li>\ud83d\udc1b Allow methods decorated by @ProcGroup.add_proc to return None</li> </ul>"},{"location":"CHANGELOG/#051","title":"0.5.1","text":"<ul> <li>\ud83d\ude91 Remove remaining more-itertools</li> </ul>"},{"location":"CHANGELOG/#050","title":"0.5.0","text":"<ul> <li>\u2796 Remove more-itertools</li> <li> <p>\u2728 Add <code>ProcGroup</code> to manage groups of processes.</p> <pre><code>from pipen import Proc, ProcGroup\n\nclass MyGroup(ProcGroup):\n\n    @ProcGroup.add_proc\n    def my_proc(self):\n        class MyProc(Proc):\n            ...\n        return MyProc\n\n    @ProcGroup.add_proc\n    def my_proc2(self):\n        class MyProc2(Proc):\n            requires = self.my_proc\n            ...\n        return MyProc2\n\npg = MyGroup()\n# Run as a pipeline\npg.as_pipen().set_data(...).run()\n\n# Integrate into a pipeline\n&lt;proc_of_a_pipeline&gt;.requires = pg.my_proc2\n</code></pre> </li> </ul>"},{"location":"CHANGELOG/#046","title":"0.4.6","text":"<ul> <li>\ud83d\udc1b Fix plugins command not listing plugins</li> </ul>"},{"location":"CHANGELOG/#045","title":"0.4.5","text":"<ul> <li>\ud83d\ude91 Fix banner alignment in terminal</li> </ul>"},{"location":"CHANGELOG/#044","title":"0.4.4","text":"<ul> <li>\ud83d\udc1b Fix when cli plugin has no docstring</li> <li>\ud83d\ude91 Exclude help from help sub-command itself</li> <li>\ud83d\ude91 Add cli plugin docstring as sub-command description</li> </ul>"},{"location":"CHANGELOG/#043","title":"0.4.3","text":"<ul> <li>\u2b06\ufe0f Bump <code>argx</code> to 0.2.2</li> <li>\ud83c\udfa8 Expose <code>parse_args()</code> to cli plugins</li> </ul>"},{"location":"CHANGELOG/#042","title":"0.4.2","text":"<ul> <li>\u2b06\ufe0f Bump <code>argx</code> to 0.2</li> </ul>"},{"location":"CHANGELOG/#041","title":"0.4.1","text":"<ul> <li>\ud83d\udc1b Fix cli plugin name</li> </ul>"},{"location":"CHANGELOG/#040","title":"0.4.0","text":"<ul> <li>\u2b06\ufe0f Upgrade python-slugify to ^0.8</li> <li>\u2b06\ufe0f Upgrade xqute to 0.1.4</li> <li>\u2b06\ufe0f Upgrade varname to 0.11</li> <li>\ud83d\udca5 Use argx instead of pyparam</li> </ul>"},{"location":"CHANGELOG/#0312","title":"0.3.12","text":"<ul> <li>\u2b06\ufe0f Upgrade python-slugify to ^7</li> </ul>"},{"location":"CHANGELOG/#0311","title":"0.3.11","text":"<ul> <li>\ud83d\udcdd Fix github workflow badges in README</li> <li>\ud83e\ude79 Fix pandas warning when less-column data passed to channel</li> </ul>"},{"location":"CHANGELOG/#0310","title":"0.3.10","text":"<ul> <li>\u2b06\ufe0f Upgrade xqute to 0.1.3</li> <li>\u2b06\ufe0f Upgrade datar to 0.11 and format test files</li> <li>\u2728 Add cli command version to show versions of deps</li> <li>\u2796 Remove rich as it is required by xqute already</li> </ul>"},{"location":"CHANGELOG/#039","title":"0.3.9","text":"<ul> <li>\u2b06\ufe0f Bump pipda to 0.11</li> <li>\u2b06\ufe0f Bump xqute to 0.1.2</li> </ul>"},{"location":"CHANGELOG/#038","title":"0.3.8","text":"<ul> <li>\u2b06\ufe0f Pump xqute to 0.1.1</li> </ul>"},{"location":"CHANGELOG/#037","title":"0.3.7","text":"<ul> <li>\u2b06\ufe0f Upgrade varname to 0.10</li> </ul>"},{"location":"CHANGELOG/#036","title":"0.3.6","text":"<ul> <li>\u2b06\ufe0f Upgrade pipda to 0.7.2, varname to 0.9.1, datar to 0.9</li> </ul>"},{"location":"CHANGELOG/#035","title":"0.3.5","text":"<ul> <li>\ud83d\udc1b Fix <code>nexts</code> being inherited for <code>Proc</code> subclasses</li> </ul>"},{"location":"CHANGELOG/#034","title":"0.3.4","text":"<ul> <li>\u2728 Print pipen version in CLI: pipen plugins</li> <li>\ud83e\ude79 Make use of full terminal width for non-panel elements in log</li> <li>\ud83e\ude79 Extend width to 256 when terminal width cannot be detected while logging (most likely logging to a text file)</li> </ul>"},{"location":"CHANGELOG/#033","title":"0.3.3","text":"<ul> <li>\u267f\ufe0f Change default log width to 100</li> <li>\ud83e\ude79 Fix broken panel in log content with console width cannot be detected</li> </ul>"},{"location":"CHANGELOG/#032","title":"0.3.2","text":"<ul> <li>\u2b06\ufe0f Upgrade rtoml to v0.8</li> <li>\u2b06\ufe0f Upgrade pipda to v0.6</li> </ul>"},{"location":"CHANGELOG/#031","title":"0.3.1","text":"<ul> <li>\ud83e\ude79 Hide config meta data in pipeline information</li> </ul>"},{"location":"CHANGELOG/#030","title":"0.3.0","text":"<ul> <li>\u2b06\ufe0f Upgrade dependencies</li> <li>\ud83d\udccc Use <code>rtoml</code> instead of <code>toml</code> (see https://github.com/pwwang/toml-bench)</li> <li>\ud83e\ude79 Dump job signature to file directly instead of dump to a string first</li> <li>\ud83d\udc77 Add python 3.10 to CI</li> <li>\ud83d\udcdd Add dependencies badge to README.md</li> </ul>"},{"location":"CHANGELOG/#0216","title":"0.2.16","text":"<ul> <li>\ud83d\udccc Pin dep versions</li> <li>\ud83e\ude79 Allow to set workdir from Pipen constructor</li> </ul>"},{"location":"CHANGELOG/#0215","title":"0.2.15","text":"<ul> <li>\ud83e\ude79 Fix <code>FutureWarning</code> in <code>Proc._compute_input()</code></li> <li>\ud83e\ude79 Add <code>__doc__</code> for <code>Proc.from_proc()</code></li> <li>\ud83d\udccc Pin deps for docs</li> </ul>"},{"location":"CHANGELOG/#0214","title":"0.2.14","text":"<ul> <li>\ud83e\ude79 Shorten pipeline info in log for long config options</li> <li>\ud83d\udc1b Fix cached jobs being put into queue</li> <li>\ud83e\ude79 Shorten job debug messages when hit limits</li> <li>\ud83d\ude91 Remove sort_dicts for pprint.pformat for py3.7</li> </ul>"},{"location":"CHANGELOG/#0213","title":"0.2.13","text":"<ul> <li>\ud83e\ude79 Don't require <code>job.signature.toml</code> to force cache a job</li> </ul>"},{"location":"CHANGELOG/#0212","title":"0.2.12","text":"<ul> <li>\ud83d\udc1b Hotfix for typos in <code>Proc.__init_subclass__()</code></li> </ul>"},{"location":"CHANGELOG/#0211","title":"0.2.11","text":"<ul> <li>\ud83e\ude79 Update <code>envs</code>, <code>plugin_opts</code> and <code>scheduler_opts</code> while subclassing processes.</li> </ul>"},{"location":"CHANGELOG/#0210","title":"0.2.10","text":"<ul> <li>\u2728 Add hook <code>on_proc_input_computed</code></li> <li>\ud83e\ude79 Default new process docstring to \"Undescribed process.\"</li> </ul>"},{"location":"CHANGELOG/#029","title":"0.2.9","text":"<ul> <li>\u2728 Allow <code>requires</code> to be set by <code>__setattr__()</code></li> </ul>"},{"location":"CHANGELOG/#028","title":"0.2.8","text":"<ul> <li>\ud83e\ude79 Forward fill na for input data</li> </ul>"},{"location":"CHANGELOG/#027","title":"0.2.7","text":"<ul> <li>\ud83e\ude79 Fix process plugin_opts not inherited from pipeline</li> </ul>"},{"location":"CHANGELOG/#026","title":"0.2.6","text":"<ul> <li>\ud83c\udfa8 Make <code>pipen._build_proc_relationships()</code> public and don't rebuild the relations</li> <li>\u2728 Allow pipenline name to be obtained from assignment</li> </ul>"},{"location":"CHANGELOG/#025","title":"0.2.5","text":"<ul> <li>\ud83e\ude79 Allow relative script path to be inherited</li> <li>\ud83d\udc1b Fix column order from depedency processes</li> <li>\ud83e\ude79 Fix doc not inherited for processes</li> </ul>"},{"location":"CHANGELOG/#024","title":"0.2.4","text":"<ul> <li>\u2728 Add execution order for processes</li> </ul>"},{"location":"CHANGELOG/#023","title":"0.2.3","text":"<ul> <li>\u26a1\ufe0fSpeed up package importing</li> </ul>"},{"location":"CHANGELOG/#022","title":"0.2.2","text":"<ul> <li>\ud83d\udc1b Load CLI plugins at runtime</li> </ul>"},{"location":"CHANGELOG/#021","title":"0.2.1","text":"<ul> <li>\ud83c\udfa8 Allow CLI plugin to have different name than the command</li> </ul>"},{"location":"CHANGELOG/#020","title":"0.2.0","text":"<ul> <li>\ud83d\udca5 Restructure CLI plugins</li> </ul>"},{"location":"CHANGELOG/#014","title":"0.1.4","text":"<ul> <li>\ud83e\ude79 Use brackets to indicate cached jobs</li> <li>\ud83e\ude79 Run on_complete hook only when no exception happened</li> <li>\ud83e\ude79 Let <code>on_proc_init</code> to modify process <code>workdir</code></li> <li>\ud83d\udc1b Fix when <code>nexts</code> affected by parent <code>nexts</code> assignment when parent in <code>__bases__</code></li> </ul>"},{"location":"CHANGELOG/#013","title":"0.1.3","text":"<ul> <li>\u2728 Add <code>on_proc_init()</code> hook to enables plugins to modify the default attributes of processes</li> <li>\ud83d\udca5 Rename <code>Proc.args</code> to <code>Proc.envs</code></li> </ul>"},{"location":"CHANGELOG/#012","title":"0.1.2","text":"<ul> <li>\ud83d\udca5 Use <code>set_starts()</code> and <code>set_data()</code> to set start processes of a pipeline.</li> </ul>"},{"location":"CHANGELOG/#011","title":"0.1.1","text":"<ul> <li>\ud83d\udca5 Allow plugins to modify other configs via on_setup() hook</li> <li>\ud83c\udfa8 Move progress bar to the last</li> <li>\ud83e\ude79 Warn when no input_data specified for start process</li> <li>\ud83d\udcac Change end to export</li> <li>\ud83d\ude9a Move on_init() so it's able to redefine default configs</li> <li>\ud83d\udca5 Change <code>exec_cmd</code> hook of cli plugin to <code>exec_command</code></li> </ul>"},{"location":"CHANGELOG/#010","title":"0.1.0","text":"<p>It's now fully documented. See documentations.</p>"},{"location":"CHANGELOG/#004","title":"0.0.4","text":"<ul> <li>Clear output if not cached.</li> <li>Make process running order fixed</li> </ul>"},{"location":"CHANGELOG/#003","title":"0.0.3","text":"<ul> <li>Fix caching issue</li> <li>Add singleton to proc to force singleton</li> <li>Log an empty line after all processes finish</li> <li>Allow input to be None</li> <li>Separate channels from different required procs</li> <li>Move proc prepare before run</li> <li>Change the order proc banner printing, making sure it prints before other logs for the proc</li> <li>FIx job not cached if input is missing</li> <li>Don't redirect output only if absolute path specified</li> <li>Make input files resolved(absolute path)</li> <li>Give more detailed ProcDependencyError</li> <li>Force job status to be failed when Ctrl + c</li> <li>Fix files for input when it is a pandas dataframe</li> <li>Add job name prefix for scheduler</li> <li>Adopt datar for channels</li> </ul>"},{"location":"CHANGELOG/#002","title":"0.0.2","text":"<ul> <li>Add on_proc_property_computed hook</li> <li>Add plugin options for pipen construct</li> <li>Keep args, envs, scheduler_opts and plugin_opts as Diot object for procs</li> <li>Fix shebang not working in script</li> <li>Make sure job rendering data are stringified.</li> <li>Move starts as a method so that pipelines can be initialized before processes.</li> <li>Use plyrda instead of siuba for channel</li> <li>Add template rendering error to indicate where the rendering error happens;</li> <li>Add succeeded to on_complete hook;</li> <li>Add hook on_proc_start;</li> <li>Add argument succedded for hook on_proc_done;</li> <li>Realign pipeline and proc names in progress bars</li> <li>Remove debug log in job preparing, which will appear on the top of the logs</li> </ul>"},{"location":"CHANGELOG/#001","title":"0.0.1","text":"<ul> <li>Reimplement PyPPL using asyncio</li> </ul>"},{"location":"basics/","title":"Basics","text":""},{"location":"basics/#layers-of-a-pipeline","title":"Layers of a pipeline","text":"<p>The pipeline consists of channels and processes. A process may have many jobs. Each job uses the corresponding elements from the input channel of the process (a row of the input channel/dataframe), and generates values for output channel. Actually, what you need to do is just specify the first input channel, and then tell <code>pipen</code> the dependencies of the processes. The later processes will use the output channel of the processes they depend on. Of course, you can also modify the output channel to match the input of the next processes, using functions.</p>"},{"location":"basics/#folder-structure","title":"Folder structure","text":"<pre><code>./\n|- pipeline.py\n`- &lt;pipeline-workdir&gt;/\n   `- &lt;pipeline-name&gt;/\n      |- proc.name\n      `- &lt;job.index&gt;/\n         |- input/\n         |- output/\n         |- job.signature.toml\n         |- job.script\n         |- job.rc\n         |- job.stdout\n         |- job.stderr\n         |- job.status\n         `- job.wrapped.&lt;scheduler&gt;\n</code></pre> Path Content Memo <code>&lt;pipeline-workdir&gt;</code> Where the pipeline directories of all processes of current pipeline are located. Can be set by <code>workdir</code> <code>&lt;pipeline-name&gt;</code> The slugified name of the pipeline. <code>&lt;job.index&gt;/</code> The job directory Starts with <code>0</code> <code>&lt;job.index&gt;/output/</code> Where you can find all the output files If this is an end process, it should be a link to the output directory of this process of the pipeline <code>&lt;job.index&gt;/job.signature.toml</code> The signature file of the job, used to check if job is cached <code>&lt;job.index&gt;/job.script</code> The rendered script file <code>&lt;job.index&gt;/job.rc</code> To file containing the return code <code>&lt;job.index&gt;/job.stdout</code> The STDOUT of the script <code>&lt;job.index&gt;/job.stderr</code> The STDERR of the script <code>&lt;job.index&gt;/job.statis</code> The status of the job <code>&lt;job.index&gt;/job.wrapped.&lt;scheduler&gt;</code> The wrapper for the scheduler to wrap the script"},{"location":"caching/","title":"Caching","text":""},{"location":"caching/#job-caching","title":"Job caching","text":"<p>If <code>cache</code> set to <code>False</code> (detected in the sequence of configuration files, <code>Pipen</code> constructor, and process definition), the job is running anyway regardless of previous runs.</p> <p>If a previous run of a job fails, the job will be running anyway.</p> <p>If a job is done successfully, a signature file will be generated for the job. When we try to run the job again, the signature will be used to check if we can skip running the job again but to use the results generated by previous run.</p> <p>We can also do a force-cache for a job by setting <code>cache</code> to <code>\"force\"</code>. This make sure of the results of previous successful run regardless of input or script changes. This is useful for the cases that, for example, you make some changes to input/script, but you don't want them to take effect immediately, especially when the job takes long time to run.</p>"},{"location":"caching/#job-signature","title":"Job signature","text":"<p>The signature of a job consists of input types and data, output types and data, and lastest time (<code>lastest_time</code>) any files/directories from the script, input or output files are generated/modified. So these siutations will make job-cache checking fail (job will start over):</p> <ol> <li>Any changes in <code>input</code> or <code>output</code> types</li> <li>Any changes in <code>input</code> or <code>output</code> data</li> <li>Any changes to <code>script</code></li> <li>Any touches to input files (since they will make the last modified time &gt; <code>lastest_time</code>)</li> <li>Any touches to input directories</li> <li>Use <code>dirsig</code> as the depth to check the files under the directories</li> <li>Otherwise if it is <code>0</code>, only the directories themselves are checked. Note that modify a file inside a directory may not change the last modified time of the directory itself.</li> <li>Any deletions to the output files/directories    Note that only the files/directories specified by <code>output</code> are checked. Files or subdirectories in the output directories will NOT be checked.</li> </ol>"},{"location":"channels/","title":"Channels","text":"<p>Channels are used to pass data from one process to another. It is actually a <code>pandas.DataFrame</code> object, where each column corresponds to an input key and each row corresponds to a job.</p> <p>The values for different variables in different jobs wil be:</p> Job Index v1 v2 v3 0 a1 b1 c1 1 a2 b2 c2 ... ... ... ... <p>With a process definition:</p> <pre><code>class MyProcess(Proc):\n    input = \"v1, v2, v3\"\n    input_data = df #  The above data frame\n</code></pre> <p>Then:</p> Job index Template Rendered to 0 <code>{{in.v1}}</code> <code>a1</code> 0 <code>{{in.v2}}</code> <code>b1</code> 0 <code>{{in.v3}}</code> <code>c1</code> 1 <code>{{in.v1}}</code> <code>a2</code> 1 <code>{{in.v2}}</code> <code>b2</code> 1 <code>{{in.v3}}</code> <code>c2</code> ... ... ... <p>The column names don't have to match the exact input keys. If <code>pipen</code> finds any of the input keys present in the data, just use them. However, if any input keys cannot find in the data frame, we will use the first couple of columns.</p> <p>For example: <pre><code>class MyProcess2(Proc):\n    input = \"v4, v3\"\n    input_data = df #  The above data frame\n</code></pre></p> <p>The for job#0, <code>{{in.v4}}</code> will be rendered as <code>a1</code> (using column <code>v1</code> in the data), and <code>{{in.v3}}</code> as <code>c1</code> (using column <code>v3</code>).</p>"},{"location":"channels/#creating-channels","title":"Creating channels","text":"<p>Since channels are just data frames, so whatever creates a pandas data frame, can be used to create a channel. Besides, a couple of class methods are avaible to create channels:</p> <ul> <li> <p><code>Channel.create(...)</code></p> <p>This takes a list of values to create a channel. If a data frame is passed, will return that data frame.</p> <p>If each element in the list is a tuple, the list is used to create a data frame directly, just like:</p> <pre><code>from pandas import DataFrame\nch = Channel.create([(1,2), (3,4)])\n# ch = DataFrame([(1,2), (3,4)])\n#         0       1\n#   &lt;int64&gt; &lt;int64&gt;\n# 0       1       2\n# 1       3       4\n</code></pre> <p>If each element is not a tuple (even it is a list), it is converted to tuple: <pre><code>ch = Channel.create([1, 2])\n# equvalent to:\n# ch = Channel.create([(1, ), (2, )])\n</code></pre></p> <p>The <code>input_data</code> is passed to this class method to create the input channel.</p> </li> <li> <p><code>Channel.from_glob(...)</code></p> <p>This takes a glob pattern to match the files to create a single-column channel.</p> <p>You can also filter the types of files by <code>ftype</code>: - <code>any</code>: to match any files (default) - <code>link</code>: to mach any links - <code>dir</code>: to match any directories - <code>file</code>: to match any files</p> <p>You may also sort the files using <code>sortby</code>: - <code>name</code>: sort the files by their basename (default) - <code>mtime</code>: sort the files by their last modified time - <code>size</code>: sort by file size</p> <p>When <code>reverse</code> is True, the above sortings are reversed.</p> </li> <li> <p><code>Channel.from_pairs(...)</code></p> <p>Like <code>Channel.from_glob()</code> but create a double-column channel.</p> </li> <li> <p><code>Channel.from_csv(...)</code></p> <p>Uses <code>pandas.read_csv()</code> to create a channel</p> </li> <li> <p><code>Channel.from_excel(...)</code></p> <p>Uses <code>pandas.read_excel()</code> to create a channel</p> </li> <li> <p><code>Channel.from_table(...)</code></p> <p>Uses <code>pandas.read_table()</code> to create a channel</p> </li> </ul>"},{"location":"channels/#builtin-verbsfunctions-to-transform-channels","title":"Builtin verbs/functions to transform channels","text":"<p><code>pipen</code> uses <code>pipda</code> to create some verbs/functions to transform channels, so that you can use them with piping syntax:</p> <pre><code>channel &gt;&gt; verb(...)\n</code></pre>"},{"location":"channels/#expanding-a-channel-by-directory-expand_dir","title":"Expanding a channel by directory: <code>expand_dir()</code>","text":"<p>Sometimes we prepare files in one process (for example, split a big file into small ones in a directory), then handle these files by different jobs in another process, so that they can be processed simultaneously.</p> <p></p> <p>For example: <pre><code>class P1(Proc):\n    # the original file: a.txt\n    input  = \"infile:file\"\n    input_data = [\"a.txt\"]\n    output = \"outdir:dir:outdir\"\n    script = \"# the script to split a.txt to 1.txt, 2.txt, 3.txt ... to {{out.outdir}}\"\n\nclass P2(Proc):\n    requires = P1\n    # expand channel [(\"outdir/a/\",)] to channel:\n    # [(\"outdir/a/1.txt\",), (\"outdir/a/2.txt\",), (\"outdir/a/3.txt\",), ...]\n    input = \"infile:file\"\n    input_data = lambda ch: ch &gt;&gt; expand_dir(pattern=\"*.txt\")\n    # outfile: 1.result, 2.result, ...\n    output  = \"outfile:file:{{in.infile.split('/')[-1].split('.')[0]}}.result\"\n    script  = \"\"\"\n    # work on {{in.infile}} (1.txt, 2.txt, 3.txt, ...)\n    # to result file {{out.outfile}} (1.result, 2.result, 3.result, ...)\n    \"\"\"\n\n# Run 3 jobs in a batch simultaneously\nPipen(forks=3).run(P1)\n</code></pre></p> <p>If the channel is a multi-column channel, you can also specify <code>col</code> to expand only on that column, values of other columns will be copied to the expanded rows/jobs.</p> <p>You can also filter and sort the expanded files using arguments <code>ftype</code>, <code>sortby</code> and <code>reverse</code>, just like when we use <code>Channel.from_glob(...)</code></p> <p>Caution</p> <ul> <li><code>expand_dir(...)</code> only works for single-row channels, which will be expanded to <code>N</code> (number of files included). If original channel has more than 1 row, only first row will be used, and other rows will be ignored.</li> <li>Only the value of the column to be expanded will be changed, values of other columns remain the same.</li> </ul>"},{"location":"channels/#collapsing-a-channel-by-files-in-a-common-ancestor-directory-collapse_files","title":"Collapsing a channel by files in a common ancestor directory: <code>collapse_files(...)</code>","text":"<p>It's basically the reverse process of <code>expand_dir()</code>. It applies when you deal with different files and in next process you need them all involved (i.e. combine the results):</p> <p></p> <p>For example: <pre><code>class P1(Proc):\n    input = \"infile:file\"\n    input_data = [\"/a/b/1.txt\", \"/a/b/2.txt\", \"/a/b/3.txt\"]\n    output = \"outfile:file:{{in.infile.split('/')[-1].split('.')[0] | append: '.txt2'}}\"\n    script = \"\"\"\n    # the script to deal with each input file:\n    # {{in.infile}} -&gt; {{out.outfile}}\n    \"\"\"\n\nclass P2(Proc):\n    requires = P1\n    # collapse channel [(\"&lt;outdir&gt;/1.txt2\",), (\"&lt;outdir&gt;/2.txt2\",), (\"&lt;outdir&gt;/3.txt2\",)]\n    # to channel: [(\"&lt;outdir&gt;/\", )]\n    input   = \"indir:file\"\n    input_data = lambda ch: ch &gt;&gt; collapse_files()\n    output  = \"outfile:file:{{in.indir.split('/')[-1]}}.result\"\n    script  = \"\"\"\n    # combine 1.txt2, 2.txt2, 3.txt3 in {{in.indir}} to {{out.outfile}}\n    \"\"\"\n\nPipen().run(P1)\n</code></pre></p> <p>Similarly, if we have multiple columns, you may specify the column by index or name to collapse by: <code>ch &gt;&gt; collapse_files(col=...)</code></p> <p>Caution</p> <ul> <li><code>os.path.dirname(os.path.commonprefix(...))</code> is used to detect the common ancestor directory, so the files could be <code>['/a/1/1.file', '/a/2/1.file']</code>. In this case <code>/a/</code> will be returned.</li> <li>values at other columns should be the same. They will NOT be checked! The values at the first row will be used.</li> </ul>"},{"location":"cli/","title":"Command line iterface","text":"<p><code>pipen</code> has a CLI tool that you can run from command line.</p> <p>To run it:</p> <pre><code>\u276f pipen --help\nUsage: pipen [-h] {version,profile,plugins,help} ...\n\nCLI Tool for pipen v0.4.2\n\nOptional Arguments:\n  -h, --help            show help message and exit\n\nSubcommands:\n    version             Print versions of pipen and its dependencies\n    profile             List available profiles.\n    plugins             List installed plugins\n    help                Print help for commands\n</code></pre>"},{"location":"cli/#writing-a-plugin-to-extend-the-cli","title":"Writing a plugin to extend the cli","text":""},{"location":"cli/#cli-plugin-abstract-class","title":"CLI plugin abstract class","text":"<p>A CLI plugin has to be a subclass of <code>pipen.cli.CLIPlugin</code>.</p> <p>A CLI plugin has to define a <code>name</code> property, which also is the sub-command of the plugin.</p> <p>There are a couple of methods of <code>pipen.cli.CLIPlugin</code> to extend for a plugin:</p> <ul> <li> <p><code>__init__(self, parser, subparser)</code>: initialize the plugin   It takes the main parser and the subparser of the sub-command as arguments. You can add arguments to the parser or subparser here.   Check argx for more information about how to define arguments.</p> </li> <li> <p><code>parse_args(self, known_parsed, unparsed_argv)</code>: parse the arguments   It takes the known parsed arguments and the unparsed argument vector as arguments, allowing   you to do custom parsing. It should return the parsed arguments.   By default, <code>known_parsed</code> is returned.</p> </li> <li> <p><code>exec_command(self, args)</code>: execute the command   It takes the parsed arguments as argument. It should execute the command as you wish.</p> </li> </ul>"},{"location":"cli/#loading-cli-plugins","title":"loading CLI plugins","text":"<p>Like pipen plugins, templates, and schedulers, there are two ways to load the CLI plugins:</p> <ol> <li> <p>Use the plugin directly:</p> <pre><code>from pipen.cli import cli_plugin\n\ncli_plugin.register(&lt;your plugin&gt;)\n</code></pre> </li> <li> <p>Use the entry points with group name <code>pipen_cli</code></p> </li> </ol>"},{"location":"cli/#the-profile-subcommand","title":"The <code>profile</code> subcommand","text":"<p>It is used to list the configurations/profiles in current directory. Run <code>pipen profile</code> or <code>pipen help profile</code> to get more information.</p>"},{"location":"cli/#the-plugins-subcommand","title":"The <code>plugins</code> subcommand","text":"<p>This subcommand is used to list the plugins for <code>pipen</code> itself, templates, scheduler and cli. Run <code>pipen plugins</code> or <code>pipen help plugins</code> to get more information.</p>"},{"location":"cli/#the-version-subcommand","title":"The <code>version</code> subcommand","text":"<p>This command prints the versions of <code>pipen</code> and its dependencies.</p>"},{"location":"cli/#cli-plugin-gallery","title":"CLI plugin gallery","text":"<ul> <li><code>pipen-cli-init</code>: A pipen CLI plugin to create a pipen project (pipeline)</li> <li><code>pipen-cli-ref</code>: Make reference documentation for processes</li> <li><code>pipen-cli-require</code>: A pipen cli plugin check the requirements of a pipeline</li> <li><code>pipen-cli-run</code>: A pipen cli plugin to run a process or a pipeline</li> </ul>"},{"location":"cloud/","title":"Cloud support","text":"<p>Since <code>v0.16.0</code>, <code>pipen</code> supports the cloud naively. There are two ways by means of cloud support:</p> <ul> <li>Run the pipeline locally (or schedulers like <code>sge</code>, <code>slurm</code>, etc.) and save the files to the cloud.</li> <li>Run the pipeline on the cloud.</li> </ul>"},{"location":"cloud/#run-the-pipeline-locally-and-save-the-files-to-the-cloud","title":"Run the pipeline locally and save the files to the cloud","text":"<p>To run the pipeline locally and save the files to the cloud, you need to install <code>pipen</code> with cloud support:</p> <pre><code>pip install xqute[cloudsh]\n# To support a specific cloud service provider\npip install cloudpathlib[s3]\npip install cloudpathlib[gs]\npip install cloudpathlib[azure]\n</code></pre> <p>The you can directly assign a cloud path as a pipeline working directory:</p> <pre><code>from pipen import Pipen, Proc, run\n\n\nclass P1(Proc):\n    \"\"\"Sort input file\"\"\"\n    input = \"in:var\"\n    input_data = [\"Hello World\"]\n    output = \"outfile:file:out.txt\"\n    # Note that out.outfile is on the cloud but the script is executed locally\n    # we can use cloudsh to save the output to the cloud\n    script = \"echo {{in.in}} | cloudsh sink {{out.outfile}}\"\n\n\nclass MyPipeline(Pipen):\n    starts = P1\n    workdir = \"gs://mybucket/mypipeline/workdir\"\n    output = \"gs://mybucket/mypipeline/output\"\n\n\nif __name__ == \"__main__\":\n    MyPipeline().run()\n</code></pre> <p>Like the following figure, the pipeline is run locally but the meta information is grabbed from and saved to the cloud (workdir). No local files are generated.</p> <p>For the output files, if a process is a non-export process, the output files are saved to the workdir. If a process is an export process, the output files are saved to the output directory (export dir).</p> <p></p>"},{"location":"cloud/#run-the-pipeline-on-the-cloud","title":"Run the pipeline on the cloud","text":"<p>Currently, <code>pipen</code> only supports running the pipeline on the cloud with google batch jobs.</p> <p>To run the pipeline on the cloud, you need to install <code>pipen</code> with cloud support:</p> <pre><code>pip install xqute[gs]\n</code></pre> <p>It is used to communicate with google cloud storage files. No <code>cloudsh</code> is needed, since operating the cloud files will be happening on the cloud (with the cloud paths mounted to the VM). You also need to have google cloud sdk installed and configured, which is used to communicate with google batch jobs (submit jobs, get job status, etc.).</p> <pre><code>from pipen import Pipen, Proc, run\n\n\nclass P1(Proc):\n    \"\"\"Sort input file\"\"\"\n    input = \"in:var\"\n    input_data = [\"Hello World\"]\n    output = \"outfile:file:out.txt\"\n    # Note that out.outfile is on the cloud but the script is executed locally\n    # we can use cloudsh to save the output to the cloud\n    script = \"echo {{in.in}} | cloudsh sink {{out.outfile}}\"\n\n\nclass MyPipeline(Pipen):\n    starts = P1\n    workdir = \"gs://mybucket/mypipeline/workdir\"\n    output = \"gs://mybucket/mypipeline/output\"\n    scheduler = \"gbatch\"\n\n\nif __name__ == \"__main__\":\n    MyPipeline().run()\n</code></pre> <p>The only difference is that we need to set <code>scheduler</code> to <code>gbatch</code> (google batch jobs).</p> <p>As shown in the following figure, the pipeline is run on the cloud platform, and the workdir and export dir will be mounted to the VM. So the process script can directly access the cloud files, no <code>cloudsh</code> or <code>gcloud</code> tools are needed.</p> <p></p>"},{"location":"configurations/","title":"Configurations","text":""},{"location":"configurations/#configuration-items","title":"Configuration items","text":"<p>There are two levels of configuration items in <code>pipen</code>: pipeline level and process level.</p> <p>There are only 3 configuration items at pipeline level:</p> <ul> <li><code>loglevel</code>: The logging level for the logger (Default: <code>\"info\"</code>)</li> <li><code>workdir</code>: Where the metadata and intermediate files are saved for the pipeline (Default: <code>./.pipen</code>)</li> <li><code>plugins</code>: The plugins to be enabled or disabled for the pipeline</li> </ul> <p>These items cannot be set or changed at process level.</p> <p>Following items are at process level. They can be set changed at process level so that they can be process-specific. You may also see some of the configuration items introduced here</p> <ul> <li><code>cache</code>: Should we detect whether the jobs are cached? See also here</li> <li><code>dirsig</code>: When checking the signature for caching, whether should we walk through the content of the directory? This is sometimes time-consuming if the directory is big.</li> <li><code>error_strategy</code>: How to deal with the errors: retry, ignore or halt. See also here</li> <li><code>num_retries</code>: How many times to retry to jobs once error occurs.</li> <li><code>template</code>: efine the template engine to use. See also here</li> <li><code>template_opts</code>: Options to initialize the template engine (will inherit from pipeline level)</li> <li><code>forks</code>: How many jobs to run simultaneously?</li> <li><code>lang</code>: The language for the script to run. See also here</li> <li><code>plugin_opts</code>: Options for process-level plugins, will inherit from pipeline level</li> <li><code>scheduler</code>: The scheduler to run the jobs</li> <li><code>scheduler_opts</code>: The options for the scheduler, will inherit from pipeline level</li> <li><code>submission_batch</code>: How many jobs to be submited simultaneously</li> </ul>"},{"location":"configurations/#configuration-priorities","title":"Configuration priorities","text":"<p>There are different places to set values for the configuration items (priorities from low to high):</p> <ul> <li> <p>The configuration files (priorities from low to high):</p> </li> <li> <p><code>~/.pipen.toml</code></p> </li> <li><code>./.pipen.toml</code></li> <li><code>PIPEN.osenv</code></li> </ul> <p>See here for how the configuration files are loaded.   <code>pipen</code> uses <code>TOML</code> as configuration language, see here for more information about <code>toml</code> format.</p> <ul> <li>The arguments of <code>Pipen</code> constructor</li> <li>The process definition</li> </ul> <p>Note</p> <p>The configurations from configuration files are with profiles. If the same profile name appears in multiple configuration files, the items will be inherited from the lower-priority files.</p> <p>Note</p> <p>Special note for <code>lang</code>.</p> <p>If it is not set at process level, and there are shebang in the script, whatever you specified at pipeline level (including in the configuration files), it will be ignored and the interpreter in the shebang will be used.</p> <p>See also script</p> <p>Tip</p> <p>If you have nothing set at <code>Pipen</code> constructor or process definition for a configuration item, the <code>PIPEN.osenv</code> is useful to use a different value than the one set in other configuration files. For example, to disable cache for all processes:</p> <pre><code>PIPEN_DEFAULT_cache=0 python ./pipeline.py ...\n</code></pre>"},{"location":"configurations/#profiles","title":"Profiles","text":"<p>You can have different profiles in configuration files:</p> <p><code>~/.pipen.toml</code> <pre><code>[default]\nscheduler = \"local\"\n\n[sge]\nscheduler = \"sge\"\n\n[sge.schduler_opts]\nsge_q = \"1-day\"\n</code></pre></p> <p>To use the <code>sge</code> profile:</p> <pre><code>Pipen().run(P1, profile=\"sge\")\n</code></pre> <p>You can also have a configuration in current directory:</p> <p><code>./.pipen.toml</code> <pre><code>[sge.scheduler_opts]\nsge_q = \"7-days\"\n</code></pre></p> <p>Then the queue to run the jobs will be <code>7-days</code>. Note that we didn't specify the <code>scheduler</code> in <code>./.pipen.toml</code>, which is inherited from <code>~/.pipen.toml</code>.</p>"},{"location":"defining-proc/","title":"Defining a process","text":"<p>A pipeline consists of many processes, which could own multiple jobs that run in parallel.</p>"},{"location":"defining-proc/#definingcreating-processes","title":"Defining/Creating processes","text":"<p><code>pipen</code> has two (preferred) ways to define processes:</p>"},{"location":"defining-proc/#subclassing-pipenproc","title":"Subclassing <code>pipen.Proc</code>","text":"<pre><code>from pipen import Proc\n\nclass MyProcess(Proc):\n    ... # process configurations\n</code></pre> <p>The configurations are specified as class variables of the class.</p>"},{"location":"defining-proc/#using-class-method-procfrom_proc","title":"Using class method <code>Proc.from_proc()</code>","text":"<p>If you want to reuse a defined process, you can either subclass it:</p> <pre><code>class MyOtherProcess(MyProcess):\n    ... # configurations inherited from MyProcess\n</code></pre> <p>Or use <code>Proc.from_proc()</code>:</p> <pre><code># You can also pass the configurations you want to override\nMyOtherProcess = Proc.from_proc(MyProcess, ...)\n</code></pre> <p>Note that <code>Proc.from_proc()</code> cannot override all configurations/class variables, because we assume that there are some shared configurations if you want to \"copy\" from another process.</p> <p>These shared configurations are:</p> <ol> <li>Template engine and its options (<code>template</code> and <code>template_opts</code>)</li> <li>Script template (<code>script</code>)</li> <li>Input keys (<code>input</code>)</li> <li>Language/Interpreter of the script (<code>lang</code>)</li> <li>Output keys (<code>output</code>)</li> </ol> <p>All other configurations can be passed to <code>Proc.from_proc()</code> to override the old ones.</p> <p>For all configurations/class variables for a process, see next section.</p> <p>You don't need to specify the new name of the new process, the variable name on the left-handle side will be used if <code>name</code> argument is not provided to <code>Proc.from_proc()</code>. For example:</p> <pre><code>NewProc = Proc.from_proc(OldProc)\n# NewProc.name == \"NewProc\"\n</code></pre> <p>But you are able to assign a different name to a new process if you want. For example:</p> <pre><code>NewProc = Proc.from_proc(OldProc, name=\"NewProc2\")\n# NewProc.name = \"NewProc2\"\n</code></pre>"},{"location":"defining-proc/#how-about-instantiation-of-proc-directly","title":"How about instantiation of <code>Proc</code> directly?","text":"<p>You are not allowed to do that. <code>Proc</code> is an abstract class, which is designed to be subclassed.</p>"},{"location":"defining-proc/#how-about-instantiation-of-a-proc-subclass","title":"How about instantiation of a <code>Proc</code> subclass?","text":"<p>Nope, in <code>pipen</code>, a process is a <code>Proc</code> subclass itself. The instances of the subcleasses are used internally, and they are singletons. In most cases, you don't need to use the instances, unless you want to access the computed properties of the instances, including:</p> <ul> <li><code>pipeline</code>: The pipeline, which is a <code>Pipen</code> object</li> <li><code>pbar</code>: The progress bar for the process, indicating the job status of this process</li> <li><code>jobs</code>: The jobs of this process</li> <li><code>xqute</code>: The <code>Xqute</code> object to manage the job running.</li> <li><code>template</code>: The template engine (a <code>pipen.template.Template</code> object)</li> <li><code>template_opts</code>: The template options (overwritten from config by the <code>template_opts</code> class variable)</li> <li><code>input</code>: The sanitized input keys and types</li> <li><code>output</code>: The compiled output template, ready for the jobs to render with their own data</li> <li><code>scheduler</code>: The scheduler object (inferred from the name or sheduler object from the <code>scheduler</code> class variable)</li> <li><code>script</code>: The compiled script template, ready for the jobs to render with their own data</li> </ul>"},{"location":"defining-proc/#how-about-copydeep-copy-of-a-proc-subclass","title":"How about copy/deep-copy of a <code>Proc</code> subclass?","text":"<p>Nope. Copy or deep-copy of a <code>Proc</code> subclass won't trigger <code>__init_subclass__()</code>, where consolidate the process name from the class name if not specified and connect the required processes with the current one. Copy or deep-copy keeps all properties, but disconnect the relationships between current process and the dependency processes, even with a separate assignment, such as <code>MyProcess.requires = ...</code>.</p>"},{"location":"defining-proc/#process-configurations-and-proc-class-variables","title":"process configurations and <code>Proc</code> class variables","text":"<p>The configurations of a process are specified as class variables of subclasses of <code>Proc</code>.</p> Name Meaning Can be overwritten by <code>Proc.from_proc()</code> <code>name</code> The name of the process. Will use the class name by default. Yes <code>desc</code> The description of the process. Will use the summary from the docstring by default. Yes <code>envs</code> The env variables that are job-independent, useful for common options across jobs. Yes, and old ones will be inherited <code>cache</code> Should we detect whether the jobs are cached? Yes <code>dirsig</code> When checking the signature for caching, the depth we should walk through the content of the directory? This is sometimes time-consuming if the directory and the depth are big. Yes <code>export</code> When True, the results will be exported to <code>&lt;pipeline.outdir&gt;</code> Defaults to None, meaning only end processes will export. You can set it to True/False to enable or disable exporting for processes Yes <code>error_strategy</code> How to deal with the errors: retry, ignore, halt Yes <code>num_retries</code> How many times to retry to jobs once error occurs Yes <code>template</code> Define the template engine to use. No <code>template_opts</code> Options to initialize the template engine. No <code>forks</code> How many jobs to run simultaneously? Yes <code>input</code> The keys and types for the input channel No <code>input_data</code> The input data (will be computed for dependent processes) Yes <code>lang</code> The language for the script to run. No <code>order</code> The execution order for the same dependency-level processes Yes <code>output</code> The output keys for the output channel No <code>plugin_opts</code> Options for process-level plugins Yes <code>requires</code> The dependency processes Yes <code>scheduler</code> The scheduler to run the jobs Yes <code>scheduler_opts</code> The options for the scheduler Yes <code>script</code> The script template for the process No <code>submission_batch</code> How many jobs to be submited simultaneously Yes"},{"location":"error/","title":"Error handling","text":"<p>You can tell <code>pipen</code> how to handle when a job fails to run.</p> <p>You can specify one of the following to <code>error_strategy</code></p> <ul> <li><code>halt</code>: Any failure will just halt the whole pipeline</li> <li><code>ignore</code>: Ignore the error and keep running (assuming the job runs successfully anyway)</li> <li><code>retry</code>: Retry to job running</li> <li>After <code>num_retries</code> times of retrying, if the job is still failing, then halt the pipeline.</li> </ul> <p><code>pipen</code> uses <code>xqute</code> to handle the errors. See also here.</p>"},{"location":"examples/","title":"Examples","text":"<p>You can find the source code of the examples under directory <code>examples/</code> in the github repository.</p> <p>Theses examples including:</p>"},{"location":"examples/#caching","title":"Caching","text":"<p>When run the script the second time, you may see from the logs that jobs are cached:</p> <pre><code>\u276f python examples/caching.py\n[09/13/21 06:10:03] I main                        _____________________________________   __\n[09/13/21 06:10:03] I main                        ___  __ \\___  _/__  __ \\__  ____/__  | / /\n[09/13/21 06:10:03] I main                        __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n[09/13/21 06:10:03] I main                        _  ____/__/ /  _  ____/_  /___  _  /|  /\n[09/13/21 06:10:03] I main                        /_/     /___/  /_/     /_____/  /_/ |_/\n[09/13/21 06:10:03] I main\n[09/13/21 06:10:03] I main                                     version: 0.1.0\n[09/13/21 06:10:03] D main\n[09/13/21 06:10:03] D main    Building process relationships:\n[09/13/21 06:10:03] D main    - Start processes: [&lt;Proc:AProcess&gt;]\n[09/13/21 06:10:03] I main\n[09/13/21 06:10:03] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PIPEN-0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:10:03] I main    \u2551  # procs          = 1                                                        \u2551\n[09/13/21 06:10:03] I main    \u2551  plugins          = ['main', 'verbose-0.0.1']                                \u2551\n[09/13/21 06:10:03] I main    \u2551  profile          = default                                                  \u2551\n[09/13/21 06:10:03] I main    \u2551  outdir           = Pipen-output                                          \u2551\n[09/13/21 06:10:03] I main    \u2551  cache            = True                                                     \u2551\n[09/13/21 06:10:03] I main    \u2551  dirsig           = 1                                                        \u2551\n[09/13/21 06:10:03] I main    \u2551  error_strategy   = ignore                                                   \u2551\n[09/13/21 06:10:03] I main    \u2551  forks            = 1                                                        \u2551\n[09/13/21 06:10:03] I main    \u2551  lang             = bash                                                     \u2551\n[09/13/21 06:10:03] I main    \u2551  loglevel         = debug                                                    \u2551\n[09/13/21 06:10:03] I main    \u2551  num_retries      = 3                                                        \u2551\n[09/13/21 06:10:03] I main    \u2551  plugin_opts      = {}                                                       \u2551\n[09/13/21 06:10:03] I main    \u2551  plugins          = None                                                     \u2551\n[09/13/21 06:10:03] I main    \u2551  scheduler        = local                                                    \u2551\n[09/13/21 06:10:03] I main    \u2551  scheduler_opts   = {}                                                       \u2551\n[09/13/21 06:10:03] I main    \u2551  submission_batch = 8                                                        \u2551\n[09/13/21 06:10:03] I main    \u2551  template         = liquid                                                   \u2551\n[09/13/21 06:10:03] I main    \u2551  template_opts    = {}                                                       \u2551\n[09/13/21 06:10:03] I main    \u2551  workdir          = ./.pipen                                                 \u2551\n[09/13/21 06:10:03] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:10:03] I main\n[09/13/21 06:10:03] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 AProcess \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:10:03] I main    \u2551 A normal process                                                             \u2551\n[09/13/21 06:10:03] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:10:03] I main    AProcess: Workdir: '.pipen/pipen-0/aprocess'\n[09/13/21 06:10:03] I main    AProcess: &lt;&lt;&lt; [START]\n[09/13/21 06:10:03] I main    AProcess: &gt;&gt;&gt; [END]\n[09/13/21 06:10:03] I verbose AProcess: size: 1\n[09/13/21 06:10:03] I verbose AProcess: [0/0] in.infile: /tmp/pipen_example_caching.txt\n[09/13/21 06:10:03] I verbose AProcess: [0/0] out.outfile: /home/pwwang/github/pipen/Pipen-output/AProcess/pipen_example_caching.txt\n[09/13/21 06:10:03] I main    AProcess: Cached jobs: 0\n[09/13/21 06:10:03] I verbose AProcess: Time elapsed: 00:00:00.040s\n[09/13/21 06:10:03] I main\n</code></pre> <p>To \"de-cache\" the jobs:</p> <pre><code>\u276f PIPEN_default_cache=0 python examples/caching.py\n[09/13/21 06:11:55] I main                        _____________________________________   __\n[09/13/21 06:11:55] I main                        ___  __ \\___  _/__  __ \\__  ____/__  | / /\n[09/13/21 06:11:55] I main                        __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n[09/13/21 06:11:55] I main                        _  ____/__/ /  _  ____/_  /___  _  /|  /\n[09/13/21 06:11:55] I main                        /_/     /___/  /_/     /_____/  /_/ |_/\n[09/13/21 06:11:55] I main\n[09/13/21 06:11:55] I main                                     version: 0.1.0\n[09/13/21 06:11:55] D main\n[09/13/21 06:11:55] D main    Building process relationships:\n[09/13/21 06:11:55] D main    - Start processes: [&lt;Proc:AProcess&gt;]\n[09/13/21 06:11:55] I main\n[09/13/21 06:11:55] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PIPEN-0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:11:55] I main    \u2551  # procs          = 1                                                        \u2551\n[09/13/21 06:11:55] I main    \u2551  plugins          = ['main', 'verbose-0.0.1']                                \u2551\n[09/13/21 06:11:55] I main    \u2551  profile          = default                                                  \u2551\n[09/13/21 06:11:55] I main    \u2551  outdir           = Pipen-output                                          \u2551\n[09/13/21 06:11:55] I main    \u2551  cache            = 0                                                        \u2551\n[09/13/21 06:11:55] I main    \u2551  dirsig           = 1                                                        \u2551\n[09/13/21 06:11:55] I main    \u2551  error_strategy   = ignore                                                   \u2551\n[09/13/21 06:11:55] I main    \u2551  forks            = 1                                                        \u2551\n[09/13/21 06:11:55] I main    \u2551  lang             = bash                                                     \u2551\n[09/13/21 06:11:55] I main    \u2551  loglevel         = debug                                                    \u2551\n[09/13/21 06:11:55] I main    \u2551  num_retries      = 3                                                        \u2551\n[09/13/21 06:11:55] I main    \u2551  plugin_opts      = {}                                                       \u2551\n[09/13/21 06:11:55] I main    \u2551  plugins          = None                                                     \u2551\n[09/13/21 06:11:55] I main    \u2551  scheduler        = local                                                    \u2551\n[09/13/21 06:11:55] I main    \u2551  scheduler_opts   = {}                                                       \u2551\n[09/13/21 06:11:55] I main    \u2551  submission_batch = 8                                                        \u2551\n[09/13/21 06:11:55] I main    \u2551  template         = liquid                                                   \u2551\n[09/13/21 06:11:55] I main    \u2551  template_opts    = {}                                                       \u2551\n[09/13/21 06:11:55] I main    \u2551  workdir          = ./.pipen                                                 \u2551\n[09/13/21 06:11:55] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:11:55] I main\n[09/13/21 06:11:55] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 AProcess \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:11:55] I main    \u2551 A normal process                                                             \u2551\n[09/13/21 06:11:55] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:11:55] I main    AProcess: Workdir: '.pipen/pipen-0/aprocess'\n[09/13/21 06:11:55] I main    AProcess: &lt;&lt;&lt; [START]\n[09/13/21 06:11:55] I main    AProcess: &gt;&gt;&gt; [END]\n[09/13/21 06:11:55] I verbose AProcess: size: 1\n[09/13/21 06:11:55] D main    AProcess: [0/0] Not cached (proc.cache is False)\n[09/13/21 06:11:55] D main    AProcess: [0/0] Clearing previous output files.\n[09/13/21 06:11:55] I verbose AProcess: [0/0] in.infile: /tmp/pipen_example_caching.txt\n[09/13/21 06:11:55] I verbose AProcess: [0/0] out.outfile: /home/pwwang/github/pipen/Pipen-output/AProcess/pipen_example_caching.txt\n[09/13/21 06:11:56] I verbose AProcess: Time elapsed: 00:00:01.060s\n[09/13/21 06:11:56] I main\n</code></pre>"},{"location":"examples/#input-data-callback","title":"Input data callback","text":"<pre><code>\u276f python examples/input_data_callback.py\n[09/13/21 06:13:12] I main                        _____________________________________   __\n[09/13/21 06:13:12] I main                        ___  __ \\___  _/__  __ \\__  ____/__  | / /\n[09/13/21 06:13:12] I main                        __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n[09/13/21 06:13:12] I main                        _  ____/__/ /  _  ____/_  /___  _  /|  /\n[09/13/21 06:13:12] I main                        /_/     /___/  /_/     /_____/  /_/ |_/\n[09/13/21 06:13:12] I main\n[09/13/21 06:13:12] I main                                     version: 0.1.0\n[09/13/21 06:13:12] I main\n[09/13/21 06:13:12] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PIPEN-0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:13:12] I main    \u2551  # procs          = 2                                                        \u2551\n[09/13/21 06:13:12] I main    \u2551  plugins          = ['main', 'verbose-0.0.1']                                \u2551\n[09/13/21 06:13:12] I main    \u2551  profile          = default                                                  \u2551\n[09/13/21 06:13:12] I main    \u2551  outdir           = Pipen-output                                             \u2551\n[09/13/21 06:13:12] I main    \u2551  cache            = True                                                     \u2551\n[09/13/21 06:13:12] I main    \u2551  dirsig           = 1                                                        \u2551\n[09/13/21 06:13:12] I main    \u2551  error_strategy   = ignore                                                   \u2551\n[09/13/21 06:13:13] I main    \u2551  forks            = 3                                                        \u2551\n[09/13/21 06:13:13] I main    \u2551  lang             = bash                                                     \u2551\n[09/13/21 06:13:13] I main    \u2551  loglevel         = info                                                     \u2551\n[09/13/21 06:13:13] I main    \u2551  num_retries      = 3                                                        \u2551\n[09/13/21 06:13:13] I main    \u2551  plugin_opts      = {}                                                       \u2551\n[09/13/21 06:13:13] I main    \u2551  plugins          = None                                                     \u2551\n[09/13/21 06:13:13] I main    \u2551  scheduler        = local                                                    \u2551\n[09/13/21 06:13:13] I main    \u2551  scheduler_opts   = {}                                                       \u2551\n[09/13/21 06:13:13] I main    \u2551  submission_batch = 8                                                        \u2551\n[09/13/21 06:13:13] I main    \u2551  template         = liquid                                                   \u2551\n[09/13/21 06:13:13] I main    \u2551  template_opts    = {}                                                       \u2551\n[09/13/21 06:13:13] I main    \u2551  workdir          = ./.pipen                                                 \u2551\n[09/13/21 06:13:13] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:13:13] I main\n[09/13/21 06:13:13] I main    \u256d\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 P1 \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n[09/13/21 06:13:13] I main    \u2502 Sort input file                                                              \u2502\n[09/13/21 06:13:13] I main    \u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n[09/13/21 06:13:13] I main    P1: Workdir: '.pipen/pipen-0/p1'\n[09/13/21 06:13:13] I main    P1: &lt;&lt;&lt; [START]\n[09/13/21 06:13:13] I main    P1: &gt;&gt;&gt; ['P2']\n[09/13/21 06:13:13] I verbose P1: size: 10\n[09/13/21 06:13:13] I verbose P1: [0/9] in.infile: /tmp/pipen_example_input_data_callback/0.txt\n[09/13/21 06:13:13] I verbose P1: [0/9] out.outfile: /home/pwwang/github/pipen/.pipen/pipen-0/p1/0/output/intermediate.txt\n[09/13/21 06:13:15] I verbose P1: Time elapsed: 00:00:02.224s\n[09/13/21 06:13:15] I main\n[09/13/21 06:13:15] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 P2 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:13:15] I main    \u2551 Paste line number                                                            \u2551\n[09/13/21 06:13:15] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:13:15] I main    P2: Workdir: '.pipen/pipen-0/p2'\n[09/13/21 06:13:15] I main    P2: &lt;&lt;&lt; ['P1']\n[09/13/21 06:13:15] I main    P2: &gt;&gt;&gt; [END]\n[09/13/21 06:13:15] I verbose P2: size: 10\n[09/13/21 06:13:15] I verbose P2: [0/9] in.infile: /home/pwwang/github/pipen/.pipen/pipen-0/p1/0/output/intermediate.txt\n[09/13/21 06:13:15] I verbose P2: [0/9] in.nlines: 2\n[09/13/21 06:13:15] I verbose P2: [0/9] out.outfile: /home/pwwang/github/pipen/Pipen-output/P2/0/result.txt\n[09/13/21 06:13:17] I verbose P2: Time elapsed: 00:00:02.192s\n[09/13/21 06:13:17] I main\n</code></pre> <pre><code>\u276f cat /home/pwwang/github/pipen/Pipen-output/P2/0/result.txt\n1       0_0\n2       0_1\n</code></pre>"},{"location":"examples/#mako-templating","title":"mako templating","text":"<pre><code>\u276f python examples/mako-templating.py\n[09/13/21 06:14:57] I main                        _____________________________________   __\n[09/13/21 06:14:57] I main                        ___  __ \\___  _/__  __ \\__  ____/__  | / /\n[09/13/21 06:14:57] I main                        __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n[09/13/21 06:14:57] I main                        _  ____/__/ /  _  ____/_  /___  _  /|  /\n[09/13/21 06:14:57] I main                        /_/     /___/  /_/     /_____/  /_/ |_/\n[09/13/21 06:14:57] I main\n[09/13/21 06:14:57] I main                                     version: 0.1.0\n[09/13/21 06:14:57] I main\n[09/13/21 06:14:57] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PIPEN-0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:14:57] I main    \u2551  # procs          = 1                                                        \u2551\n[09/13/21 06:14:57] I main    \u2551  plugins          = ['main', 'verbose-0.0.1']                                \u2551\n[09/13/21 06:14:57] I main    \u2551  profile          = default                                                  \u2551\n[09/13/21 06:14:57] I main    \u2551  outdir           = Pipen-output                                             \u2551\n[09/13/21 06:14:57] I main    \u2551  cache            = True                                                     \u2551\n[09/13/21 06:14:57] I main    \u2551  dirsig           = 1                                                        \u2551\n[09/13/21 06:14:57] I main    \u2551  error_strategy   = ignore                                                   \u2551\n[09/13/21 06:14:57] I main    \u2551  forks            = 1                                                        \u2551\n[09/13/21 06:14:57] I main    \u2551  lang             = bash                                                     \u2551\n[09/13/21 06:14:57] I main    \u2551  loglevel         = info                                                     \u2551\n[09/13/21 06:14:57] I main    \u2551  num_retries      = 3                                                        \u2551\n[09/13/21 06:14:57] I main    \u2551  plugin_opts      = {}                                                       \u2551\n[09/13/21 06:14:57] I main    \u2551  plugins          = None                                                     \u2551\n[09/13/21 06:14:57] I main    \u2551  scheduler        = local                                                    \u2551\n[09/13/21 06:14:57] I main    \u2551  scheduler_opts   = {}                                                       \u2551\n[09/13/21 06:14:57] I main    \u2551  submission_batch = 8                                                        \u2551\n[09/13/21 06:14:57] I main    \u2551  template         = liquid                                                   \u2551\n[09/13/21 06:14:57] I main    \u2551  template_opts    = {}                                                       \u2551\n[09/13/21 06:14:57] I main    \u2551  workdir          = ./.pipen                                                 \u2551\n[09/13/21 06:14:57] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:14:57] I main\n[09/13/21 06:14:57] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 MakoProcess \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:14:57] I main    \u2551 A process using mako templating                                              \u2551\n[09/13/21 06:14:57] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:14:57] I main    MakoProcess: Workdir: '.pipen/pipen-0/makoprocess'\n[09/13/21 06:14:57] I main    MakoProcess: &lt;&lt;&lt; [START]\n[09/13/21 06:14:57] I main    MakoProcess: &gt;&gt;&gt; [END]\n[09/13/21 06:14:57] I verbose MakoProcess: size    : 1\n[09/13/21 06:14:57] I verbose MakoProcess: template: mako\n[09/13/21 06:14:57] I verbose MakoProcess: [0/0] in.a: 1\n[09/13/21 06:14:57] I verbose MakoProcess: [0/0] out.outfile: /home/pwwang/github/pipen/Pipen-output/MakoProcess/1.txt\n[09/13/21 06:14:58] I verbose MakoProcess: Time elapsed: 00:00:01.019s\n[09/13/21 06:14:58] I main\n</code></pre>"},{"location":"examples/#multile-jobs","title":"multile jobs","text":"<pre><code>&gt; python examples/multijobs.py\n[09/13/21 06:16:09] I main                        _____________________________________   __\n[09/13/21 06:16:09] I main                        ___  __ \\___  _/__  __ \\__  ____/__  | / /\n[09/13/21 06:16:09] I main                        __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n[09/13/21 06:16:09] I main                        _  ____/__/ /  _  ____/_  /___  _  /|  /\n[09/13/21 06:16:09] I main                        /_/     /___/  /_/     /_____/  /_/ |_/\n[09/13/21 06:16:09] I main\n[09/13/21 06:16:09] I main                                     version: 0.1.0\n[09/13/21 06:16:09] I main\n[09/13/21 06:16:09] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PIPEN-0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:16:09] I main    \u2551  # procs          = 1                                                        \u2551\n[09/13/21 06:16:09] I main    \u2551  plugins          = ['main', 'verbose-0.0.1']                                \u2551\n[09/13/21 06:16:09] I main    \u2551  profile          = default                                                  \u2551\n[09/13/21 06:16:09] I main    \u2551  outdir           = Pipen-output                                             \u2551\n[09/13/21 06:16:09] I main    \u2551  cache            = True                                                     \u2551\n[09/13/21 06:16:09] I main    \u2551  dirsig           = 1                                                        \u2551\n[09/13/21 06:16:09] I main    \u2551  error_strategy   = ignore                                                   \u2551\n[09/13/21 06:16:09] I main    \u2551  forks            = 1                                                        \u2551\n[09/13/21 06:16:09] I main    \u2551  lang             = bash                                                     \u2551\n[09/13/21 06:16:09] I main    \u2551  loglevel         = info                                                     \u2551\n[09/13/21 06:16:09] I main    \u2551  num_retries      = 3                                                        \u2551\n[09/13/21 06:16:09] I main    \u2551  plugin_opts      = {}                                                       \u2551\n[09/13/21 06:16:09] I main    \u2551  plugins          = None                                                     \u2551\n[09/13/21 06:16:09] I main    \u2551  scheduler        = local                                                    \u2551\n[09/13/21 06:16:09] I main    \u2551  scheduler_opts   = {}                                                       \u2551\n[09/13/21 06:16:09] I main    \u2551  submission_batch = 8                                                        \u2551\n[09/13/21 06:16:09] I main    \u2551  template         = liquid                                                   \u2551\n[09/13/21 06:16:09] I main    \u2551  template_opts    = {}                                                       \u2551\n[09/13/21 06:16:09] I main    \u2551  workdir          = ./.pipen                                                 \u2551\n[09/13/21 06:16:09] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:16:09] I main\n[09/13/21 06:16:09] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 MultiJobProc \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:16:09] I main    \u2551 A process with multiple jobs                                                 \u2551\n[09/13/21 06:16:09] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:16:09] I main    MultiJobProc: Workdir: '.pipen/pipen-0/multijobproc'\n[09/13/21 06:16:09] I main    MultiJobProc: &lt;&lt;&lt; [START]\n[09/13/21 06:16:09] I main    MultiJobProc: &gt;&gt;&gt; [END]\n[09/13/21 06:16:10] I verbose MultiJobProc: forks: 3\n[09/13/21 06:16:10] I verbose MultiJobProc: cache: False\n[09/13/21 06:16:10] I verbose MultiJobProc: size : 10\n[09/13/21 06:16:10] I verbose MultiJobProc: [0/9] in.i: 0\n[09/13/21 06:16:10] I verbose MultiJobProc: [0/9] out.outfile: /home/pwwang/github/pipen/Pipen-output/MultiJobProc/0/0.txt\n[09/13/21 06:16:16] I verbose MultiJobProc: Time elapsed: 00:00:06.139s\n[09/13/21 06:16:16] I main\n</code></pre>"},{"location":"examples/#plugin","title":"plugin","text":"<pre><code>\u276f python examples/plugin-example.py\n[09/13/21 06:18:18] I notify  Calling on_setup\n[09/13/21 06:18:18] I main                        _____________________________________   __\n[09/13/21 06:18:18] I main                        ___  __ \\___  _/__  __ \\__  ____/__  | / /\n[09/13/21 06:18:18] I main                        __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n[09/13/21 06:18:18] I main                        _  ____/__/ /  _  ____/_  /___  _  /|  /\n[09/13/21 06:18:18] I main                        /_/     /___/  /_/     /_____/  /_/ |_/\n[09/13/21 06:18:18] I main\n[09/13/21 06:18:18] I main                                     version: 0.1.0\n[09/13/21 06:18:18] I main\n[09/13/21 06:18:18] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PIPEN-0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:18:18] I main    \u2551  # procs          = 1                                                        \u2551\n[09/13/21 06:18:18] I main    \u2551  plugins          = ['main', 'notifyplugin-0.0.0']                           \u2551\n[09/13/21 06:18:18] I main    \u2551  profile          = default                                                  \u2551\n[09/13/21 06:18:18] I main    \u2551  outdir           = Pipen-output                                             \u2551\n[09/13/21 06:18:18] I main    \u2551  cache            = True                                                     \u2551\n[09/13/21 06:18:18] I main    \u2551  dirsig           = 1                                                        \u2551\n[09/13/21 06:18:18] I main    \u2551  error_strategy   = ignore                                                   \u2551\n[09/13/21 06:18:18] I main    \u2551  forks            = 1                                                        \u2551\n[09/13/21 06:18:18] I main    \u2551  lang             = bash                                                     \u2551\n[09/13/21 06:18:18] I main    \u2551  loglevel         = info                                                     \u2551\n[09/13/21 06:18:18] I main    \u2551  num_retries      = 3                                                        \u2551\n[09/13/21 06:18:18] I main    \u2551  plugin_opts      = {}                                                       \u2551\n[09/13/21 06:18:18] I main    \u2551  plugins          = [&lt;class '__main__.NotifyPlugin'&gt;]                        \u2551\n[09/13/21 06:18:18] I main    \u2551  scheduler        = local                                                    \u2551\n[09/13/21 06:18:18] I main    \u2551  scheduler_opts   = {}                                                       \u2551\n[09/13/21 06:18:18] I main    \u2551  submission_batch = 8                                                        \u2551\n[09/13/21 06:18:18] I main    \u2551  template         = liquid                                                   \u2551\n[09/13/21 06:18:18] I main    \u2551  template_opts    = {}                                                       \u2551\n[09/13/21 06:18:18] I main    \u2551  workdir          = ./.pipen                                                 \u2551\n[09/13/21 06:18:18] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:18:18] I notify  Calling on_start\n[09/13/21 06:18:18] I main\n[09/13/21 06:18:18] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 AProcess \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:18:18] I main    \u2551 Undescribed                                                                  \u2551\n[09/13/21 06:18:18] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:18:18] I main    AProcess: Workdir: '.pipen/pipen-0/aprocess'\n[09/13/21 06:18:18] I main    AProcess: &lt;&lt;&lt; [START]\n[09/13/21 06:18:18] I main    AProcess: &gt;&gt;&gt; [END]\n[09/13/21 06:18:18] W main    AProcess: No script specified.\n[09/13/21 06:18:18] I notify  Calling on_proc_start\n[09/13/21 06:18:18] I main    AProcess: Cached jobs: 0\n[09/13/21 06:18:18] I notify  Calling on_proc_done, succeeded = cached\n[09/13/21 06:18:18] I main\n\n                PIPEN-0: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 2.91 procs/s]\n[09/13/21 06:18:18] I notify  Calling on_complete, succeeded = True\n</code></pre>"},{"location":"examples/#using-python-interpreter","title":"Using python interpreter","text":"<pre><code>\u276f python examples/python-script.py\n[09/13/21 06:19:45] I main                        _____________________________________   __\n[09/13/21 06:19:45] I main                        ___  __ \\___  _/__  __ \\__  ____/__  | / /\n[09/13/21 06:19:45] I main                        __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n[09/13/21 06:19:45] I main                        _  ____/__/ /  _  ____/_  /___  _  /|  /\n[09/13/21 06:19:45] I main                        /_/     /___/  /_/     /_____/  /_/ |_/\n[09/13/21 06:19:45] I main\n[09/13/21 06:19:45] I main                                     version: 0.1.0\n[09/13/21 06:19:45] I main\n[09/13/21 06:19:45] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PIPEN-0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:19:45] I main    \u2551  # procs          = 1                                                        \u2551\n[09/13/21 06:19:45] I main    \u2551  plugins          = ['main', 'verbose-0.0.1']                                \u2551\n[09/13/21 06:19:45] I main    \u2551  profile          = default                                                  \u2551\n[09/13/21 06:19:45] I main    \u2551  outdir           = Pipen-output                                             \u2551\n[09/13/21 06:19:46] I main    \u2551  cache            = True                                                     \u2551\n[09/13/21 06:19:46] I main    \u2551  dirsig           = 1                                                        \u2551\n[09/13/21 06:19:46] I main    \u2551  error_strategy   = ignore                                                   \u2551\n[09/13/21 06:19:46] I main    \u2551  forks            = 1                                                        \u2551\n[09/13/21 06:19:46] I main    \u2551  lang             = bash                                                     \u2551\n[09/13/21 06:19:46] I main    \u2551  loglevel         = info                                                     \u2551\n[09/13/21 06:19:46] I main    \u2551  num_retries      = 3                                                        \u2551\n[09/13/21 06:19:46] I main    \u2551  plugin_opts      = {}                                                       \u2551\n[09/13/21 06:19:46] I main    \u2551  plugins          = None                                                     \u2551\n[09/13/21 06:19:46] I main    \u2551  scheduler        = local                                                    \u2551\n[09/13/21 06:19:46] I main    \u2551  scheduler_opts   = {}                                                       \u2551\n[09/13/21 06:19:46] I main    \u2551  submission_batch = 8                                                        \u2551\n[09/13/21 06:19:46] I main    \u2551  template         = liquid                                                   \u2551\n[09/13/21 06:19:46] I main    \u2551  template_opts    = {}                                                       \u2551\n[09/13/21 06:19:46] I main    \u2551  workdir          = ./.pipen                                                 \u2551\n[09/13/21 06:19:46] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:19:46] I main\n[09/13/21 06:19:46] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PythonScriptProc \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:19:46] I main    \u2551 A process using python interpreter for script                                \u2551\n[09/13/21 06:19:46] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:19:46] I main    PythonScriptProc: Workdir: '.pipen/pipen-0/pythonscriptproc'\n[09/13/21 06:19:46] I main    PythonScriptProc: &lt;&lt;&lt; [START]\n[09/13/21 06:19:46] I main    PythonScriptProc: &gt;&gt;&gt; [END]\n[09/13/21 06:19:46] I verbose PythonScriptProc: lang: python\n[09/13/21 06:19:46] I verbose PythonScriptProc: size: 1\n[09/13/21 06:19:46] I verbose PythonScriptProc: [0/0] in.a: 1\n[09/13/21 06:19:46] I verbose PythonScriptProc: [0/0] out.outfile:\n                      /home/pwwang/github/pipen/Pipen-output/PythonScriptProc/1.txt\n[09/13/21 06:19:48] I verbose PythonScriptProc: Time elapsed: 00:00:02.031s\n[09/13/21 06:19:48] I main\n</code></pre>"},{"location":"examples/#error-handling-retry","title":"Error-handling: retry","text":"<pre><code>\u276f python examples/retry.py\n[09/13/21 06:20:38] I main                        _____________________________________   __\n[09/13/21 06:20:38] I main                        ___  __ \\___  _/__  __ \\__  ____/__  | / /\n[09/13/21 06:20:38] I main                        __  /_/ /__  / __  /_/ /_  __/  __   |/ /\n[09/13/21 06:20:38] I main                        _  ____/__/ /  _  ____/_  /___  _  /|  /\n[09/13/21 06:20:38] I main                        /_/     /___/  /_/     /_____/  /_/ |_/\n[09/13/21 06:20:38] I main\n[09/13/21 06:20:38] I main                                     version: 0.1.0\n[09/13/21 06:20:38] D main\n[09/13/21 06:20:38] D main    Building process relationships:\n[09/13/21 06:20:38] D main    - Start processes: [&lt;Proc:RetryProc&gt;]\n[09/13/21 06:20:38] I main\n[09/13/21 06:20:38] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 PIPEN-0 \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:20:38] I main    \u2551  # procs          = 1                                                        \u2551\n[09/13/21 06:20:38] I main    \u2551  plugins          = ['main', 'verbose-0.0.1']                                \u2551\n[09/13/21 06:20:38] I main    \u2551  profile          = default                                                  \u2551\n[09/13/21 06:20:38] I main    \u2551  outdir           = Pipen-output                                             \u2551\n[09/13/21 06:20:38] I main    \u2551  cache            = True                                                     \u2551\n[09/13/21 06:20:38] I main    \u2551  dirsig           = 1                                                        \u2551\n[09/13/21 06:20:38] I main    \u2551  error_strategy   = ignore                                                   \u2551\n[09/13/21 06:20:38] I main    \u2551  forks            = 1                                                        \u2551\n[09/13/21 06:20:38] I main    \u2551  lang             = bash                                                     \u2551\n[09/13/21 06:20:38] I main    \u2551  loglevel         = debug                                                    \u2551\n[09/13/21 06:20:38] I main    \u2551  num_retries      = 3                                                        \u2551\n[09/13/21 06:20:38] I main    \u2551  plugin_opts      = {}                                                       \u2551\n[09/13/21 06:20:38] I main    \u2551  plugins          = None                                                     \u2551\n[09/13/21 06:20:38] I main    \u2551  scheduler        = local                                                    \u2551\n[09/13/21 06:20:38] I main    \u2551  scheduler_opts   = {}                                                       \u2551\n[09/13/21 06:20:38] I main    \u2551  submission_batch = 8                                                        \u2551\n[09/13/21 06:20:38] I main    \u2551  template         = liquid                                                   \u2551\n[09/13/21 06:20:38] I main    \u2551  template_opts    = {}                                                       \u2551\n[09/13/21 06:20:38] I main    \u2551  workdir          = ./.pipen                                                 \u2551\n[09/13/21 06:20:38] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:20:38] I main\n[09/13/21 06:20:38] I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 RetryProc \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n[09/13/21 06:20:38] I main    \u2551 Retry the jobs when fail                                                     \u2551\n[09/13/21 06:20:38] I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n[09/13/21 06:20:38] I main    RetryProc: Workdir: '.pipen/pipen-0/retryproc'\n[09/13/21 06:20:38] I main    RetryProc: &lt;&lt;&lt; [START]\n[09/13/21 06:20:38] I main    RetryProc: &gt;&gt;&gt; [END]\n[09/13/21 06:20:38] I verbose RetryProc: size: 1\n[09/13/21 06:20:38] D main    RetryProc: [0/0] Not cached (job.rc != 0)\n[09/13/21 06:20:38] D main    RetryProc: [0/0] Clearing previous output files.\n[09/13/21 06:20:38] I verbose RetryProc: [0/0] in.starttime: 1631539238\n[09/13/21 06:20:39] D main    RetryProc: [0/0] Retrying #1\n[09/13/21 06:20:40] D main    RetryProc: [0/0] Retrying #2\n[09/13/21 06:20:41] D main    RetryProc: [0/0] Retrying #3\n[09/13/21 06:20:42] D main    RetryProc: [0/0] Retrying #4\n[09/13/21 06:20:43] I verbose RetryProc: Time elapsed: 00:00:05.203s\n[09/13/21 06:20:43] I main\n</code></pre>"},{"location":"input-output/","title":"Input and output","text":""},{"location":"input-output/#specify-input-of-a-process","title":"Specify input of a process","text":"<p>The input of a process is specified with <code>input</code>, the keys of the input data, and <code>input_data</code>, the real input data</p> <p>Tip</p> <p>Why separate the keys and data?</p> <p>Because the keys and data are not always combined, for example, we need the keys to infer the <code>output</code> and <code>script</code> (using them in the template), but the data may be deferred to obtain from the output of dependency processes.</p> <p>The complete form of an input key (<code>input</code>) is <code>&lt;key&gt;:&lt;type&gt;</code>. The <code>&lt;type&gt;</code> could be <code>var</code>, <code>file</code>, <code>dir</code>, <code>files</code> and <code>dirs</code>. A type of <code>var</code> can be omitted. So <code>ph1, ph2</code> is the same as <code>ph1:var, ph2:var</code></p> <p>If a process is requiring other processes, the specified <code>input_data</code> will be ignored, and will use the output data of their required processes:</p> <pre><code>class P1(Proc):\n    input = \"v1\"\n    output = \"o1:{{in.v1}}\" # pass by v1 as output variable\n    input_data = [\"a\"]\n\nclass P2(Proc):\n    input = \"v2\"\n    output = \"o2:{{in.v2}}\"\n    input_data = [\"b\"]\n\nclass P3(Proc):\n    requires = [P1, P2]\n    input = \"i1, i2\"\n    output = \"o3:{{in.i1}}_{{in.i2}}\" # will be \"a_b\"\n    # input_data = []  # ignored with a warning\n\nPipen().run(P1, P2)\n</code></pre> <p>Tip</p> <p>The direct <code>input_data</code> is ignore, but you can use a callback to modify the input channel. For example:</p> <pre><code>class P4(Proc):\n    requires = [P1, P2]\n    input = \"i1, i2\"\n    input_data = lambda ch: ch.applymap(str.upper)\n    output = \"o3:{{in.i1}}_{{in.i2}}\" # will be \"A_B\"\n</code></pre> <p>Note</p> <p>When the input data does have enough columns, <code>None</code> will be used with warnings. And when the input data has more columns than the input keys, the extra columns are dropped and ignored, also with warnings</p>"},{"location":"input-output/#specify-output-of-a-process","title":"Specify output of a process","text":"<p>Different from input, instead of channels, you have to tell <code>pipen</code> how to compute the output channel. The output can be a <code>list</code> or <code>str</code>. If it's <code>str</code>, a comma (<code>,</code>) is used to separate different keys:</p> <p>To use templating in <code>output</code>, see <code>templating</code>.</p> <pre><code>class P1(Proc):\n    input = \"invar, infile\"\n    input_data = [(1, \"/a/b/c.txt\")]\n    output = (\n        \"outvar:{{in.invar}}2, \"\n        \"outfile:file:{{in.infile.split('/')[-1]}}2, \"\n        \"outdir:dir:{{in.infile.split('/')[-1].split('.')[0]}}-dir\"\n    )\n\n# The type 'var' is omitted in the first element.\n# The output channel will be:\n#\n#    outvar    outfile                 outdir\n#    &lt;object&gt;  &lt;object&gt;                &lt;object&gt;\n# 0  \"12\"      \"&lt;job.outdir&gt;/c.text2\"  \"&lt;job.outdir&gt;/c-dir\"\n</code></pre>"},{"location":"input-output/#types-of-input-and-output","title":"Types of input and output","text":""},{"location":"input-output/#input","title":"Input","text":"Type Meaning <code>var</code> Use the values directly <code>file</code> Treat the data as a file path <code>dir</code> Treat the data as a directory path <code>files</code> Treat the data as a list of file paths <code>dirs</code> Treat the data as a list of directory paths <p>For <code>file</code>/<code>files</code>, when checking whether a job is cached, their last modified time will be checked.</p> <p>For <code>dir</code>/<code>dirs</code>, if <code>dirsig &gt; 0</code>, then the files inside the directories will be checked. Otherwise, the directories themselves are checked for last modified time.</p>"},{"location":"input-output/#output","title":"Output","text":"Type Meaning Memo <code>var</code> Use the values directly <code>dir</code> Use the data as a directory path The directory will be created directly <code>file</code> Use the data as a file path"},{"location":"plugin/","title":"Plugins","text":"<p><code>pipen</code> uses <code>simplug</code> for plugin support. There are very enriched hooks available for you to write your own plugins to extend <code>pipen</code>.</p>"},{"location":"plugin/#runtime-plugins","title":"Runtime plugins","text":""},{"location":"plugin/#plugin-hooks","title":"Plugin hooks","text":"<p>To implement a function in your plugin, just simply:</p> <pre><code>from pipen import plugin\n\n@plugin.impl\n[async ]def hook(...):\n    ...\n</code></pre> <p>Note that you have to use keyword-arguments and they have to match the hook signature.</p> <p>See <code>simplug</code> for more details.</p>"},{"location":"plugin/#pipeline-level-hooks","title":"Pipeline-level hooks","text":"<ul> <li> <p><code>on_setup(pipen)</code> (sync):</p> <p>Setup for the plugin, mainly used for initalization and set the default values for the plugin configuration items.</p> <p>This is only called once even when you have multiple pipelines (<code>Pipen</code> objects) in a python session.</p> </li> <li> <p><code>on_init(pipen)</code> (async)</p> <p>Called when pipeline is initialized. Note that here only default configurations are loaded (from defaults.CONFIG and config files). The configurations from <code>Pipen</code> constructor and the processes are not loaded yet. It's useful for plugins to change the default configurations.</p> </li> <li> <p><code>on_start(pipen)</code> (async)</p> <p>Right before the pipeline starts to run. The process relationships are inferred here. You can access the start processes by <code>pipen.starts</code> and all processes by <code>pipen.procs</code> in the sequence of the execution order.</p> </li> <li> <p><code>on_complete(pipen, succeeded)</code> (async)</p> <p>After all processes finish. <code>succeeded</code> indicates whether all processes/jobs finish successfully.</p> </li> </ul>"},{"location":"plugin/#process-level-hooks","title":"Process-level hooks","text":"<ul> <li> <p><code>on_proc_create(proc)</code> (sync)</p> <p>Called before proc get instantiated. Enables plugins to modify the default attributes of processes</p> </li> <li> <p><code>on_proc_input_computed(proc)</code> (sync)</p> <p>Called after process input data is computed.</p> </li> <li> <p><code>on_proc_script_computed(proc)</code> (sync)</p> <p>Called after process script is computed.</p> <p>The script is computed as a string that is about to compiled into a template. You can modify the script here.</p> </li> <li> <p><code>on_proc_init(proc)</code> (async)</p> <p>When process object is initialized. Allows plugins to modify the process attributes after initialization, but before the jobs are initialized.</p> </li> <li> <p><code>on_proc_start(proc)</code> (async)</p> <p>When process object initialization completes, including the <code>xqute</code> and job initialization. The <code>output_data</code> is also accessible here. The process is ready to run.</p> </li> <li> <p><code>on_proc_shutdown(proc, sig)</code> (sync)</p> <p>When the process is shut down (i.e. by <code>&lt;ctrl-c&gt;</code>). You can access the signal that shuts the process down by <code>sig</code>. Only first plugin (based on the priority) that implements this hook will get called.</p> </li> <li> <p><code>on_proc_done(proc, succeeded)</code> (async)</p> <p>When a process is done.</p> </li> </ul>"},{"location":"plugin/#job-level-hooks","title":"Job-level hooks","text":"<ul> <li> <p><code>on_job_init(job)</code> (async)</p> <p>When a job is initialized</p> </li> <li> <p><code>on_job_queued(job)</code> (async)</p> <p>When a job is queued in xqute. Note it might not be queued yet in the scheduler system.</p> </li> <li> <p><code>on_job_submitting(job)</code> (async)</p> <p>When a job is submitting.</p> <p>The first plugin (based on priority) have this hook return <code>False</code> will cancel the submission</p> </li> <li> <p><code>on_job_submitted(job)</code> (async)</p> <p>When a job is submitted in the scheduler system.</p> </li> <li> <p><code>on_job_started(job)</code> (async)</p> <p>When a job starts to run in then scheduler system.</p> </li> <li> <p><code>on_job_polling(job)</code> (async)</p> <p>When status of a job is being polled.</p> </li> <li> <p><code>on_job_killing(job)</code> (async)</p> <p>When a job is being killed.</p> <p>The first plugin (based on priority) have this hook return <code>False</code> will cancel the killing</p> </li> <li> <p><code>on_job_killed(job)</code> (async)</p> <p>When a job is killed</p> </li> <li> <p><code>on_job_succeeded(job)</code> (async)</p> <p>When a job completes successfully</p> </li> <li> <p><code>on_job_cached(job)</code> (async)</p> <p>When a job is cached</p> </li> <li> <p><code>on_job_failed(job)</code> (async)</p> <p>When a job is done but failed (i.e. return_code == 1).</p> </li> <li> <p><code>on_jobcmd_init(job) -&gt; str</code> (sync)</p> <p>When the job command wrapper script is initialized before the prescript is run</p> <p>This should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance.</p> <p>For multiple plugins, the code will be inserted in the order of the plugin priority.</p> <p>The code will replace the <code>#![jobcmd_init]</code> placeholder in the wrapped job script. See also https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95</p> </li> <li> <p><code>on_jobcmd_prep(job) -&gt; str</code> (sync)</p> <p>When the job command right about to be run</p> <p>This should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance.</p> <p>The bash variable <code>$cmd</code> is accessible in the context. It is also possible to modify the <code>cmd</code> variable. Just remember to assign the modified value to <code>cmd</code>.</p> <p>For multiple plugins, the code will be inserted in the order of the plugin priority. Keep in mind that the <code>$cmd</code> may be modified by other plugins.</p> <p>The code will replace the <code>#![jobcmd_prep]</code> placeholder in the wrapped job script. See also https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95</p> </li> <li> <p><code>on_jobcmd_end(job) -&gt; str</code> (sync):</p> <p>When the job command finishes and after the postscript is run</p> <p>This should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance.</p> <p>The bash variable <code>$rc</code> is accessible in the context, which is the return code of the job command.</p> <p>For multiple plugins, the code will be inserted in the order of the plugin priority.</p> <p>The code will replace the <code>#![jobcmd_end]</code> placeholder in the wrapped job script. See also https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95</p> </li> </ul>"},{"location":"plugin/#loading-plugins","title":"Loading plugins","text":"<p>You can specify the plugins to be loaded by specifying the names or the plugin itself in <code>plugins</code> configuration. With names, the plugins will be loaded from entry points.</p> <p>You can also disable some plugins if they are set in the lower-priority configurations. For example, you want to disable <code>pipen_verbose</code> (enabled in a configuration file) for a pipeline:</p> <pre><code>Pipen(..., plugins=[\"-pipen_verbose\"])\n</code></pre> <p>Note</p> <p>You can use <code>+</code> as prefix to enable a disabled plugin, or <code>-</code> as prefix to disable an enabled plugin. If no prefix is used, only the specified plugins will be enabled and all other plugins will be disabled. You should either use <code>+</code> or <code>-</code> for all plugins or none of them. If a plugin is not given as a string, it will be treated as <code>+plugin</code>.</p>"},{"location":"plugin/#writing-a-plugin","title":"Writing a plugin","text":"<p>You can write your own plugin by implementing some of the above hooks. You can import the plugin directly and add it to `Pipen(..., plugins=[...]). For example:</p> <pre><code>from pipen import plugin, Pipen\n\nclass PipenPlugin:\n\n    @plugin.impl\n    [async ]def hook(...):\n        ...\n\nPipen(..., plugins=[PipenPlugin])\n\n\nYou can also use the entry point to register your plugin using the group name `pipen`\n\nFor `setup.py`, you will need:\n```python\nsetup(\n    # ...\n    entry_points={\"pipen\": [\"pipen_verbose = pipen_verbose\"]},\n    # ...\n)\n</code></pre> <p>For <code>pyproject.toml</code>:</p> <pre><code>[tool.poetry.plugins.pipen]\npipen_verbose = \"pipen_verbose\"\n</code></pre> <p>Then the plugin <code>pipen_verbose</code> can be loaded by <code>plugins=[\"+pipen_verbose\"]</code> or disabled by <code>plugins=[\"-pipen_verbose\"]</code></p>"},{"location":"plugin/#logging-to-the-console-from-a-plugin","title":"Logging to the console from a plugin","text":"<p>Of course you can do arbitrary logging from a plugin. However, to keep the consistency with main logger of <code>pipen</code>, The best practice is:</p> <pre><code>from pipen.utils import get_logger\n\nlogger = get_logger(\"verbose\", \"info\")\n\n# do some logging inside the hooks\n</code></pre> <p>The above code will produce some logging on the console like this:</p> <pre><code>11-04 12:00:19 I main    \u256d\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550 Process \u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256e\n11-04 12:00:19 I main    \u2551 Undescribed.                                                  \u2551\n11-04 12:00:19 I main    \u2570\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u256f\n11-04 12:00:19 I main    Process: Workdir: '.pipen/process'\n11-04 12:00:19 I verbose Process: size: 10\n11-04 12:00:19 I verbose Process: [0/9] in.a: 0\n11-04 12:00:19 I verbose Process: [0/9] out.b: pipeline-0-output/Process/0/a.txt\n</code></pre>"},{"location":"plugin/#cli-plugins","title":"CLI plugins","text":"<p>See CLI for more details.</p>"},{"location":"plugin/#plugin-gallery","title":"Plugin gallery","text":"<ul> <li><code>pipen-verbose</code>: Add verbosal information in logs for pipen.</li> <li><code>pipen-report</code>: Generate report for pipen</li> <li><code>pipen-filters</code>: Add a set of useful filters for pipen templates.</li> <li><code>pipen-diagram</code>: Draw pipeline diagrams for pipen</li> <li><code>pipen-args</code>: Command line argument parser for pipen</li> <li><code>pipen-dry</code>: Dry runner for pipen pipelines</li> <li><code>pipen-annotate</code>: Use docstring to annotate pipen processes</li> <li><code>pipen-board</code>: Visualize configuration and running of pipen pipelines on the web</li> <li><code>pipen-lock</code>: Process lock for pipen to prevent multiple runs at the same time.</li> <li><code>pipen-log2file</code>: Save running logs to file for pipen</li> <li><code>pipen-poplog</code>: Populate logs from jobs to running log of the pipeline</li> <li><code>pipen-runinfo</code>: Save running information to file for pipen</li> <li><code>pipen-gcs</code>: A plugin for pipen to handle files in Google Cloud Storage.</li> </ul>"},{"location":"proc-group/","title":"Process group","text":"<p>A process group is a collection of processes that are related to each other. It is a convenient way to manage a set of processes.</p> <p>With <code>pipen</code>, not only a process can be reused, but also a group of processes can be reused. We just need to define the relationship between the processes in the group, and then we can reuse the group in other pipelines, or even run it directly as a pipeline.</p>"},{"location":"proc-group/#define-a-process-group","title":"Define a process group","text":"<p>To define a process group, we need to define a class that inherits from <code>pipen.procgroup.ProcGroup</code>. The class name will be the name of the group, unless we specify a <code>name</code> attribute.</p> <pre><code>from pipen.procgroup import ProcGroup\n\nclass MyGroup(ProcGroup):\n    ...\n</code></pre> <p>Note that the subclasses of <code>ProcGroup</code> are singleton classes. If you need to define multiple groups, you can define a base class and then inherit from it.</p>"},{"location":"proc-group/#add-processes-to-a-group","title":"Add processes to a group","text":"<p>There are two ways to add processes to a group, using <code>pg.add_proc</code> or <code>ProcGroup.add_proc</code>, where <code>pg</code> is a process group instance. The first method is used after the group is instantiated and it decorates a process class directly. The second method is used before the group is instantiated and it decorates a property of <code>ProcGroup</code> that returns a process.</p> <ol> <li> <p>Using the <code>pg.add_proc()</code> decorator.</p> <pre><code>from pipen import Proc, ProcGroup\n\nclass MyGroup(ProcGroup):\n    ...\n\npg = MyGroup()\n\n@pg.add_proc\nclass MyProc(Proc):\n    ...\n</code></pre> </li> <li> <p>Using the <code>ProcGroup.add_proc()</code> decorator to decorate a property of the group class.</p> <pre><code>from pipen import Proc, ProcGroup\n\nclass MyGroup(ProcGroup):\n\n    @ProcGroup.add_proc\n    def my_proc(self):\n        class MyProc(Proc):\n            ...\n        return MyProc\n</code></pre> </li> </ol> <p>This method adds a process at runtime, so it is useful when we want to add processes to a group dynamically.</p>"},{"location":"proc-group/#access-processes-in-a-group","title":"Access processes in a group","text":"<p>We can access the processes in a group using the <code>pg.&lt;proc&gt;</code> attribute, where <code>pg</code> is a process group instance. Note that when we use the <code>ProcGroup.add_proc</code> method to add processes, the process name is the name of the property.</p> <p>However, you can always use <code>pg.procs.&lt;proc_name&gt;</code> to access the process, where the <code>&lt;proc_name&gt;</code> is the real name of the process.</p> <pre><code>from pipen import Proc, ProcGroup\n\nclass MyGroup(ProcGroup):\n\n    @ProcGroup.add_proc\n    def my_proc(self):\n        class MyProc(Proc):\n            ...\n        return MyProc\n\npg = MyGroup()\nassert pg.my_proc.name == 'MyProc'\nassert pg.procs.MyProc.name == 'MyProc'\n</code></pre> <p>We can use <code>pg.starts</code> to get the start processes of the group, which are the processes that have no required processes. So when you add processes to a group, remember to specify <code>.requires</code> for each process, unless they are start processes.</p>"},{"location":"proc-group/#run-a-process-group-as-a-pipeline","title":"Run a process group as a pipeline","text":"<p>To run a process group as a pipeline, we can convert it to a pipeline using the <code>as_pipen()</code> method. The method takes the same arguments as the <code>Pipen</code> constructor.</p> <pre><code>from pipen import Proc, ProcGroup\n\nclass MyGroup(ProcGroup):\n    ...\n\npg = MyGroup()\n\n@pg.add_proc\nclass MyProc(Proc):\n    ...\n\npg.as_pipen().set_data(...).run()\n</code></pre>"},{"location":"proc-group/#integrate-a-process-group-into-a-pipeline","title":"Integrate a process group into a pipeline","text":"<pre><code>from pipen import Proc, ProcGroup\n\nclass MyGroup(ProcGroup):\n\n    @ProcGroup.add_proc\n    def my_proc(self):\n        class MyProc(Proc):\n            ...\n        return MyProc\n\n    @ProcGroup.add_proc\n    def my_proc2(self):\n        class MyProc2(Proc):\n            requires = self.my_proc\n            ...\n\n        return MyProc2\n\npg = MyGroup()\n\nclass PrepareData(Proc):\n    ...\n\nclass PostGroup(Proc):\n    requires = pg.my_proc2\n\npg.my_proc.requires = PrepareData\n\npipen = Pipen().set_starts(PrepareData).set_data(...).run()\n</code></pre>"},{"location":"running/","title":"Defining and running a pipeline","text":""},{"location":"running/#creating-a-pipen-object","title":"Creating a <code>Pipen</code> object","text":"<p>The arguments for the constrctor are:</p> <ul> <li><code>name</code>: The name of the pipeline</li> <li><code>desc</code>: The description of the pipeline</li> <li><code>outdir</code>: The output directory of the pipeline. If not provided, defaults to <code>&lt;pipeline-name&gt;_results</code>.</li> <li><code>**kwargs</code>: Other configurations</li> </ul>"},{"location":"running/#specification-of-the-start-processes","title":"Specification of the start processes","text":"<p>Once the requirements of the processes are specified, we are able to build the entire process dependency network. To start runing a pipeline, we just need to specify the start processes to start:</p> <pre><code>class P1(Proc):\n    ...\n\nclass P2(Proc):\n    ...\n\nclass P3(Proc):\n    requires = [P1, P2]\n    ...\n\nPipen().set_starts(P1, P2)\n</code></pre> <p>You can specify the start processes individually, like we did above, or send a list of processes:</p> <pre><code>Pipen().set_starts([P1, P2])\n</code></pre>"},{"location":"running/#setting-input-data-for-start-processes","title":"Setting input data for start processes","text":"<p>Other than set the input data when defining a process, you can also specify the input data for start processes:</p> <pre><code>Pipen().set_starts(P1, P2).set_data(&lt;data for P1&gt;, &lt;data for P2&gt;)\n</code></pre> <p>This is useful when you want to reuse the processes.</p> <p>The order of data in <code>.set_data()</code> has to be the same as the order of processes to be set in <code>.set_starts()</code>. When the <code>input_data</code> of a start process has already been set, an error will be raised. To use that <code>input_data</code>, use <code>None</code> in <code>.set_data()</code>. For example:</p> <pre><code>class P1(Proc):\n    ...\n\nclass P2(Proc):\n    input_data = [1]\n\nPipen().set_starts(P1, P2).set_data(&lt;data for P1&gt;, None)\n</code></pre>"},{"location":"running/#running-with-a-different-profile","title":"Running with a different profile","text":"<p><code>Pipen.run()</code> accepts an argument <code>profile</code>, which allows you to use different profile from configuration files to run the pipeline:</p> <pre><code>Pipen().run(\"sge\")\n</code></pre> <p>See configurations for more details.</p>"},{"location":"running/#shortcut-for-running-a-pipeline","title":"Shortcut for running a pipeline","text":"<pre><code>import pipen\n\nclass P1(pipen.Proc):\n    ...\n\nclass P2(pipen.Proc):\n    ...\n\nclass P3(pipen.Proc):\n    requires = [P1, P2]\n    ...\n\npipen.run(\"MyPipeline\", starts=[P1, P2], data=[&lt;data for P1&gt;, &lt;data for P2&gt;])\n</code></pre> <pre><code>&gt;&gt;&gt; help(pipen.run)\n\nrun(\n    name: 'str',\n    starts: 'Type[Proc] | List[Type[Proc]]',\n    data: 'Iterable' = None,\n    *,\n    desc: 'str' = None,\n    outdir: 'str | PathLike' = None,\n    profile: 'str' = 'default',\n    **kwargs,\n) -&gt; 'bool'\n    Shortcut to run a pipeline\n\n    Args:\n        name: The name of the pipeline\n        starts: The start processes\n        data: The input data for the start processes\n        desc: The description of the pipeline\n        outdir: The output directory of the results\n        profile: The profile to use\n        **kwargs: Other options pass to Pipen to create the pipeline\n\n    Returns:\n        True if the pipeline ends successfully else False\n</code></pre>"},{"location":"scheduler/","title":"Scheduler","text":"<p><code>pipen</code> can send jobs to different scheduler system to run. To specify the scheduler, use <code>scheduler</code> and <code>scheduler_opts</code> configurations.</p>"},{"location":"scheduler/#default-supported-schedulers","title":"Default supported schedulers","text":"<p><code>pipen</code> uses <code>xqute</code> for scheduler backend support. The following schedulers are supported by <code>pipen</code>:</p>"},{"location":"scheduler/#local","title":"<code>local</code>","text":"<p>This is the default scheduler used by <code>pipen</code>. The jobs will be run on the local machine.</p> <p>No scheduler-specific options are available.</p>"},{"location":"scheduler/#sge","title":"<code>sge</code>","text":"<p>Send the jobs to run on <code>sge</code> scheduler.</p> <p>The <code>scheduler_opts</code> will be the ones supported by <code>qsub</code>.</p>"},{"location":"scheduler/#slurm","title":"<code>slurm</code>","text":"<p>Send the jobs to run on <code>slurm</code> scheduler.</p> <p>The <code>scheduler_opts</code> will be the ones supported by <code>sbatch</code>.</p>"},{"location":"scheduler/#ssh","title":"<code>ssh</code>","text":"<p>Send the jobs to run on a remote machine via <code>ssh</code>.</p> <p>The <code>scheduler_opts</code> will be the ones supported by <code>ssh</code>.</p> <p>See also xqute.</p>"},{"location":"scheduler/#container","title":"<code>container</code>","text":"<p>Send the jobs to run in a container (Docker/Podman/Apptainer). The <code>scheduler_opts</code> will be used to construct the container command.</p> <p>They include: - <code>image</code>: The container image to use. - <code>entrypoint</code>: The entrypoint of the container to run the wrapped job script. If not specified, the default entrypoint <code>/bin/sh</code> will be used. - <code>bin</code>: The container command to use. If not specified, it will use <code>docker</code>. - <code>volumes</code>: A list of volumes to mount to the container. The default volumes are:   - <code>workdir</code>: The working directory of the pipeline, mounted to <code>/mnt/disks/pipen-pipeline/workdir</code>.   - <code>outdir</code>: The output directory of the pipeline, mounted to <code>/mnt/disks/pipen-pipeline/outdir</code>. - <code>envs</code>: A dictionary of environment variables to set in the container. - <code>remove</code>: Whether to remove the container after the job is done. Default is <code>True</code>. Only supported by Docker and Podman. - <code>user</code>: The user to run the container as. Default is the current user. Only supported by Docker and Podman. - <code>bin_args</code>: Additional arguments to pass to the container command. For example, <code>{\"bin_args\": [\"--privileged\"]}</code> will run the container in privileged mode. Only supported by Docker and Podman.</p>"},{"location":"scheduler/#gbatch","title":"<code>gbatch</code>","text":"<p>Send the jobs to run using Google Cloud Batch.</p> <p>The <code>scheduler_opts</code> will be used to construct the job configuration. This scheduler requires that the pipeline's <code>outdir</code> is a Google Cloud Storage path (e.g., <code>gs://bucket/path</code>).</p> <p>The scheduler options include: - <code>project</code>: Google Cloud project ID - <code>location</code>: Google Cloud region or zone - <code>mount</code>: GCS path to mount (e.g. <code>gs://my-bucket:/mnt/my-bucket</code>). You can pass a list of mounts. - <code>service_account</code>: GCP service account email (e.g. <code>test-account@example.com</code>) - <code>network</code>: GCP network (e.g. <code>default-network</code>) - <code>subnetwork</code>: GCP subnetwork (e.g. <code>regions/us-central1/subnetworks/default</code>) - <code>no_external_ip_address</code>: Whether to disable external IP address - <code>machine_type</code>: GCP machine type (e.g. <code>e2-standard-4</code>) - <code>provisioning_model</code>: GCP provisioning model (e.g. <code>SPOT</code>) - <code>image_uri</code>: Container image URI (e.g. <code>ubuntu-2004-lts</code>) - <code>entrypoint</code>: Container entrypoint (e.g. <code>/bin/bash</code>) - <code>commands</code>: The command list to run in the container.     There are three ways to specify the commands:     1. If no entrypoint is specified, the final command will be     [commands, wrapped_script], where the entrypoint is the wrapper script     interpreter that is determined by <code>JOBCMD_WRAPPER_LANG</code> (e.g. /bin/bash),     commands is the list you provided, and wrapped_script is the path to the     wrapped job script.     2. You can specify something like \"-c\", then the final command     will be [\"-c\", \"wrapper_script_interpreter, wrapper_script\"]     3. You can use the placeholders <code>{lang}</code> and <code>{script}</code> in the commands     list, where <code>{lang}</code> will be replaced with the interpreter (e.g. /bin/bash)     and <code>{script}</code> will be replaced with the path to the wrapped job script.     For example, you can specify [\"{lang} {script}\"] and the final command     will be [\"wrapper_interpreter, wrapper_script\"]</p> <p>Additional keyword arguments can be used for job configuration (e.g. <code>taskGroups</code>). See more details at Google Cloud Batch documentation.</p> <p>By default, the pipeline's workdir is mounted to <code>/mnt/disks/pipen-pipeline/workdir</code> and the outdir is mounted to <code>/mnt/disks/pipen-pipeline/outdir</code> on the VM.</p>"},{"location":"scheduler/#writing-your-own-scheduler-plugin","title":"Writing your own scheduler plugin","text":"<p>To write a scheduler plugin, you need to subclass both <code>xqute.schedulers.scheduler.Scheduler</code> and <code>pipen.scheduler.SchedulerPostInit</code>.</p> <p>For examples of a scheduler plugin, see local_scheduler, sge_scheduler, slurm_scheduler, ssh_scheduler, and [gbatch_scheduler][6], and also <code>pipen.scheduler</code>.</p> <p>A scheduler class can be passed to <code>scheduler</code> configuration directly to be used as a scheduler. But you can also register it with entry points:</p> <p>For <code>setup.py</code>, you will need: <pre><code>setup(\n\t# ...\n\tentry_points={\"pipen_sched\": [\"mysched = pipen_mysched\"]},\n\t# ...\n)\n</code></pre></p> <p>For <code>pyproject.toml</code>: <pre><code>[tool.poetry.plugins.pipen_sched]\nmysched = \"pipen_mysched\"\n</code></pre></p> <p>Then you can switch the scheduler to <code>mysched</code> by <code>scheduler=\"mysched\"</code></p>"},{"location":"script/","title":"Script","text":"<p>For templating in <code>script</code>, see <code>templating</code></p>"},{"location":"script/#choosing-your-language","title":"Choosing your language","text":"<p>You can specify the path of interpreter to <code>lang</code>. If the interpreter is in <code>$PATH</code>, you can directly give the basename of the interpreter (i.e. <code>python</code> instead of <code>/path/to/python</code>).</p> <p>For example, if you have your own perl installed at <code>/home/user/bin/perl</code>, then you need to tell <code>pipen</code> where it is: <code>lang = \"/home/user/bin/perl\"</code>. If <code>/home/user/bin</code> is in your <code>$PATH</code>, you can simply do: <code>lang = \"perl\"</code></p> <p>You can also use shebang to specify the interperter: <pre><code>#!/home/usr/bin/perl\n# You perl code goes here\n</code></pre></p> <p>If you have shebang in your script, the <code>lang</code> specified in the configuration files and <code>Pipen</code> constructor will be ignored (but the one specified in process definition is not).</p>"},{"location":"script/#use-script-from-a-file","title":"Use script from a file","text":"<p>You can also put the script into a file, and use it with a <code>file://</code> prefix: <code>script = \"file:///a/b/c.pl\"</code></p> <p>Note</p> <p>You may also use a script file with a relative path, which is relative to where process is defined. For example: a process with <code>script = \"file://./scripts/script.py\"</code> is defined in <code>/a/b/pipeline.py</code>, then the script file refers to <code>/a/b/scripts/script.py</code></p> <p>Hint</p> <p>Indents are important in python, when you write your scripts, you don't have to worry about the indents in your first empty lines. For example, you don't have to do this:</p> <pre><code>class P1(Proc):\n    lang = \"python\"\n    script = \"\"\"\nimport os\nimport re\ndef somefunc ():\n    pass\n\"\"\"\n</code></pre> <p>You can do this:</p> <pre><code>class P1(Proc):\n    lang = \"python\"\n    script = \"\"\"\n    import os\n    import re\n    def somefunc ():\n        pass\n    \"\"\"\n</code></pre> <p>Only the first non-empty line is used to detect the indent for the whole script.</p>"},{"location":"script/#debugging-your-script","title":"Debugging your script","text":"<p>If you need to debug your script, you just need to find the real running script, which is at: <code>&lt;pipeline-workdir&gt;/&lt;proc-name&gt;/&lt;job.index&gt;/job.script</code>. The template is rendered already in the file. You can debug it using the tool according to the language you used for the script.</p>"},{"location":"script/#caching-your-results","title":"Caching your results","text":"<p>Job results get automatically cached previous run is successful and input/output data are not changed, see caching.</p> <p>However, there are cases when you want to cache some results even when the job fails. For example, there is a very time-consuming chunk of code in your script that you don't want to run that part each time if it finishes once. In that case, you can save the intermediate results in a directory under <code>&lt;job.outdir&gt;</code>, where the directory is not specified in <code>output</code>. This keeps that directory untouched each time when the running data get purged if previous run fails.</p>"},{"location":"templating/","title":"Templating","text":"<p>Templates are used in <code>output</code> and <code>script</code> in process definition.</p>"},{"location":"templating/#template-engines","title":"Template engines","text":"<p>By default, <code>pipen</code> uses <code>liquid</code> template engine to render the <code>output</code> and <code>script</code>. You can also switch the template engine to <code>jinja2</code> by specifying:</p> <pre><code>template = \"jinja2\"\n</code></pre> <p>in one of the configuration files, or in the <code>Pipen</code> constructor:</p> <pre><code>pipeline = Pipen(..., template=\"jinja2\", ...)\n</code></pre> <p>or in the process definition</p> <pre><code>class MyProcess(Proc):\n    ...\n    template = \"jinja2\" # overwrite the global template engine\n</code></pre> <p>Besides specifying the name of a template engine, you can also specify a subclass <code>pipen.template.Template</code> as a template engine. This enables us to use our own template engine. You just have to wrap then use a subclass of <code>pipen.template.Template</code>. For example, if you want to use <code>mako</code>:</p> <pre><code>from mako.template import Template as MakoTemplate\nfrom pipen.template import Template\n\nclass TemplateMako(Template):\n\n    def __init__(self, source, **kwargs):\n        super().__init__(source)\n        self.engine = MakoTemplate(source, **kwargs)\n\n    def _render(self, data):\n        return self.engine.render(**data)\n\n# Use it for a process\nfrom pipen import Proc\n\nclass MyProcess(Proc):\n    template = TemplateMako\n    ... # other configurations\n</code></pre> <p>The <code>template_opts</code> configuration is used to pass to <code>TemplateMako</code> constructor. The values is passed by to the <code>MakoTemplate</code> constructor.</p> <p>You can also register the template as a plugin of pipen:</p> <p>In <code>pyproject.toml</code>:</p> <pre><code>[tool.poetry.plugins.pipen_tpl]\nmako = \"pipen_mako:pipen_mako\"\n</code></pre> <p>Or in <code>setup.py</code>:</p> <pre><code>setup(\n    ...,\n    entry_points={\"pipen_tpl\": [\"pipen_mako:pipen_mako\"]},\n)\n</code></pre> <p>Then in <code>pipen_mako.py</code> of your package:</p> <pre><code>def pipen_mako():\n    # TemplateMako is defined as the above\n    return TemplateMako\n</code></pre>"},{"location":"templating/#rendering-data","title":"Rendering data","text":"<p>There are some data shared to render both <code>output</code> and <code>script</code>. However, there are some different. One of the obvious reasons is that, the <code>script</code> template can use the <code>output</code> data to render.</p>"},{"location":"templating/#output","title":"<code>output</code>","text":"<p>The data to render the <code>output</code>:</p> Name Description <code>job.index</code> The index of the job, 0-based <code>job.metadir</code><sup>1</sup> The directory where job metadata is saved, typically <code>&lt;pipeline-workdir&gt;/&lt;pipeline-name&gt;/&lt;proc-name&gt;/&lt;job.index&gt;/</code> <code>job.outdir</code><sup>1</sup> *The output directory of the job: <code>&lt;pipeline-workdir&gt;/&lt;pipeline-name&gt;/&lt;proc-name&gt;/&lt;job.index&gt;/output</code> <code>job.stdout_file</code><sup>1</sup> The file that saves the stdout of the job <code>job.stderr_file</code><sup>1</sup> The file that saves the stderr of the job <code>in</code> The input data of the job. You can use <code>in.&lt;input-key&gt;</code><sup>1</sup> to access the data for each input key <code>proc</code> The process object, used to access their properties, such as <code>proc.workdir</code> <code>envs</code> The <code>envs</code> of the process <p><code>*</code>: If the process is an end process, it will be a symbolic link to <code>&lt;pipeline-outdir&gt;/&lt;process-name&gt;/&lt;job.index&gt;</code>. When the process has only a single job, the <code>&lt;job.index&gt;</code> is also omitted.</p>"},{"location":"templating/#script","title":"<code>script</code>","text":"<p>All the data used to render <code>output</code> can also be used to render <code>script</code>. Addtionally, the rendered <code>output</code> can also be used to render <code>script</code>. For example:</p> <pre><code>class MyProcess(Proc):\n    input = \"in\"\n    output = \"outfile:file:{{in.in}}.txt\"\n    script = \"echo {{in.in}} &gt; {{out.outfile}}\"\n    ... # other configurations\n</code></pre> <p>With input data [\"a\"], the script is rendered as <code>echo a &gt; &lt;job.outdir&gt;/a.txt</code></p> <p><sup>1</sup> The paths are <code>MountedPath</code> objects, which represent paths of jobs and it is useful when a job is running in a remote system (a VM, a container, etc.), where we need to mount the paths into the remote system. It has an attribute <code>spec</code> to get the specified path. When there is no mountings, it is the same as the path itself.</p>"},{"location":"api/pipen.channel/","title":"pipen.channel","text":"module &lt;/&gt; <p>Provide some function for creating and modifying channels (dataframes)</p> Classes <ul> <li><code>Channel</code> \u2014 A DataFrame wrapper with creators&lt;/&gt;</li> </ul> Functions <ul> <li><code>collapse_files</code><code>(</code><code>data</code>, <code>col</code><code>)</code> (DataFrame) \u2014 Collapse a Channel according to the files in ,other cols will use the values in row 0. &lt;/&gt;</li> <li><code>expand_dir</code><code>(</code><code>data</code>, <code>col</code>, <code>pattern</code>, <code>ftype</code>, <code>sortby</code>, <code>reverse</code><code>)</code> (DataFrame) \u2014 Expand a Channel according to the files in ,other cols will keep the same. &lt;/&gt;</li> </ul> class &lt;/&gt; Bases pandas.core.frame.DataFrame pandas.core.generic.NDFrame pandas.core.base.PandasObject pandas.core.accessor.DirNamesMixin pandas.core.indexing.IndexingMixin pandas.core.arraylike.OpsMixin <p>A DataFrame wrapper with creators</p> Parameters <ul> <li><code>data</code> (optional) \u2014 Dict can contain Series, arrays, constants, dataclass or list-like objects. Ifdata is a dict, column order follows insertion-order. If a dict contains Series which have an index defined, it is aligned by its index. This alignment also occurs if data is a Series or a DataFrame itself. Alignment is done on Series/DataFrame inputs. If data is a list of dicts, column order follows insertion-order. </li> <li><code>index</code> (Axes | None, optional) \u2014 Index to use for resulting frame. Will default to RangeIndex ifno indexing information part of input data and no index provided. </li> <li><code>columns</code> (Axes | None, optional) \u2014 Column labels to use for resulting frame when data does not have them,defaulting to RangeIndex(0, 1, 2, ..., n). If data contains column labels, will perform column selection instead. </li> <li><code>dtype</code> (Dtype | None, optional) \u2014 Data type to force. Only a single dtype is allowed. If None, infer.</li> <li><code>copy</code> (bool | none, optional) \u2014 Copy data from inputs.For dict data, the default of None behaves like <code>copy=True</code>.  For DataFrame or 2d ndarray input, the default of None behaves like <code>copy=False</code>. If data is a dict containing one or more Series (possibly of different dtypes), <code>copy=False</code> will ensure that these inputs are not copied. .. versionchanged:: 1.3.0 </li> </ul> Attributes <ul> <li><code>T</code> \u2014 The transpose of the DataFrame.&lt;/&gt;</li> <li><code>at</code> (_AtIndexer) \u2014 Access a single value for a row/column label pair.Similar to <code>loc</code>, in that both provide label-based lookups. Use <code>at</code> if you only need to get or set a single value in a DataFrame or Series. &lt;/&gt;</li> <li><code>attrs</code> (dict[Hashable, Any]) \u2014 Dictionary of global attributes of this dataset... warning:: attrs is experimental and may change without warning. &lt;/&gt;</li> <li><code>axes</code> (list) \u2014 Return a list representing the axes of the DataFrame.It has the row axis labels and column axis labels as the only members. They are returned in that order. &lt;/&gt;</li> <li><code>dtypes</code> \u2014 Return the dtypes in the DataFrame.This returns a Series with the data type of each column. The result's index is the original DataFrame's columns. Columns with mixed types are stored with the <code>object</code> dtype. See :ref:<code>the User Guide &lt;basics.dtypes&gt;</code> for more. &lt;/&gt;</li> <li><code>empty</code> \u2014 Indicator whether Series/DataFrame is empty.True if Series/DataFrame is entirely empty (no items), meaning any of the axes are of length 0. &lt;/&gt;</li> <li><code>flags</code> (Flags) \u2014 Get the properties associated with this pandas object.The available flags are <ul> <li>:attr:<code>Flags.allows_duplicate_labels</code></li> </ul> &lt;/&gt;</li> <li><code>iat</code> (_iAtIndexer) \u2014 Access a single value for a row/column pair by integer position.Similar to <code>iloc</code>, in that both provide integer-based lookups. Use <code>iat</code> if you only need to get or set a single value in a DataFrame or Series. &lt;/&gt;</li> <li><code>iloc</code> (_iLocIndexer) \u2014 Purely integer-location based indexing for selection by position... deprecated:: 2.2.0 Returning a tuple from a callable is deprecated. <code>.iloc[]</code> is primarily integer position based (from <code>0</code> to <code>length-1</code> of the axis), but may also be used with a boolean array. Allowed inputs are: <ul> <li>An integer, e.g. <code>5</code>.</li> <li>A list or array of integers, e.g. <code>[4, 3, 0]</code>.</li> <li>A slice object with ints, e.g. <code>1:7</code>.</li> <li>A boolean array.</li> <li>A <code>callable</code> function with one argument (the calling Series or   DataFrame) and that returns valid output for indexing (one of the above).   This is useful in method chains, when you don't have a reference to the   calling object, but would like to base your selection on   some value.</li> <li>A tuple of row and column indexes. The tuple elements consist of one of the   above inputs, e.g. <code>(0, 1)</code>.</li> </ul> <code>.iloc</code> will raise <code>IndexError</code> if a requested indexer is out-of-bounds, except slice indexers which allow out-of-bounds indexing (this conforms with python/numpy slice semantics). See more at :ref:<code>Selection by Position &lt;indexing.integer&gt;</code>. &lt;/&gt;</li> <li><code>loc</code> (_LocIndexer) \u2014 Access a group of rows and columns by label(s) or a boolean array.<code>.loc[]</code> is primarily label based, but may also be used with a boolean array. Allowed inputs are: <ul> <li>A single label, e.g. <code>5</code> or <code>'a'</code>, (note that <code>5</code> is   interpreted as a label of the index, and never as an   integer position along the index).</li> <li>A list or array of labels, e.g. <code>['a', 'b', 'c']</code>.</li> <li>A slice object with labels, e.g. <code>'a':'f'</code>.</li> </ul> .. warning:: Note that contrary to usual python slices, both the       start and the stop are included <ul> <li>A boolean array of the same length as the axis being sliced,   e.g. <code>[True, False, True]</code>.</li> <li>An alignable boolean Series. The index of the key will be aligned before   masking.</li> <li>An alignable Index. The Index of the returned selection will be the input.</li> <li>A <code>callable</code> function with one argument (the calling Series or   DataFrame) and that returns valid output for indexing (one of the above)</li> </ul> See more at :ref:<code>Selection by Label &lt;indexing.label&gt;</code>. &lt;/&gt;</li> <li><code>ndim</code> (int) \u2014 Return an int representing the number of axes / array dimensions.Return 1 if Series. Otherwise return 2 if DataFrame. &lt;/&gt;</li> <li><code>shape</code> (tuple) \u2014 Return a tuple representing the dimensionality of the DataFrame.&lt;/&gt;</li> <li><code>size</code> (int) \u2014 Return an int representing the number of elements in this object.Return the number of rows if Series. Otherwise return the number of rows times number of columns if DataFrame. &lt;/&gt;</li> <li><code>style</code> (Styler) \u2014 Returns a Styler object.Contains methods for building a styled HTML representation of the DataFrame. &lt;/&gt;</li> <li><code>values</code> \u2014 Return a Numpy representation of the DataFrame... warning:: We recommend using :meth:<code>DataFrame.to_numpy</code> instead. Only the values in the DataFrame will be returned, the axes labels will be removed. &lt;/&gt;</li> </ul> Methods <ul> <li><code>__add__</code><code>(</code><code>other</code><code>)</code> (DataFrame) \u2014 Get Addition of DataFrame and other, column-wise.&lt;/&gt;</li> <li><code>__arrow_c_stream__</code><code>(</code><code>requested_schema</code><code>)</code> (PyCapsule) \u2014 Export the pandas DataFrame as an Arrow C stream PyCapsule.&lt;/&gt;</li> <li><code>__contains__</code><code>(</code><code>key</code><code>)</code> (bool) \u2014 True if the key is in the info axis&lt;/&gt;</li> <li><code>__dataframe__</code><code>(</code><code>nan_as_null</code>, <code>allow_copy</code><code>)</code> (DataFrame interchange object) \u2014 Return the dataframe interchange object implementing the interchange protocol.&lt;/&gt;</li> <li><code>__dataframe_consortium_standard__</code><code>(</code><code>api_version</code><code>)</code> (Any) \u2014 Provide entry point to the Consortium DataFrame Standard API.&lt;/&gt;</li> <li><code>__delitem__</code><code>(</code><code>key</code><code>)</code> \u2014 Delete item&lt;/&gt;</li> <li><code>__dir__</code><code>(</code><code>)</code> (list) \u2014 Provide method name lookup and completion.&lt;/&gt;</li> <li><code>__finalize__</code><code>(</code><code>other</code>, <code>method</code>, <code>**kwargs</code><code>)</code> \u2014 Propagate metadata from other to self.&lt;/&gt;</li> <li><code>__getattr__</code><code>(</code><code>name</code><code>)</code> \u2014 After regular attribute access, try looking up the nameThis allows simpler access to columns for interactive use. &lt;/&gt;</li> <li><code>__iter__</code><code>(</code><code>)</code> (iterator) \u2014 Iterate over info axis.&lt;/&gt;</li> <li><code>__len__</code><code>(</code><code>)</code> (int) \u2014 Returns length of info axis, but here we use the index.&lt;/&gt;</li> <li><code>__matmul__</code><code>(</code><code>other</code><code>)</code> (pandas.core.frame.dataframe | pandas.core.series.series) \u2014 Matrix multiplication using binary <code>@</code> operator.&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 Return a string representation for a particular DataFrame.&lt;/&gt;</li> <li><code>__rmatmul__</code><code>(</code><code>other</code><code>)</code> (DataFrame) \u2014 Matrix multiplication using binary <code>@</code> operator.&lt;/&gt;</li> <li><code>__setattr__</code><code>(</code><code>name</code>, <code>value</code><code>)</code> \u2014 After regular attribute access, try setting the nameThis allows simpler access to columns for interactive use. &lt;/&gt;</li> <li><code>__sizeof__</code><code>(</code><code>)</code> (int) \u2014 Generates the total memory usage for an object that returnseither a value or Series of values &lt;/&gt;</li> <li><code>abs</code><code>(</code><code>)</code> (abs) \u2014 Return a Series/DataFrame with absolute numeric value of each element.&lt;/&gt;</li> <li><code>add</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Addition of dataframe and other, element-wise (binary operator <code>add</code>).&lt;/&gt;</li> <li><code>add_prefix</code><code>(</code><code>prefix</code>, <code>axis</code><code>)</code> (Series or DataFrame) \u2014 Prefix labels with string <code>prefix</code>.&lt;/&gt;</li> <li><code>add_suffix</code><code>(</code><code>suffix</code>, <code>axis</code><code>)</code> (Series or DataFrame) \u2014 Suffix labels with string <code>suffix</code>.&lt;/&gt;</li> <li><code>aggregate</code><code>(</code><code>func</code>, <code>axis</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (scalar, Series or DataFrame) \u2014 Aggregate using one or more operations over the specified axis.&lt;/&gt;</li> <li><code>align</code><code>(</code><code>other</code>, <code>join</code>, <code>axis</code>, <code>level</code>, <code>copy</code>, <code>fill_value</code>, <code>method</code>, <code>limit</code>, <code>fill_axis</code>, <code>broadcast_axis</code><code>)</code> (tuple of (Series/DataFrame, type of other)) \u2014 Align two objects on their axes with the specified join method.&lt;/&gt;</li> <li><code>all</code><code>(</code><code>axis</code>, <code>bool_only</code>, <code>skipna</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame) \u2014 Return whether all elements are True, potentially over an axis.&lt;/&gt;</li> <li><code>any</code><code>(</code><code>axis</code>, <code>bool_only</code>, <code>skipna</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame) \u2014 Return whether any element is True, potentially over an axis.&lt;/&gt;</li> <li><code>apply</code><code>(</code><code>func</code>, <code>axis</code>, <code>raw</code>, <code>result_type</code>, <code>args</code>, <code>by_row</code>, <code>engine</code>, <code>engine_kwargs</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame) \u2014 Apply a function along an axis of the DataFrame.&lt;/&gt;</li> <li><code>applymap</code><code>(</code><code>func</code>, <code>na_action</code>, <code>**kwargs</code><code>)</code> (DataFrame) \u2014 Apply a function to a Dataframe elementwise.&lt;/&gt;</li> <li><code>asfreq</code><code>(</code><code>freq</code>, <code>method</code>, <code>how</code>, <code>normalize</code>, <code>fill_value</code><code>)</code> (Series/DataFrame) \u2014 Convert time series to specified frequency.&lt;/&gt;</li> <li><code>asof</code><code>(</code><code>where</code>, <code>subset</code><code>)</code> (scalar, Series, or DataFrame) \u2014 Return the last row(s) without any NaNs before <code>where</code>.&lt;/&gt;</li> <li><code>assign</code><code>(</code><code>**kwargs</code><code>)</code> (DataFrame) \u2014 Assign new columns to a DataFrame.&lt;/&gt;</li> <li><code>astype</code><code>(</code><code>dtype</code>, <code>copy</code>, <code>errors</code><code>)</code> (same type as caller) \u2014 Cast a pandas object to a specified dtype <code>dtype</code>.&lt;/&gt;</li> <li><code>at_time</code><code>(</code><code>time</code>, <code>asof</code>, <code>axis</code><code>)</code> (Series or DataFrame) \u2014 Select values at particular time of day (e.g., 9:30AM).&lt;/&gt;</li> <li><code>backfill</code><code>(</code><code>axis</code>, <code>inplace</code>, <code>limit</code>, <code>downcast</code><code>)</code> (Series/DataFrame or None) \u2014 Fill NA/NaN values by using the next valid observation to fill the gap.&lt;/&gt;</li> <li><code>between_time</code><code>(</code><code>start_time</code>, <code>end_time</code>, <code>inclusive</code>, <code>axis</code><code>)</code> (Series or DataFrame) \u2014 Select values between particular times of the day (e.g., 9:00-9:30 AM).&lt;/&gt;</li> <li><code>bfill</code><code>(</code><code>axis</code>, <code>inplace</code>, <code>limit</code>, <code>limit_area</code>, <code>downcast</code><code>)</code> (Series/DataFrame or None) \u2014 Fill NA/NaN values by using the next valid observation to fill the gap.&lt;/&gt;</li> <li><code>bool</code><code>(</code><code>)</code> (bool) \u2014 Return the bool of a single element Series or DataFrame.&lt;/&gt;</li> <li><code>clip</code><code>(</code><code>lower</code>, <code>upper</code>, <code>axis</code>, <code>inplace</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame or None) \u2014 Trim values at input threshold(s).&lt;/&gt;</li> <li><code>combine</code><code>(</code><code>other</code>, <code>func</code>, <code>fill_value</code>, <code>overwrite</code><code>)</code> (DataFrame) \u2014 Perform column-wise combine with another DataFrame.&lt;/&gt;</li> <li><code>combine_first</code><code>(</code><code>other</code><code>)</code> (DataFrame) \u2014 Update null elements with value in the same location in <code>other</code>.&lt;/&gt;</li> <li><code>compare</code><code>(</code><code>other</code>, <code>align_axis</code>, <code>keep_shape</code>, <code>keep_equal</code>, <code>result_names</code><code>)</code> (DataFrame) \u2014 Compare to another DataFrame and show the differences.&lt;/&gt;</li> <li><code>convert_dtypes</code><code>(</code><code>infer_objects</code>, <code>convert_string</code>, <code>convert_integer</code>, <code>convert_boolean</code>, <code>convert_floating</code>, <code>dtype_backend</code><code>)</code> (Series or DataFrame) \u2014 Convert columns to the best possible dtypes using dtypes supporting <code>pd.NA</code>.&lt;/&gt;</li> <li><code>copy</code><code>(</code><code>deep</code><code>)</code> (Series or DataFrame) \u2014 Make a copy of this object's indices and data.&lt;/&gt;</li> <li><code>corr</code><code>(</code><code>method</code>, <code>min_periods</code>, <code>numeric_only</code><code>)</code> (DataFrame) \u2014 Compute pairwise correlation of columns, excluding NA/null values.&lt;/&gt;</li> <li><code>corrwith</code><code>(</code><code>other</code>, <code>axis</code>, <code>drop</code>, <code>method</code>, <code>numeric_only</code><code>)</code> (Series) \u2014 Compute pairwise correlation.&lt;/&gt;</li> <li><code>count</code><code>(</code><code>axis</code>, <code>numeric_only</code><code>)</code> (Series) \u2014 Count non-NA cells for each column or row.&lt;/&gt;</li> <li><code>cov</code><code>(</code><code>min_periods</code>, <code>ddof</code>, <code>numeric_only</code><code>)</code> (DataFrame) \u2014 Compute pairwise covariance of columns, excluding NA/null values.&lt;/&gt;</li> <li><code>create</code><code>(</code><code>value</code><code>)</code> (DataFrame) \u2014 Create a channel from a list.&lt;/&gt;</li> <li><code>cummax</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame) \u2014 Return cumulative maximum over a DataFrame or Series axis.&lt;/&gt;</li> <li><code>cummin</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame) \u2014 Return cumulative minimum over a DataFrame or Series axis.&lt;/&gt;</li> <li><code>cumprod</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame) \u2014 Return cumulative product over a DataFrame or Series axis.&lt;/&gt;</li> <li><code>cumsum</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame) \u2014 Return cumulative sum over a DataFrame or Series axis.&lt;/&gt;</li> <li><code>describe</code><code>(</code><code>percentiles</code>, <code>include</code>, <code>exclude</code><code>)</code> (Series or DataFrame) \u2014 Generate descriptive statistics.&lt;/&gt;</li> <li><code>diff</code><code>(</code><code>periods</code>, <code>axis</code><code>)</code> (DataFrame) \u2014 First discrete difference of element.&lt;/&gt;</li> <li><code>dot</code><code>(</code><code>other</code><code>)</code> (Series or DataFrame) \u2014 Compute the matrix multiplication between the DataFrame and other.&lt;/&gt;</li> <li><code>drop</code><code>(</code><code>labels</code>, <code>axis</code>, <code>index</code>, <code>columns</code>, <code>level</code>, <code>inplace</code>, <code>errors</code><code>)</code> (DataFrame or None) \u2014 Drop specified labels from rows or columns.&lt;/&gt;</li> <li><code>drop_duplicates</code><code>(</code><code>subset</code>, <code>keep</code>, <code>inplace</code>, <code>ignore_index</code><code>)</code> (DataFrame or None) \u2014 Return DataFrame with duplicate rows removed.&lt;/&gt;</li> <li><code>droplevel</code><code>(</code><code>level</code>, <code>axis</code><code>)</code> (Series/DataFrame) \u2014 Return Series/DataFrame with requested index / column level(s) removed.&lt;/&gt;</li> <li><code>dropna</code><code>(</code><code>axis</code>, <code>how</code>, <code>thresh</code>, <code>subset</code>, <code>inplace</code>, <code>ignore_index</code><code>)</code> (DataFrame or None) \u2014 Remove missing values.&lt;/&gt;</li> <li><code>duplicated</code><code>(</code><code>subset</code>, <code>keep</code><code>)</code> (Series) \u2014 Return boolean Series denoting duplicate rows.&lt;/&gt;</li> <li><code>eq</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code><code>)</code> (DataFrame of bool) \u2014 Get Equal to of dataframe and other, element-wise (binary operator <code>eq</code>).&lt;/&gt;</li> <li><code>equals</code><code>(</code><code>other</code><code>)</code> (bool) \u2014 Test whether two objects contain the same elements.&lt;/&gt;</li> <li><code>eval</code><code>(</code><code>expr</code>, <code>inplace</code>, <code>**kwargs</code><code>)</code> (ndarray, scalar, pandas object, or None) \u2014 Evaluate a string describing operations on DataFrame columns.&lt;/&gt;</li> <li><code>ewm</code><code>(</code><code>com</code>, <code>span</code>, <code>halflife</code>, <code>alpha</code>, <code>min_periods</code>, <code>adjust</code>, <code>ignore_na</code>, <code>axis</code>, <code>times</code>, <code>method</code><code>)</code> (pandas.api.typing.ExponentialMovingWindow) \u2014 Provide exponentially weighted (EW) calculations.&lt;/&gt;</li> <li><code>expanding</code><code>(</code><code>min_periods</code>, <code>axis</code>, <code>method</code><code>)</code> (pandas.api.typing.Expanding) \u2014 Provide expanding window calculations.&lt;/&gt;</li> <li><code>explode</code><code>(</code><code>column</code>, <code>ignore_index</code><code>)</code> (DataFrame) \u2014 Transform each element of a list-like to a row, replicating index values.&lt;/&gt;</li> <li><code>ffill</code><code>(</code><code>axis</code>, <code>inplace</code>, <code>limit</code>, <code>limit_area</code>, <code>downcast</code><code>)</code> (Series/DataFrame or None) \u2014 Fill NA/NaN values by propagating the last valid observation to next valid.&lt;/&gt;</li> <li><code>fillna</code><code>(</code><code>value</code>, <code>method</code>, <code>axis</code>, <code>inplace</code>, <code>limit</code>, <code>downcast</code><code>)</code> (Series/DataFrame or None) \u2014 Fill NA/NaN values using the specified method.&lt;/&gt;</li> <li><code>filter</code><code>(</code><code>items</code>, <code>like</code>, <code>regex</code>, <code>axis</code><code>)</code> (same type as input object) \u2014 Subset the dataframe rows or columns according to the specified index labels.&lt;/&gt;</li> <li><code>first</code><code>(</code><code>offset</code><code>)</code> (Series or DataFrame) \u2014 Select initial periods of time series data based on a date offset.&lt;/&gt;</li> <li><code>first_valid_index</code><code>(</code><code>)</code> (type of index) \u2014 Return index for first non-NA value or None, if no non-NA value is found.&lt;/&gt;</li> <li><code>floordiv</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Integer division of dataframe and other, element-wise (binary operator <code>floordiv</code>).&lt;/&gt;</li> <li><code>from_csv</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a channel from a csv file&lt;/&gt;</li> <li><code>from_dict</code><code>(</code><code>data</code>, <code>orient</code>, <code>dtype</code>, <code>columns</code><code>)</code> (DataFrame) \u2014 Construct DataFrame from dict of array-like or dicts.&lt;/&gt;</li> <li><code>from_excel</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a channel from an excel file.&lt;/&gt;</li> <li><code>from_glob</code><code>(</code><code>pattern</code>, <code>ftype</code>, <code>sortby</code>, <code>reverse</code><code>)</code> (DataFrame) \u2014 Create a channel with a glob pattern&lt;/&gt;</li> <li><code>from_pairs</code><code>(</code><code>pattern</code>, <code>ftype</code>, <code>sortby</code>, <code>reverse</code><code>)</code> (DataFrame) \u2014 Create a width=2 channel with a glob pattern&lt;/&gt;</li> <li><code>from_records</code><code>(</code><code>data</code>, <code>index</code>, <code>exclude</code>, <code>columns</code>, <code>coerce_float</code>, <code>nrows</code><code>)</code> (DataFrame) \u2014 Convert structured or record ndarray to DataFrame.&lt;/&gt;</li> <li><code>from_table</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Create a channel from a table file.&lt;/&gt;</li> <li><code>ge</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code><code>)</code> (DataFrame of bool) \u2014 Get Greater than or equal to of dataframe and other, element-wise (binary operator <code>ge</code>).&lt;/&gt;</li> <li><code>get</code><code>(</code><code>key</code>, <code>default</code><code>)</code> (same type as items contained in object) \u2014 Get item from object for given key (ex: DataFrame column).&lt;/&gt;</li> <li><code>groupby</code><code>(</code><code>by</code>, <code>axis</code>, <code>level</code>, <code>as_index</code>, <code>sort</code>, <code>group_keys</code>, <code>observed</code>, <code>dropna</code><code>)</code> (pandas.api.typing.DataFrameGroupBy) \u2014 Group DataFrame using a mapper or by a Series of columns.&lt;/&gt;</li> <li><code>gt</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code><code>)</code> (DataFrame of bool) \u2014 Get Greater than of dataframe and other, element-wise (binary operator <code>gt</code>).&lt;/&gt;</li> <li><code>head</code><code>(</code><code>n</code><code>)</code> (same type as caller) \u2014 Return the first <code>n</code> rows.&lt;/&gt;</li> <li><code>idxmax</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code><code>)</code> (Series) \u2014 Return index of first occurrence of maximum over requested axis.&lt;/&gt;</li> <li><code>idxmin</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code><code>)</code> (Series) \u2014 Return index of first occurrence of minimum over requested axis.&lt;/&gt;</li> <li><code>infer_objects</code><code>(</code><code>copy</code><code>)</code> (same type as input object) \u2014 Attempt to infer better dtypes for object columns.&lt;/&gt;</li> <li><code>info</code><code>(</code><code>verbose</code>, <code>buf</code>, <code>max_cols</code>, <code>memory_usage</code>, <code>show_counts</code><code>)</code> (None) \u2014 Print a concise summary of a DataFrame.&lt;/&gt;</li> <li><code>insert</code><code>(</code><code>loc</code>, <code>column</code>, <code>value</code>, <code>allow_duplicates</code><code>)</code> \u2014 Insert column into DataFrame at specified location.&lt;/&gt;</li> <li><code>interpolate</code><code>(</code><code>method</code>, <code>axis</code>, <code>limit</code>, <code>inplace</code>, <code>limit_direction</code>, <code>limit_area</code>, <code>downcast</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame or None) \u2014 Fill NaN values using an interpolation method.&lt;/&gt;</li> <li><code>isetitem</code><code>(</code><code>loc</code>, <code>value</code><code>)</code> \u2014 Set the given value in the column with position <code>loc</code>.&lt;/&gt;</li> <li><code>isin</code><code>(</code><code>values</code><code>)</code> (DataFrame) \u2014 Whether each element in the DataFrame is contained in values.&lt;/&gt;</li> <li><code>isna</code><code>(</code><code>)</code> (DataFrame) \u2014 Detect missing values.&lt;/&gt;</li> <li><code>isnull</code><code>(</code><code>)</code> (DataFrame) \u2014 DataFrame.isnull is an alias for DataFrame.isna.&lt;/&gt;</li> <li><code>items</code><code>(</code><code>)</code> (label : object) \u2014 Iterate over (column name, Series) pairs.&lt;/&gt;</li> <li><code>iterrows</code><code>(</code><code>)</code> (index : label or tuple of label) \u2014 Iterate over DataFrame rows as (index, Series) pairs.&lt;/&gt;</li> <li><code>itertuples</code><code>(</code><code>index</code>, <code>name</code><code>)</code> (iterator) \u2014 Iterate over DataFrame rows as namedtuples.&lt;/&gt;</li> <li><code>join</code><code>(</code><code>other</code>, <code>on</code>, <code>how</code>, <code>lsuffix</code>, <code>rsuffix</code>, <code>sort</code>, <code>validate</code><code>)</code> (DataFrame) \u2014 Join columns of another DataFrame.&lt;/&gt;</li> <li><code>keys</code><code>(</code><code>)</code> (Index) \u2014 Get the 'info axis' (see Indexing for more).&lt;/&gt;</li> <li><code>kurt</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or scalar) \u2014 Return unbiased kurtosis over requested axis.&lt;/&gt;</li> <li><code>last</code><code>(</code><code>offset</code><code>)</code> (Series or DataFrame) \u2014 Select final periods of time series data based on a date offset.&lt;/&gt;</li> <li><code>last_valid_index</code><code>(</code><code>)</code> (type of index) \u2014 Return index for last non-NA value or None, if no non-NA value is found.&lt;/&gt;</li> <li><code>le</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code><code>)</code> (DataFrame of bool) \u2014 Get Less than or equal to of dataframe and other, element-wise (binary operator <code>le</code>).&lt;/&gt;</li> <li><code>lt</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code><code>)</code> (DataFrame of bool) \u2014 Get Less than of dataframe and other, element-wise (binary operator <code>lt</code>).&lt;/&gt;</li> <li><code>map</code><code>(</code><code>func</code>, <code>na_action</code>, <code>**kwargs</code><code>)</code> (DataFrame) \u2014 Apply a function to a Dataframe elementwise.&lt;/&gt;</li> <li><code>mask</code><code>(</code><code>cond</code>, <code>other</code>, <code>inplace</code>, <code>axis</code>, <code>level</code><code>)</code> (Same type as caller or None if ``inplace=True``.) \u2014 Replace values where the condition is True.&lt;/&gt;</li> <li><code>max</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or scalar) \u2014 Return the maximum of the values over the requested axis.&lt;/&gt;</li> <li><code>mean</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or scalar) \u2014 Return the mean of the values over the requested axis.&lt;/&gt;</li> <li><code>median</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or scalar) \u2014 Return the median of the values over the requested axis.&lt;/&gt;</li> <li><code>melt</code><code>(</code><code>id_vars</code>, <code>value_vars</code>, <code>var_name</code>, <code>value_name</code>, <code>col_level</code>, <code>ignore_index</code><code>)</code> (DataFrame) \u2014 Unpivot a DataFrame from wide to long format, optionally leaving identifiers set.&lt;/&gt;</li> <li><code>memory_usage</code><code>(</code><code>index</code>, <code>deep</code><code>)</code> (Series) \u2014 Return the memory usage of each column in bytes.&lt;/&gt;</li> <li><code>merge</code><code>(</code><code>right</code>, <code>how</code>, <code>on</code>, <code>left_on</code>, <code>right_on</code>, <code>left_index</code>, <code>right_index</code>, <code>sort</code>, <code>suffixes</code>, <code>copy</code>, <code>indicator</code>, <code>validate</code><code>)</code> (DataFrame) \u2014 Merge DataFrame or named Series objects with a database-style join.&lt;/&gt;</li> <li><code>min</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or scalar) \u2014 Return the minimum of the values over the requested axis.&lt;/&gt;</li> <li><code>mod</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Modulo of dataframe and other, element-wise (binary operator <code>mod</code>).&lt;/&gt;</li> <li><code>mode</code><code>(</code><code>axis</code>, <code>numeric_only</code>, <code>dropna</code><code>)</code> (DataFrame) \u2014 Get the mode(s) of each element along the selected axis.&lt;/&gt;</li> <li><code>mul</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Multiplication of dataframe and other, element-wise (binary operator <code>mul</code>).&lt;/&gt;</li> <li><code>ne</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code><code>)</code> (DataFrame of bool) \u2014 Get Not equal to of dataframe and other, element-wise (binary operator <code>ne</code>).&lt;/&gt;</li> <li><code>nlargest</code><code>(</code><code>n</code>, <code>columns</code>, <code>keep</code><code>)</code> (DataFrame) \u2014 Return the first <code>n</code> rows ordered by <code>columns</code> in descending order.&lt;/&gt;</li> <li><code>notna</code><code>(</code><code>)</code> (DataFrame) \u2014 Detect existing (non-missing) values.&lt;/&gt;</li> <li><code>notnull</code><code>(</code><code>)</code> (DataFrame) \u2014 DataFrame.notnull is an alias for DataFrame.notna.&lt;/&gt;</li> <li><code>nsmallest</code><code>(</code><code>n</code>, <code>columns</code>, <code>keep</code><code>)</code> (DataFrame) \u2014 Return the first <code>n</code> rows ordered by <code>columns</code> in ascending order.&lt;/&gt;</li> <li><code>nunique</code><code>(</code><code>axis</code>, <code>dropna</code><code>)</code> (Series) \u2014 Count number of distinct elements in specified axis.&lt;/&gt;</li> <li><code>pad</code><code>(</code><code>axis</code>, <code>inplace</code>, <code>limit</code>, <code>downcast</code><code>)</code> (Series/DataFrame or None) \u2014 Fill NA/NaN values by propagating the last valid observation to next valid.&lt;/&gt;</li> <li><code>pct_change</code><code>(</code><code>periods</code>, <code>fill_method</code>, <code>limit</code>, <code>freq</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame) \u2014 Fractional change between the current and a prior element.&lt;/&gt;</li> <li><code>pipe</code><code>(</code><code>func</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (the return type of ``func``.) \u2014 Apply chainable functions that expect Series or DataFrames.&lt;/&gt;</li> <li><code>pivot</code><code>(</code><code>columns</code>, <code>index</code>, <code>values</code><code>)</code> (DataFrame) \u2014 Return reshaped DataFrame organized by given index / column values.&lt;/&gt;</li> <li><code>pivot_table</code><code>(</code><code>values</code>, <code>index</code>, <code>columns</code>, <code>aggfunc</code>, <code>fill_value</code>, <code>margins</code>, <code>dropna</code>, <code>margins_name</code>, <code>observed</code>, <code>sort</code><code>)</code> (DataFrame) \u2014 Create a spreadsheet-style pivot table as a DataFrame.&lt;/&gt;</li> <li><code>pop</code><code>(</code><code>item</code><code>)</code> (Series) \u2014 Return item and drop from frame. Raise KeyError if not found.&lt;/&gt;</li> <li><code>pow</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Exponential power of dataframe and other, element-wise (binary operator <code>pow</code>).&lt;/&gt;</li> <li><code>prod</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code>, <code>min_count</code>, <code>**kwargs</code><code>)</code> (Series or scalar) \u2014 Return the product of the values over the requested axis.&lt;/&gt;</li> <li><code>quantile</code><code>(</code><code>q</code>, <code>axis</code>, <code>numeric_only</code>, <code>interpolation</code>, <code>method</code><code>)</code> (Series or DataFrame) \u2014 Return values at the given quantile over requested axis.&lt;/&gt;</li> <li><code>query</code><code>(</code><code>expr</code>, <code>inplace</code>, <code>**kwargs</code><code>)</code> (DataFrame or None) \u2014 Query the columns of a DataFrame with a boolean expression.&lt;/&gt;</li> <li><code>radd</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Addition of dataframe and other, element-wise (binary operator <code>radd</code>).&lt;/&gt;</li> <li><code>rank</code><code>(</code><code>axis</code>, <code>method</code>, <code>numeric_only</code>, <code>na_option</code>, <code>ascending</code>, <code>pct</code><code>)</code> (same type as caller) \u2014 Compute numerical data ranks (1 through n) along axis.&lt;/&gt;</li> <li><code>reindex</code><code>(</code><code>labels</code>, <code>index</code>, <code>columns</code>, <code>axis</code>, <code>method</code>, <code>copy</code>, <code>level</code>, <code>fill_value</code>, <code>limit</code>, <code>tolerance</code><code>)</code> (DataFrame with changed index.) \u2014 Conform DataFrame to new index with optional filling logic.&lt;/&gt;</li> <li><code>reindex_like</code><code>(</code><code>other</code>, <code>method</code>, <code>copy</code>, <code>limit</code>, <code>tolerance</code><code>)</code> (Series or DataFrame) \u2014 Return an object with matching indices as other object.&lt;/&gt;</li> <li><code>rename</code><code>(</code><code>mapper</code>, <code>index</code>, <code>columns</code>, <code>axis</code>, <code>copy</code>, <code>inplace</code>, <code>level</code>, <code>errors</code><code>)</code> (DataFrame or None) \u2014 Rename columns or index labels.&lt;/&gt;</li> <li><code>rename_axis</code><code>(</code><code>mapper</code>, <code>index</code>, <code>columns</code>, <code>axis</code>, <code>copy</code>, <code>inplace</code><code>)</code> (Series, DataFrame, or None) \u2014 Set the name of the axis for the index or columns.&lt;/&gt;</li> <li><code>reorder_levels</code><code>(</code><code>order</code>, <code>axis</code><code>)</code> (DataFrame) \u2014 Rearrange index levels using input order. May not drop or duplicate levels.&lt;/&gt;</li> <li><code>replace</code><code>(</code><code>to_replace</code>, <code>value</code>, <code>inplace</code>, <code>limit</code>, <code>regex</code>, <code>method</code><code>)</code> (Series/DataFrame) \u2014 Replace values given in <code>to_replace</code> with <code>value</code>.&lt;/&gt;</li> <li><code>resample</code><code>(</code><code>rule</code>, <code>axis</code>, <code>closed</code>, <code>label</code>, <code>convention</code>, <code>kind</code>, <code>on</code>, <code>level</code>, <code>origin</code>, <code>offset</code>, <code>group_keys</code><code>)</code> (pandas.api.typing.Resampler) \u2014 Resample time-series data.&lt;/&gt;</li> <li><code>reset_index</code><code>(</code><code>level</code>, <code>drop</code>, <code>inplace</code>, <code>col_level</code>, <code>col_fill</code>, <code>allow_duplicates</code>, <code>names</code><code>)</code> (DataFrame or None) \u2014 Reset the index, or a level of it.&lt;/&gt;</li> <li><code>rfloordiv</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Integer division of dataframe and other, element-wise (binary operator <code>rfloordiv</code>).&lt;/&gt;</li> <li><code>rmod</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Modulo of dataframe and other, element-wise (binary operator <code>rmod</code>).&lt;/&gt;</li> <li><code>rmul</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Multiplication of dataframe and other, element-wise (binary operator <code>rmul</code>).&lt;/&gt;</li> <li><code>rolling</code><code>(</code><code>window</code>, <code>min_periods</code>, <code>center</code>, <code>win_type</code>, <code>on</code>, <code>axis</code>, <code>closed</code>, <code>step</code>, <code>method</code><code>)</code> (pandas.api.typing.Window or pandas.api.typing.Rolling) \u2014 Provide rolling window calculations.&lt;/&gt;</li> <li><code>round</code><code>(</code><code>decimals</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (DataFrame) \u2014 Round a DataFrame to a variable number of decimal places.&lt;/&gt;</li> <li><code>rpow</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Exponential power of dataframe and other, element-wise (binary operator <code>rpow</code>).&lt;/&gt;</li> <li><code>rsub</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Subtraction of dataframe and other, element-wise (binary operator <code>rsub</code>).&lt;/&gt;</li> <li><code>rtruediv</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Floating division of dataframe and other, element-wise (binary operator <code>rtruediv</code>).&lt;/&gt;</li> <li><code>sample</code><code>(</code><code>n</code>, <code>frac</code>, <code>replace</code>, <code>weights</code>, <code>random_state</code>, <code>axis</code>, <code>ignore_index</code><code>)</code> (Series or DataFrame) \u2014 Return a random sample of items from an axis of object.&lt;/&gt;</li> <li><code>select_dtypes</code><code>(</code><code>include</code>, <code>exclude</code><code>)</code> (DataFrame) \u2014 Return a subset of the DataFrame's columns based on the column dtypes.&lt;/&gt;</li> <li><code>sem</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>ddof</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame (if level specified)) \u2014 Return unbiased standard error of the mean over requested axis.&lt;/&gt;</li> <li><code>set_axis</code><code>(</code><code>labels</code>, <code>axis</code>, <code>copy</code><code>)</code> (DataFrame) \u2014 Assign desired index to given axis.&lt;/&gt;</li> <li><code>set_flags</code><code>(</code><code>copy</code>, <code>allows_duplicate_labels</code><code>)</code> (Series or DataFrame) \u2014 Return a new object with updated flags.&lt;/&gt;</li> <li><code>set_index</code><code>(</code><code>keys</code>, <code>drop</code>, <code>append</code>, <code>inplace</code>, <code>verify_integrity</code><code>)</code> (DataFrame or None) \u2014 Set the DataFrame index using existing columns.&lt;/&gt;</li> <li><code>shift</code><code>(</code><code>periods</code>, <code>freq</code>, <code>axis</code>, <code>fill_value</code>, <code>suffix</code><code>)</code> (DataFrame) \u2014 Shift index by desired number of periods with an optional time <code>freq</code>.&lt;/&gt;</li> <li><code>skew</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or scalar) \u2014 Return unbiased skew over requested axis.&lt;/&gt;</li> <li><code>sort_index</code><code>(</code><code>axis</code>, <code>level</code>, <code>ascending</code>, <code>inplace</code>, <code>kind</code>, <code>na_position</code>, <code>sort_remaining</code>, <code>ignore_index</code>, <code>key</code><code>)</code> (DataFrame or None) \u2014 Sort object by labels (along an axis).&lt;/&gt;</li> <li><code>sort_values</code><code>(</code><code>by</code>, <code>axis</code>, <code>ascending</code>, <code>inplace</code>, <code>kind</code>, <code>na_position</code>, <code>ignore_index</code>, <code>key</code><code>)</code> (DataFrame or None) \u2014 Sort by the values along either axis.&lt;/&gt;</li> <li><code>squeeze</code><code>(</code><code>axis</code><code>)</code> (DataFrame, Series, or scalar) \u2014 Squeeze 1 dimensional axis objects into scalars.&lt;/&gt;</li> <li><code>stack</code><code>(</code><code>level</code>, <code>dropna</code>, <code>sort</code>, <code>future_stack</code><code>)</code> (DataFrame or Series) \u2014 Stack the prescribed level(s) from columns to index.&lt;/&gt;</li> <li><code>std</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>ddof</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame (if level specified)) \u2014 Return sample standard deviation over requested axis.&lt;/&gt;</li> <li><code>sub</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Subtraction of dataframe and other, element-wise (binary operator <code>sub</code>).&lt;/&gt;</li> <li><code>sum</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>numeric_only</code>, <code>min_count</code>, <code>**kwargs</code><code>)</code> (Series or scalar) \u2014 Return the sum of the values over the requested axis.&lt;/&gt;</li> <li><code>swapaxes</code><code>(</code><code>axis1</code>, <code>axis2</code>, <code>copy</code><code>)</code> (same as input) \u2014 Interchange axes and swap values axes appropriately.&lt;/&gt;</li> <li><code>swaplevel</code><code>(</code><code>i</code>, <code>j</code>, <code>axis</code><code>)</code> (DataFrame) \u2014 Swap levels i and j in a :class:<code>MultiIndex</code>.&lt;/&gt;</li> <li><code>tail</code><code>(</code><code>n</code><code>)</code> (type of caller) \u2014 Return the last <code>n</code> rows.&lt;/&gt;</li> <li><code>take</code><code>(</code><code>indices</code>, <code>axis</code>, <code>**kwargs</code><code>)</code> (same type as caller) \u2014 Return the elements in the given positional indices along an axis.&lt;/&gt;</li> <li><code>to_clipboard</code><code>(</code><code>excel</code>, <code>sep</code>, <code>**kwargs</code><code>)</code> \u2014 Copy object to the system clipboard.&lt;/&gt;</li> <li><code>to_csv</code><code>(</code><code>path_or_buf</code>, <code>sep</code>, <code>na_rep</code>, <code>float_format</code>, <code>columns</code>, <code>header</code>, <code>index</code>, <code>index_label</code>, <code>mode</code>, <code>encoding</code>, <code>compression</code>, <code>quoting</code>, <code>quotechar</code>, <code>lineterminator</code>, <code>chunksize</code>, <code>date_format</code>, <code>doublequote</code>, <code>escapechar</code>, <code>decimal</code>, <code>errors</code>, <code>storage_options</code><code>)</code> (None or str) \u2014 Write object to a comma-separated values (csv) file.&lt;/&gt;</li> <li><code>to_dict</code><code>(</code><code>orient</code>, <code>into</code>, <code>index</code><code>)</code> (dict, list or collections.abc.MutableMapping) \u2014 Convert the DataFrame to a dictionary.&lt;/&gt;</li> <li><code>to_excel</code><code>(</code><code>excel_writer</code>, <code>sheet_name</code>, <code>na_rep</code>, <code>float_format</code>, <code>columns</code>, <code>header</code>, <code>index</code>, <code>index_label</code>, <code>startrow</code>, <code>startcol</code>, <code>engine</code>, <code>merge_cells</code>, <code>inf_rep</code>, <code>freeze_panes</code>, <code>storage_options</code>, <code>engine_kwargs</code><code>)</code> \u2014 Write object to an Excel sheet.&lt;/&gt;</li> <li><code>to_feather</code><code>(</code><code>path</code>, <code>**kwargs</code><code>)</code> \u2014 Write a DataFrame to the binary Feather format.&lt;/&gt;</li> <li><code>to_gbq</code><code>(</code><code>destination_table</code>, <code>project_id</code>, <code>chunksize</code>, <code>reauth</code>, <code>if_exists</code>, <code>auth_local_webserver</code>, <code>table_schema</code>, <code>location</code>, <code>progress_bar</code>, <code>credentials</code><code>)</code> \u2014 Write a DataFrame to a Google BigQuery table.&lt;/&gt;</li> <li><code>to_hdf</code><code>(</code><code>path_or_buf</code>, <code>key</code>, <code>mode</code>, <code>complevel</code>, <code>complib</code>, <code>append</code>, <code>format</code>, <code>index</code>, <code>min_itemsize</code>, <code>nan_rep</code>, <code>dropna</code>, <code>data_columns</code>, <code>errors</code>, <code>encoding</code><code>)</code> \u2014 Write the contained data to an HDF5 file using HDFStore.&lt;/&gt;</li> <li><code>to_html</code><code>(</code><code>buf</code>, <code>columns</code>, <code>col_space</code>, <code>header</code>, <code>index</code>, <code>na_rep</code>, <code>formatters</code>, <code>float_format</code>, <code>sparsify</code>, <code>index_names</code>, <code>justify</code>, <code>max_rows</code>, <code>max_cols</code>, <code>show_dimensions</code>, <code>decimal</code>, <code>bold_rows</code>, <code>classes</code>, <code>escape</code>, <code>notebook</code>, <code>border</code>, <code>table_id</code>, <code>render_links</code>, <code>encoding</code><code>)</code> (str or None) \u2014 Render a DataFrame as an HTML table.&lt;/&gt;</li> <li><code>to_json</code><code>(</code><code>path_or_buf</code>, <code>orient</code>, <code>date_format</code>, <code>double_precision</code>, <code>force_ascii</code>, <code>date_unit</code>, <code>default_handler</code>, <code>lines</code>, <code>compression</code>, <code>index</code>, <code>indent</code>, <code>storage_options</code>, <code>mode</code><code>)</code> (None or str) \u2014 Convert the object to a JSON string.&lt;/&gt;</li> <li><code>to_latex</code><code>(</code><code>buf</code>, <code>columns</code>, <code>header</code>, <code>index</code>, <code>na_rep</code>, <code>formatters</code>, <code>float_format</code>, <code>sparsify</code>, <code>index_names</code>, <code>bold_rows</code>, <code>column_format</code>, <code>longtable</code>, <code>escape</code>, <code>encoding</code>, <code>decimal</code>, <code>multicolumn</code>, <code>multicolumn_format</code>, <code>multirow</code>, <code>caption</code>, <code>label</code>, <code>position</code><code>)</code> (str or None) \u2014 Render object to a LaTeX tabular, longtable, or nested table.&lt;/&gt;</li> <li><code>to_markdown</code><code>(</code><code>buf</code>, <code>mode</code>, <code>index</code>, <code>storage_options</code>, <code>**kwargs</code><code>)</code> (str) \u2014 Print DataFrame in Markdown-friendly format.&lt;/&gt;</li> <li><code>to_numpy</code><code>(</code><code>dtype</code>, <code>copy</code>, <code>na_value</code><code>)</code> (numpy.ndarray) \u2014 Convert the DataFrame to a NumPy array.&lt;/&gt;</li> <li><code>to_orc</code><code>(</code><code>path</code>, <code>engine</code>, <code>index</code>, <code>engine_kwargs</code><code>)</code> (bytes if no path argument is provided else None) \u2014 Write a DataFrame to the ORC format.&lt;/&gt;</li> <li><code>to_parquet</code><code>(</code><code>path</code>, <code>engine</code>, <code>compression</code>, <code>index</code>, <code>partition_cols</code>, <code>storage_options</code>, <code>**kwargs</code><code>)</code> (bytes if no path argument is provided else None) \u2014 Write a DataFrame to the binary parquet format.&lt;/&gt;</li> <li><code>to_period</code><code>(</code><code>freq</code>, <code>axis</code>, <code>copy</code><code>)</code> (DataFrame) \u2014 Convert DataFrame from DatetimeIndex to PeriodIndex.&lt;/&gt;</li> <li><code>to_pickle</code><code>(</code><code>path</code>, <code>compression</code>, <code>protocol</code>, <code>storage_options</code><code>)</code> \u2014 Pickle (serialize) object to file.&lt;/&gt;</li> <li><code>to_records</code><code>(</code><code>index</code>, <code>column_dtypes</code>, <code>index_dtypes</code><code>)</code> (numpy.rec.recarray) \u2014 Convert DataFrame to a NumPy record array.&lt;/&gt;</li> <li><code>to_sql</code><code>(</code><code>name</code>, <code>con</code>, <code>schema</code>, <code>if_exists</code>, <code>index</code>, <code>index_label</code>, <code>chunksize</code>, <code>dtype</code>, <code>method</code><code>)</code> (None or int) \u2014 Write records stored in a DataFrame to a SQL database.&lt;/&gt;</li> <li><code>to_stata</code><code>(</code><code>path</code>, <code>convert_dates</code>, <code>write_index</code>, <code>byteorder</code>, <code>time_stamp</code>, <code>data_label</code>, <code>variable_labels</code>, <code>version</code>, <code>convert_strl</code>, <code>compression</code>, <code>storage_options</code>, <code>value_labels</code><code>)</code> \u2014 Export DataFrame object to Stata dta format.&lt;/&gt;</li> <li><code>to_string</code><code>(</code><code>buf</code>, <code>columns</code>, <code>col_space</code>, <code>header</code>, <code>index</code>, <code>na_rep</code>, <code>formatters</code>, <code>float_format</code>, <code>sparsify</code>, <code>index_names</code>, <code>justify</code>, <code>max_rows</code>, <code>max_cols</code>, <code>show_dimensions</code>, <code>decimal</code>, <code>line_width</code>, <code>min_rows</code>, <code>max_colwidth</code>, <code>encoding</code><code>)</code> (str or None) \u2014 Render a DataFrame to a console-friendly tabular output.&lt;/&gt;</li> <li><code>to_timestamp</code><code>(</code><code>freq</code>, <code>how</code>, <code>axis</code>, <code>copy</code><code>)</code> (DataFrame) \u2014 Cast to DatetimeIndex of timestamps, at beginning of period.&lt;/&gt;</li> <li><code>to_xarray</code><code>(</code><code>)</code> (xarray.DataArray or xarray.Dataset) \u2014 Return an xarray object from the pandas object.&lt;/&gt;</li> <li><code>to_xml</code><code>(</code><code>path_or_buffer</code>, <code>index</code>, <code>root_name</code>, <code>row_name</code>, <code>na_rep</code>, <code>attr_cols</code>, <code>elem_cols</code>, <code>namespaces</code>, <code>prefix</code>, <code>encoding</code>, <code>xml_declaration</code>, <code>pretty_print</code>, <code>parser</code>, <code>stylesheet</code>, <code>compression</code>, <code>storage_options</code><code>)</code> (None or str) \u2014 Render a DataFrame to an XML document.&lt;/&gt;</li> <li><code>transform</code><code>(</code><code>func</code>, <code>axis</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> (DataFrame) \u2014 Call <code>func</code> on self producing a DataFrame with the same axis shape as self.&lt;/&gt;</li> <li><code>transpose</code><code>(</code><code>*args</code>, <code>copy</code><code>)</code> (DataFrame) \u2014 Transpose index and columns.&lt;/&gt;</li> <li><code>truediv</code><code>(</code><code>other</code>, <code>axis</code>, <code>level</code>, <code>fill_value</code><code>)</code> (DataFrame) \u2014 Get Floating division of dataframe and other, element-wise (binary operator <code>truediv</code>).&lt;/&gt;</li> <li><code>truncate</code><code>(</code><code>before</code>, <code>after</code>, <code>axis</code>, <code>copy</code><code>)</code> (type of caller) \u2014 Truncate a Series or DataFrame before and after some index value.&lt;/&gt;</li> <li><code>tz_convert</code><code>(</code><code>tz</code>, <code>axis</code>, <code>level</code>, <code>copy</code><code>)</code> (Series/DataFrame) \u2014 Convert tz-aware axis to target time zone.&lt;/&gt;</li> <li><code>tz_localize</code><code>(</code><code>tz</code>, <code>axis</code>, <code>level</code>, <code>copy</code>, <code>ambiguous</code>, <code>nonexistent</code><code>)</code> (Series/DataFrame) \u2014 Localize tz-naive index of a Series or DataFrame to target time zone.&lt;/&gt;</li> <li><code>unstack</code><code>(</code><code>level</code>, <code>fill_value</code>, <code>sort</code><code>)</code> (Series or DataFrame) \u2014 Pivot a level of the (necessarily hierarchical) index labels.&lt;/&gt;</li> <li><code>update</code><code>(</code><code>other</code>, <code>join</code>, <code>overwrite</code>, <code>filter_func</code>, <code>errors</code><code>)</code> (None) \u2014 Modify in place using non-NA values from another DataFrame.&lt;/&gt;</li> <li><code>value_counts</code><code>(</code><code>subset</code>, <code>normalize</code>, <code>sort</code>, <code>ascending</code>, <code>dropna</code><code>)</code> (Series) \u2014 Return a Series containing the frequency of each distinct row in the Dataframe.&lt;/&gt;</li> <li><code>var</code><code>(</code><code>axis</code>, <code>skipna</code>, <code>ddof</code>, <code>numeric_only</code>, <code>**kwargs</code><code>)</code> (Series or DataFrame (if level specified)) \u2014 Return unbiased variance over requested axis.&lt;/&gt;</li> <li><code>where</code><code>(</code><code>cond</code>, <code>other</code>, <code>inplace</code>, <code>axis</code>, <code>level</code><code>)</code> (Same type as caller or None if ``inplace=True``.) \u2014 Replace values where the condition is False.&lt;/&gt;</li> <li><code>xs</code><code>(</code><code>key</code>, <code>axis</code>, <code>level</code>, <code>drop_level</code><code>)</code> (Series or DataFrame) \u2014 Return cross-section from the Series/DataFrame.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Get Addition of DataFrame and other, column-wise.</p><p>Equivalent to <code>DataFrame.add(other)</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Object to be added to the DataFrame.</li> </ul> Returns (DataFrame) <p>The result of adding <code>other</code> to DataFrame.</p> See Also <p>DataFrame.add : Add a DataFrame and another object, with option for index-    or column-oriented addition.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'height': [1.5, 2.6], 'weight': [500, 800]},...                   index=['elk', 'moose'])\n&gt;&gt;&gt; df\n       height  weight\nelk       1.5     500\nmoose     2.6     800\n</code></pre> <p>Adding a scalar affects all rows and columns.</p> <pre><code>&gt;&gt;&gt; df[['height', 'weight']] + 1.5\n       height  weight\nelk       3.0   501.5\nmoose     4.1   801.5\n</code></pre> <p>Each element of a list is added to a column of the DataFrame, in order.</p> <pre><code>&gt;&gt;&gt; df[['height', 'weight']] + [0.5, 1.5]\n       height  weight\nelk       2.0   501.5\nmoose     3.1   801.5\n</code></pre> <p>Keys of a dictionary are aligned to the DataFrame, based on column names; each value in the dictionary is added to the corresponding column.</p> <pre><code>&gt;&gt;&gt; df[['height', 'weight']] + {'height': 0.5, 'weight': 1.5}\n       height  weight\nelk       2.0   501.5\nmoose     3.1   801.5\n</code></pre> <p>When <code>other</code> is a :class:<code>Series</code>, the index of <code>other</code> is aligned with the columns of the DataFrame.</p> <pre><code>&gt;&gt;&gt; s1 = pd.Series([0.5, 1.5], index=['weight', 'height'])\n&gt;&gt;&gt; df[['height', 'weight']] + s1\n       height  weight\nelk       3.0   500.5\nmoose     4.1   800.5\n</code></pre> <p>Even when the index of <code>other</code> is the same as the index of the DataFrame, the :class:<code>Series</code> will not be reoriented. If index-wise alignment is desired, :meth:<code>DataFrame.add</code> should be used with <code>axis='index'</code>.</p> <pre><code>&gt;&gt;&gt; s2 = pd.Series([0.5, 1.5], index=['elk', 'moose'])\n&gt;&gt;&gt; df[['height', 'weight']] + s2\n       elk  height  moose  weight\nelk    NaN     NaN    NaN     NaN\nmoose  NaN     NaN    NaN     NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df[['height', 'weight']].add(s2, axis='index')\n       height  weight\nelk       2.0   500.5\nmoose     4.1   801.5\n</code></pre> <p>When <code>other</code> is a :class:<code>DataFrame</code>, both columns names and the index are aligned.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'height': [0.2, 0.4, 0.6]},\n...                      index=['elk', 'moose', 'deer'])\n&gt;&gt;&gt; df[['height', 'weight']] + other\n       height  weight\ndeer      NaN     NaN\nelk       1.7     NaN\nmoose     3.0     NaN\n</code></pre> method &lt;/&gt; <p>Provide method name lookup and completion.</p> <p>Notes</p> <p>Only provide 'public' methods.</p> method &lt;/&gt; <p>Generates the total memory usage for an object that returnseither a value or Series of values</p> method &lt;/&gt; <p>Return a new object with updated flags.</p> Parameters <ul> <li><code>copy</code> (bool, default False) \u2014 Specify if a copy of the object should be made... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> <li><code>allows_duplicate_labels</code> (bool, optional) \u2014 Whether the returned object allows duplicate labels.</li> </ul> Returns (Series or DataFrame) <p>The same type as the caller.</p> See Also <p>DataFrame.attrs : Global metadata applying to this dataset.DataFrame.flags : Global flags applying to this object.</p> <p>Notes</p> <p>This method returns a new object that's a view on the same data as the input. Mutating the input or the output values will be reflected in the other.</p> <p>This method is intended to be used in method chains.</p> <p>\"Flags\" differ from \"metadata\". Flags reflect properties of the pandas object (the Series or DataFrame). Metadata refer to properties of the dataset, and should be stored in :attr:<code>DataFrame.attrs</code>.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2]})&gt;&gt;&gt; df.flags.allows_duplicate_labels\nTrue\n&gt;&gt;&gt; df2 = df.set_flags(allows_duplicate_labels=False)\n&gt;&gt;&gt; df2.flags.allows_duplicate_labels\nFalse\n</code></pre> method &lt;/&gt; <p>Interchange axes and swap values axes appropriately.</p><p>.. deprecated:: 2.1.0     <code>swapaxes</code> is deprecated and will be removed.     Please use <code>transpose</code> instead.</p> Examples <p>Please see examples for :meth:<code>DataFrame.transpose</code>.</p> method &lt;/&gt; <p>Return Series/DataFrame with requested index / column level(s) removed.</p> Parameters <ul> <li><code>level</code> (int, str, or list-like) \u2014 If a string is given, must be the name of a levelIf list-like, elements must be names or positional indexes of levels. </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Axis along which the level(s) is removed:<ul> <li>0 or 'index': remove level(s) in column.</li> <li>1 or 'columns': remove level(s) in row.</li> </ul> For <code>Series</code> this parameter is unused and defaults to 0. </li> </ul> Returns (Series/DataFrame) <p>Series/DataFrame with requested index / column level(s) removed.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12]\n... ]).set_index([0, 1]).rename_axis(['a', 'b'])\n</code></pre> <pre><code>&gt;&gt;&gt; df.columns = pd.MultiIndex.from_tuples([\n...     ('c', 'e'), ('d', 'f')\n... ], names=['level_1', 'level_2'])\n</code></pre> <pre><code>&gt;&gt;&gt; df\nlevel_1   c   d\nlevel_2   e   f\na b\n1 2      3   4\n5 6      7   8\n9 10    11  12\n</code></pre> <pre><code>&gt;&gt;&gt; df.droplevel('a')\nlevel_1   c   d\nlevel_2   e   f\nb\n2        3   4\n6        7   8\n10      11  12\n</code></pre> <pre><code>&gt;&gt;&gt; df.droplevel('level_2', axis=1)\nlevel_1   c   d\na b\n1 2      3   4\n5 6      7   8\n9 10    11  12\n</code></pre> method &lt;/&gt; <p>Squeeze 1 dimensional axis objects into scalars.</p><p>Series or DataFrames with a single element are squeezed to a scalar. DataFrames with a single column or a single row are squeezed to a Series. Otherwise the object is unchanged.</p> <p>This method is most useful when you don't know if your object is a Series or DataFrame, but you do know it has just a single column. In that case you can safely call <code>squeeze</code> to ensure you have a Series.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default None) \u2014 A specific axis to squeeze. By default, all length-1 axes aresqueezed. For <code>Series</code> this parameter is unused and defaults to <code>None</code>. </li> </ul> Returns (DataFrame, Series, or scalar) <p>The projection after squeezing <code>axis</code> or all the axes.</p> See Also <p>Series.iloc : Integer-location based indexing for selecting scalars.DataFrame.iloc : Integer-location based indexing for selecting Series. Series.to_frame : Inverse of DataFrame.squeeze for a     single-column DataFrame.</p> Examples <pre><code>&gt;&gt;&gt; primes = pd.Series([2, 3, 5, 7])</code></pre> <p>Slicing might produce a Series with a single value:</p> <pre><code>&gt;&gt;&gt; even_primes = primes[primes % 2 == 0]\n&gt;&gt;&gt; even_primes\n0    2\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; even_primes.squeeze()\n2\n</code></pre> <p>Squeezing objects with more than one value in every axis does nothing:</p> <pre><code>&gt;&gt;&gt; odd_primes = primes[primes % 2 == 1]\n&gt;&gt;&gt; odd_primes\n1    3\n2    5\n3    7\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; odd_primes.squeeze()\n1    3\n2    5\n3    7\ndtype: int64\n</code></pre> <p>Squeezing is even more effective when used with DataFrames.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[1, 2], [3, 4]], columns=['a', 'b'])\n&gt;&gt;&gt; df\n   a  b\n0  1  2\n1  3  4\n</code></pre> <p>Slicing a single column will produce a DataFrame with the columns having only one value:</p> <pre><code>&gt;&gt;&gt; df_a = df[['a']]\n&gt;&gt;&gt; df_a\n   a\n0  1\n1  3\n</code></pre> <p>So the columns can be squeezed down, resulting in a Series:</p> <pre><code>&gt;&gt;&gt; df_a.squeeze('columns')\n0    1\n1    3\nName: a, dtype: int64\n</code></pre> <p>Slicing a single row from a single column will produce a single scalar DataFrame:</p> <pre><code>&gt;&gt;&gt; df_0a = df.loc[df.index &lt; 1, ['a']]\n&gt;&gt;&gt; df_0a\n   a\n0  1\n</code></pre> <p>Squeezing the rows produces a single scalar Series:</p> <pre><code>&gt;&gt;&gt; df_0a.squeeze('rows')\na    1\nName: 0, dtype: int64\n</code></pre> <p>Squeezing all axes will project directly into a scalar:</p> <pre><code>&gt;&gt;&gt; df_0a.squeeze()\n1\n</code></pre> method &lt;/&gt; <p>Set the name of the axis for the index or columns.</p> Parameters <ul> <li><code>mapper</code> (scalar, list-like, optional) \u2014 Value to set the axis name attribute.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to rename. For <code>Series</code> this parameter is unused and defaults to 0.</li> <li><code>copy</code> (bool, default None) \u2014 Also copy underlying data... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> <li><code>inplace</code> (bool, default False) \u2014 Modifies the object directly, instead of creating a new Seriesor DataFrame. </li> </ul> Returns (Series, DataFrame, or None) <p>The same type as the caller or None if <code>inplace=True</code>.</p> See Also <p>Series.rename : Alter Series index labels or name.DataFrame.rename : Alter DataFrame index labels or name. Index.rename : Set new names on index.</p> <p>Notes</p> <p><code>DataFrame.rename_axis</code> supports two calling conventions</p> <ul> <li><code>(index=index_mapper, columns=columns_mapper, ...)</code></li> <li><code>(mapper, axis={'index', 'columns'}, ...)</code></li> </ul> <p>The first calling convention will only modify the names of the index and/or the names of the Index object that is the columns. In this case, the parameter <code>copy</code> is ignored.</p> <p>The second calling convention will modify the names of the corresponding index if mapper is a list or a scalar. However, if mapper is dict-like or a function, it will use the deprecated behavior of modifying the axis labels.</p> <p>We highly recommend using keyword arguments to clarify your intent.</p> Examples <p>Series</p><pre><code>&gt;&gt;&gt; s = pd.Series([\"dog\", \"cat\", \"monkey\"])\n&gt;&gt;&gt; s\n0       dog\n1       cat\n2    monkey\ndtype: object\n&gt;&gt;&gt; s.rename_axis(\"animal\")\nanimal\n0    dog\n1    cat\n2    monkey\ndtype: object\n</code></pre> <p>DataFrame</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"num_legs\": [4, 4, 2],\n...                    \"num_arms\": [0, 0, 2]},\n...                   [\"dog\", \"cat\", \"monkey\"])\n&gt;&gt;&gt; df\n        num_legs  num_arms\ndog            4         0\ncat            4         0\nmonkey         2         2\n&gt;&gt;&gt; df = df.rename_axis(\"animal\")\n&gt;&gt;&gt; df\n        num_legs  num_arms\nanimal\ndog            4         0\ncat            4         0\nmonkey         2         2\n&gt;&gt;&gt; df = df.rename_axis(\"limbs\", axis=\"columns\")\n&gt;&gt;&gt; df\nlimbs   num_legs  num_arms\nanimal\ndog            4         0\ncat            4         0\nmonkey         2         2\n</code></pre> <p>MultiIndex</p> <pre><code>&gt;&gt;&gt; df.index = pd.MultiIndex.from_product([['mammal'],\n...                                        ['dog', 'cat', 'monkey']],\n...                                       names=['type', 'name'])\n&gt;&gt;&gt; df\nlimbs          num_legs  num_arms\ntype   name\nmammal dog            4         0\n       cat            4         0\n       monkey         2         2\n</code></pre> <pre><code>&gt;&gt;&gt; df.rename_axis(index={'type': 'class'})\nlimbs          num_legs  num_arms\nclass  name\nmammal dog            4         0\n       cat            4         0\n       monkey         2         2\n</code></pre> <pre><code>&gt;&gt;&gt; df.rename_axis(columns=str.upper)\nLIMBS          num_legs  num_arms\ntype   name\nmammal dog            4         0\n       cat            4         0\n       monkey         2         2\n</code></pre> method &lt;/&gt; <p>Test whether two objects contain the same elements.</p><p>This function allows two Series or DataFrames to be compared against each other to see if they have the same shape and elements. NaNs in the same location are considered equal.</p> <p>The row/column index do not need to have the same type, as long as the values are considered equal. Corresponding columns and index must be of the same dtype.</p> Parameters <ul> <li><code>other</code> (Series or DataFrame) \u2014 The other Series or DataFrame to be compared with the first.</li> </ul> Returns (bool) <p>True if all elements are the same in both objects, Falseotherwise.</p> See Also <p>Series.eq : Compare two Series objects of the same length    and return a Series where each element is True if the element     in each Series is equal, False otherwise. DataFrame.eq : Compare two DataFrame objects of the same shape and     return a DataFrame where each element is True if the respective     element in each DataFrame is equal, False otherwise. testing.assert_series_equal : Raises an AssertionError if left and     right are not equal. Provides an easy interface to ignore     inequality in dtypes, indexes and precision among others. testing.assert_frame_equal : Like assert_series_equal, but targets     DataFrames. numpy.array_equal : Return True if two arrays have the same shape     and elements, False otherwise.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({1: [10], 2: [20]})&gt;&gt;&gt; df\n    1   2\n0  10  20\n</code></pre> <p>DataFrames df and exactly_equal have the same types and values for their elements and column labels, which will return True.</p> <pre><code>&gt;&gt;&gt; exactly_equal = pd.DataFrame({1: [10], 2: [20]})\n&gt;&gt;&gt; exactly_equal\n    1   2\n0  10  20\n&gt;&gt;&gt; df.equals(exactly_equal)\nTrue\n</code></pre> <p>DataFrames df and different_column_type have the same element types and values, but have different types for the column labels, which will still return True.</p> <pre><code>&gt;&gt;&gt; different_column_type = pd.DataFrame({1.0: [10], 2.0: [20]})\n&gt;&gt;&gt; different_column_type\n   1.0  2.0\n0   10   20\n&gt;&gt;&gt; df.equals(different_column_type)\nTrue\n</code></pre> <p>DataFrames df and different_data_type have different types for the same values for their elements, and will return False even though their column labels are the same values and types.</p> <pre><code>&gt;&gt;&gt; different_data_type = pd.DataFrame({1: [10.0], 2: [20.0]})\n&gt;&gt;&gt; different_data_type\n      1     2\n0  10.0  20.0\n&gt;&gt;&gt; df.equals(different_data_type)\nFalse\n</code></pre> method &lt;/&gt; <p>Return the bool of a single element Series or DataFrame.</p><p>.. deprecated:: 2.1.0</p> <p>bool is deprecated and will be removed in future version of pandas.    For <code>Series</code> use <code>pandas.Series.item</code>.</p> <p>This must be a boolean scalar value, either True or False. It will raise a ValueError if the Series or DataFrame does not have exactly 1 element, or that element is not boolean (integer values 0 and 1 will also raise an exception).</p> Returns (bool) <p>The value in the Series or DataFrame.</p> See Also <p>Series.astype : Change the data type of a Series, including to boolean.DataFrame.astype : Change the data type of a DataFrame, including to boolean. numpy.bool_ : NumPy boolean data type, used by pandas for boolean values.</p> Examples <p>The method will only work for single element objects with a boolean value:</p><pre><code>&gt;&gt;&gt; pd.Series([True]).bool()  # doctest: +SKIP\nTrue\n&gt;&gt;&gt; pd.Series([False]).bool()  # doctest: +SKIP\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; pd.DataFrame({'col': [True]}).bool()  # doctest: +SKIP\nTrue\n&gt;&gt;&gt; pd.DataFrame({'col': [False]}).bool()  # doctest: +SKIP\nFalse\n</code></pre> <p>This is an alternative method and will only work for single element objects with a boolean value:</p> <pre><code>&gt;&gt;&gt; pd.Series([True]).item()  # doctest: +SKIP\nTrue\n&gt;&gt;&gt; pd.Series([False]).item()  # doctest: +SKIP\nFalse\n</code></pre> method &lt;/&gt; <p>Return a Series/DataFrame with absolute numeric value of each element.</p><p>This function only applies to elements that are all numeric.</p> Returns (abs) <p>Series/DataFrame containing the absolute value of each element.</p> See Also <p>numpy.absolute : Calculate the absolute value element-wise.</p> <p>Notes</p> <p>For <code>complex</code> inputs, <code>1.2 + 1j</code>, the absolute value is :math:<code>\\sqrt{ a^2 + b^2 }</code>.</p> Examples <p>Absolute numeric values in a Series.</p><pre><code>&gt;&gt;&gt; s = pd.Series([-1.10, 2, -3.33, 4])\n&gt;&gt;&gt; s.abs()\n0    1.10\n1    2.00\n2    3.33\n3    4.00\ndtype: float64\n</code></pre> <p>Absolute numeric values in a Series with complex numbers.</p> <pre><code>&gt;&gt;&gt; s = pd.Series([1.2 + 1j])\n&gt;&gt;&gt; s.abs()\n0    1.56205\ndtype: float64\n</code></pre> <p>Absolute numeric values in a Series with a Timedelta element.</p> <pre><code>&gt;&gt;&gt; s = pd.Series([pd.Timedelta('1 days')])\n&gt;&gt;&gt; s.abs()\n0   1 days\ndtype: timedelta64[ns]\n</code></pre> <p>Select rows with data closest to certain value using argsort (from <code>StackOverflow &lt;https://stackoverflow.com/a/17758115&gt;</code>__).</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'a': [4, 5, 6, 7],\n...     'b': [10, 20, 30, 40],\n...     'c': [100, 50, -30, -50]\n... })\n&gt;&gt;&gt; df\n     a    b    c\n0    4   10  100\n1    5   20   50\n2    6   30  -30\n3    7   40  -50\n&gt;&gt;&gt; df.loc[(df.c - 43).abs().argsort()]\n     a    b    c\n1    5   20   50\n0    4   10  100\n2    6   30  -30\n3    7   40  -50\n</code></pre> method &lt;/&gt; <p>Iterate over info axis.</p> Returns (iterator) <p>Info axis as iterator.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]})&gt;&gt;&gt; for x in df:\n...     print(x)\nA\nB\n</code></pre> method &lt;/&gt; <p>Get the 'info axis' (see Indexing for more).</p><p>This is index for Series, columns for DataFrame.</p> Returns (Index) <p>Info axis.</p> Examples <pre><code>&gt;&gt;&gt; d = pd.DataFrame(data={'A': [1, 2, 3], 'B': [0, 4, 8]},...                  index=['a', 'b', 'c'])\n&gt;&gt;&gt; d\n   A  B\na  1  0\nb  2  4\nc  3  8\n&gt;&gt;&gt; d.keys()\nIndex(['A', 'B'], dtype='object')\n</code></pre> method &lt;/&gt; <p>True if the key is in the info axis</p> method &lt;/&gt; <p>Write object to an Excel sheet.</p><p>To write a single object to an Excel .xlsx file it is only necessary to specify a target file name. To write to multiple sheets it is necessary to create an <code>ExcelWriter</code> object with a target file name, and specify a sheet in the file to write to.</p> <p>Multiple sheets may be written to by specifying unique <code>sheet_name</code>. With all data written to the file it is necessary to save the changes. Note that creating an <code>ExcelWriter</code> object with a file name that already exists will result in the contents of the existing file being erased.</p> Parameters <ul> <li><code>excel_writer</code> (path-like, file-like, or ExcelWriter object) \u2014 File path or existing ExcelWriter.</li> <li><code>sheet_name</code> (str, default 'Sheet1') \u2014 Name of sheet which will contain DataFrame.</li> <li><code>na_rep</code> (str, default '') \u2014 Missing data representation.</li> <li><code>float_format</code> (str, optional) \u2014 Format string for floating point numbers. For example<code>float_format=\"%.2f\"</code> will format 0.1234 to 0.12. </li> <li><code>columns</code> (sequence or list of str, optional) \u2014 Columns to write.</li> <li><code>header</code> (bool or list of str, default True) \u2014 Write out the column names. If a list of string is given it isassumed to be aliases for the column names. </li> <li><code>index</code> (bool, default True) \u2014 Write row names (index).</li> <li><code>index_label</code> (str or sequence, optional) \u2014 Column label for index column(s) if desired. If not specified, and<code>header</code> and <code>index</code> are True, then the index names are used. A sequence should be given if the DataFrame uses MultiIndex. </li> <li><code>startrow</code> (int, default 0) \u2014 Upper left cell row to dump data frame.</li> <li><code>startcol</code> (int, default 0) \u2014 Upper left cell column to dump data frame.</li> <li><code>engine</code> (str, optional) \u2014 Write engine to use, 'openpyxl' or 'xlsxwriter'. You can also set thisvia the options <code>io.excel.xlsx.writer</code> or <code>io.excel.xlsm.writer</code>. </li> <li><code>merge_cells</code> (bool, default True) \u2014 Write MultiIndex and Hierarchical Rows as merged cells.</li> <li><code>inf_rep</code> (str, default 'inf') \u2014 Representation for infinity (there is no native representation forinfinity in Excel). </li> <li><code>freeze_panes</code> (tuple of int (length 2), optional) \u2014 Specifies the one-based bottommost row and rightmost column thatis to be frozen. </li> <li><code>storage_options</code> (dict, optional) \u2014 Extra options that make sense for a particular storage connection, e.g.host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to <code>urllib.request.Request</code> as header options. For other URLs (e.g. starting with \"s3://\", and \"gcs://\") the key-value pairs are forwarded to <code>fsspec.open</code>. Please see <code>fsspec</code> and <code>urllib</code> for more details, and for more examples on storage options refer <code>here &lt;https://pandas.pydata.org/docs/user_guide/io.html? highlight=storage_options#reading-writing-remote-files&gt;</code>_. .. versionadded:: 1.2.0 </li> <li><code>engine_kwargs</code> (dict, optional) \u2014 Arbitrary keyword arguments passed to excel engine.</li> </ul> See Also <p>to_csv : Write DataFrame to a comma-separated values (csv) file.ExcelWriter : Class for writing DataFrame objects into excel sheets. read_excel : Read an Excel file into a pandas DataFrame. read_csv : Read a comma-separated values (csv) file into DataFrame. io.formats.style.Styler.to_excel : Add styles to Excel sheet.</p> <p>Notes</p> <p>For compatibility with :meth:<code>~DataFrame.to_csv</code>, to_excel serializes lists and dicts to strings before writing.</p> <p>Once a workbook has been saved it is not possible to write further data without rewriting the whole workbook.</p> Examples <p>:</p><p>, , ) P</p> <p>:</p> <p>, P</p> <p>s :</p> <p>) P ) )</p> <p>:</p> <p>, P )</p> <p>, s :</p> <p>P</p> method &lt;/&gt; <p>Convert the object to a JSON string.</p><p>Note NaN's and None will be converted to null and datetime objects will be converted to UNIX timestamps.</p> Parameters <ul> <li><code>path_or_buf</code> (str, path object, file-like object, or None, default None) \u2014 String, path object (implementing os.PathLike[str]), or file-likeobject implementing a write() function. If None, the result is returned as a string. </li> <li><code>orient</code> (str) \u2014 Indication of expected JSON string format.<ul> <li> Series: <ul> <li>default is 'index'</li> <li>allowed values are: {'split', 'records', 'index', 'table'}.</li> </ul> </li> <li> DataFrame: <ul> <li>default is 'columns'</li> <li>allowed values are: {'split', 'records', 'index', 'columns',   'values', 'table'}.</li> </ul> </li> <li> The format of the JSON string: <ul> <li>'split' : dict like {'index' -&gt; [index], 'columns' -&gt; [columns],   'data' -&gt; [values]}</li> <li>'records' : list like [{column -&gt; value}, ... , {column -&gt; value}]</li> <li>'index' : dict like {index -&gt; {column -&gt; value}}</li> <li>'columns' : dict like {column -&gt; {index -&gt; value}}</li> <li>'values' : just the values array</li> <li>'table' : dict like {'schema': {schema}, 'data': {data}}</li> </ul> Describing the data, where data component is like <code>orient='records'</code>. </li> </ul> </li> <li><code>date_format</code> ({None, 'epoch', 'iso'}) \u2014 Type of date conversion. 'epoch' = epoch milliseconds,'iso' = ISO8601. The default depends on the <code>orient</code>. For <code>orient='table'</code>, the default is 'iso'. For all other orients, the default is 'epoch'. </li> <li><code>double_precision</code> (int, default 10) \u2014 The number of decimal places to use when encodingfloating point values. The possible maximal value is 15. Passing double_precision greater than 15 will raise a ValueError. </li> <li><code>force_ascii</code> (bool, default True) \u2014 Force encoded string to be ASCII.</li> <li><code>date_unit</code> (str, default 'ms' (milliseconds)) \u2014 The time unit to encode to, governs timestamp and ISO8601precision.  One of 's', 'ms', 'us', 'ns' for second, millisecond, microsecond, and nanosecond respectively. </li> <li><code>default_handler</code> (callable, default None) \u2014 Handler to call if object cannot otherwise be converted to asuitable format for JSON. Should receive a single argument which is the object to convert and return a serialisable object. </li> <li><code>lines</code> (bool, default False) \u2014 If 'orient' is 'records' write out line-delimited json format. Willthrow ValueError if incorrect 'orient' since others are not list-like. </li> <li><code>compression</code> (str or dict, default 'infer') \u2014 For on-the-fly compression of the output data. If 'infer' and 'path_or_buf' ispath-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', '.xz', '.zst', '.tar', '.tar.gz', '.tar.xz' or '.tar.bz2' (otherwise no compression). Set to <code>None</code> for no compression. Can also be a dict with key <code>'method'</code> set to one of {<code>'zip'</code>, <code>'gzip'</code>, <code>'bz2'</code>, <code>'zstd'</code>, <code>'xz'</code>, <code>'tar'</code>} and other key-value pairs are forwarded to <code>zipfile.ZipFile</code>, <code>gzip.GzipFile</code>, <code>bz2.BZ2File</code>, <code>zstandard.ZstdCompressor</code>, <code>lzma.LZMAFile</code> or <code>tarfile.TarFile</code>, respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: <code>compression={'method': 'gzip', 'compresslevel': 1, 'mtime': 1}</code>. .. versionadded:: 1.5.0     Added support for <code>.tar</code> files. .. versionchanged:: 1.4.0 Zstandard support. </li> <li><code>index</code> (bool or None, default None) \u2014 The index is only used when 'orient' is 'split', 'index', 'column',or 'table'. Of these, 'index' and 'column' do not support <code>index=False</code>. </li> <li><code>indent</code> (int, optional) \u2014 Length of whitespace used to indent each record.</li> <li><code>storage_options</code> (dict, optional) \u2014 Extra options that make sense for a particular storage connection, e.g.host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to <code>urllib.request.Request</code> as header options. For other URLs (e.g. starting with \"s3://\", and \"gcs://\") the key-value pairs are forwarded to <code>fsspec.open</code>. Please see <code>fsspec</code> and <code>urllib</code> for more details, and for more examples on storage options refer <code>here &lt;https://pandas.pydata.org/docs/user_guide/io.html? highlight=storage_options#reading-writing-remote-files&gt;</code>_. </li> <li><code>mode</code> (str, default 'w' (writing)) \u2014 Specify the IO mode for output when supplying a path_or_buf.Accepted args are 'w' (writing) and 'a' (append) only. mode='a' is only supported when lines is True and orient is 'records'. </li> </ul> Returns (None or str) <p>If path_or_buf is None, returns the resulting json format as astring. Otherwise returns None.</p> See Also <p>read_json : Convert a JSON string to pandas object.</p> <p>Notes</p> <p>The behavior of <code>indent=0</code> varies from the stdlib, which does not indent the output but does insert newlines. Currently, <code>indent=0</code> and the default <code>indent=None</code> are equivalent in pandas, though this may change in a future release.</p> <p><code>orient='table'</code> contains a 'pandas_version' field under 'schema'. This stores the version of <code>pandas</code> used in the latest revision of the schema.</p> Examples <pre><code>&gt;&gt;&gt; from json import loads, dumps&gt;&gt;&gt; df = pd.DataFrame(\n...     [[\"a\", \"b\"], [\"c\", \"d\"]],\n...     index=[\"row 1\", \"row 2\"],\n...     columns=[\"col 1\", \"col 2\"],\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; result = df.to_json(orient=\"split\")\n&gt;&gt;&gt; parsed = loads(result)\n&gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP\n{\n    \"columns\": [\n        \"col 1\",\n        \"col 2\"\n    ],\n    \"index\": [\n        \"row 1\",\n        \"row 2\"\n    ],\n    \"data\": [\n        [\n            \"a\",\n            \"b\"\n        ],\n        [\n            \"c\",\n            \"d\"\n        ]\n    ]\n}\n</code></pre> <p>Encoding/decoding a Dataframe using <code>'records'</code> formatted JSON. Note that index labels are not preserved with this encoding.</p> <pre><code>&gt;&gt;&gt; result = df.to_json(orient=\"records\")\n&gt;&gt;&gt; parsed = loads(result)\n&gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP\n[\n    {\n        \"col 1\": \"a\",\n        \"col 2\": \"b\"\n    },\n    {\n        \"col 1\": \"c\",\n        \"col 2\": \"d\"\n    }\n]\n</code></pre> <p>Encoding/decoding a Dataframe using <code>'index'</code> formatted JSON:</p> <pre><code>&gt;&gt;&gt; result = df.to_json(orient=\"index\")\n&gt;&gt;&gt; parsed = loads(result)\n&gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP\n{\n    \"row 1\": {\n        \"col 1\": \"a\",\n        \"col 2\": \"b\"\n    },\n    \"row 2\": {\n        \"col 1\": \"c\",\n        \"col 2\": \"d\"\n    }\n}\n</code></pre> <p>Encoding/decoding a Dataframe using <code>'columns'</code> formatted JSON:</p> <pre><code>&gt;&gt;&gt; result = df.to_json(orient=\"columns\")\n&gt;&gt;&gt; parsed = loads(result)\n&gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP\n{\n    \"col 1\": {\n        \"row 1\": \"a\",\n        \"row 2\": \"c\"\n    },\n    \"col 2\": {\n        \"row 1\": \"b\",\n        \"row 2\": \"d\"\n    }\n}\n</code></pre> <p>Encoding/decoding a Dataframe using <code>'values'</code> formatted JSON:</p> <pre><code>&gt;&gt;&gt; result = df.to_json(orient=\"values\")\n&gt;&gt;&gt; parsed = loads(result)\n&gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP\n[\n    [\n        \"a\",\n        \"b\"\n    ],\n    [\n        \"c\",\n        \"d\"\n    ]\n]\n</code></pre> <p>Encoding with Table Schema:</p> <pre><code>&gt;&gt;&gt; result = df.to_json(orient=\"table\")\n&gt;&gt;&gt; parsed = loads(result)\n&gt;&gt;&gt; dumps(parsed, indent=4)  # doctest: +SKIP\n{\n    \"schema\": {\n        \"fields\": [\n            {\n                \"name\": \"index\",\n                \"type\": \"string\"\n            },\n            {\n                \"name\": \"col 1\",\n                \"type\": \"string\"\n            },\n            {\n                \"name\": \"col 2\",\n                \"type\": \"string\"\n            }\n        ],\n        \"primaryKey\": [\n            \"index\"\n        ],\n        \"pandas_version\": \"1.4.0\"\n    },\n    \"data\": [\n        {\n            \"index\": \"row 1\",\n            \"col 1\": \"a\",\n            \"col 2\": \"b\"\n        },\n        {\n            \"index\": \"row 2\",\n            \"col 1\": \"c\",\n            \"col 2\": \"d\"\n        }\n    ]\n}\n</code></pre> method &lt;/&gt; <p>Write the contained data to an HDF5 file using HDFStore.</p><p>Hierarchical Data Format (HDF) is self-describing, allowing an application to interpret the structure and contents of a file with no outside information. One HDF file can hold a mix of related objects which can be accessed as a group or as individual objects.</p> <p>In order to add another DataFrame or Series to an existing HDF file please use append mode and a different a key.</p> <p>.. warning::</p> <p>One can store a subclass of <code>DataFrame</code> or <code>Series</code> to HDF5,    but the type of the subclass is lost upon storing.</p> <p>For more information see the :ref:<code>user guide &lt;io.hdf5&gt;</code>.</p> Parameters <ul> <li><code>path_or_buf</code> (str or pandas.HDFStore) \u2014 File path or HDFStore object.</li> <li><code>key</code> (str) \u2014 Identifier for the group in the store.</li> <li><code>mode</code> ({'a', 'w', 'r+'}, default 'a') \u2014 Mode to open file:<ul> <li>'w': write, a new file is created (an existing file with   the same name would be deleted).</li> <li>'a': append, an existing file is opened for reading and   writing, and if the file does not exist it is created.</li> <li>'r+': similar to 'a', but the file must already exist.</li> </ul> </li> <li><code>complevel</code> ({0-9}, default None) \u2014 Specifies a compression level for data.A value of 0 or None disables compression. </li> <li><code>complib</code> ({'zlib', 'lzo', 'bzip2', 'blosc'}, default 'zlib') \u2014 Specifies the compression library to be used.These additional compressors for Blosc are supported (default if no compressor specified: 'blosc:blosclz'): {'blosc:blosclz', 'blosc:lz4', 'blosc:lz4hc', 'blosc:snappy', 'blosc:zlib', 'blosc:zstd'}. Specifying a compression library which is not available issues a ValueError. </li> <li><code>append</code> (bool, default False) \u2014 For Table formats, append the input data to the existing.</li> <li><code>format</code> ({'fixed', 'table', None}, default 'fixed') \u2014 Possible values:<ul> <li>'fixed': Fixed format. Fast writing/reading. Not-appendable,   nor searchable.</li> <li>'table': Table format. Write as a PyTables Table structure   which may perform worse but allow more flexible operations   like searching / selecting subsets of the data.</li> <li>If None, pd.get_option('io.hdf.default_format') is checked,   followed by fallback to \"fixed\".</li> </ul> </li> <li><code>index</code> (bool, default True) \u2014 Write DataFrame index as a column.</li> <li><code>min_itemsize</code> (dict or int, optional) \u2014 Map column names to minimum string sizes for columns.</li> <li><code>nan_rep</code> (Any, optional) \u2014 How to represent null values as str.Not allowed with append=True. </li> <li><code>dropna</code> (bool, default False, optional) \u2014 Remove missing values.</li> <li><code>data_columns</code> (list of columns or True, optional) \u2014 List of columns to create as indexed data columns for on-diskqueries, or True to use all columns. By default only the axes of the object are indexed. See :ref:<code>Query via data columns&lt;io.hdf5-query-data-columns&gt;</code>. for more information. Applicable only to format='table'. </li> <li><code>errors</code> (str, default 'strict') \u2014 Specifies how encoding and decoding errors are to be handled.See the errors argument for :func:<code>open</code> for a full list of options. </li> </ul> See Also <p>read_hdf : Read from HDF file.DataFrame.to_orc : Write a DataFrame to the binary orc format. DataFrame.to_parquet : Write a DataFrame to the binary parquet format. DataFrame.to_sql : Write to a SQL table. DataFrame.to_feather : Write out feather-format for DataFrames. DataFrame.to_csv : Write out to a csv file.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2, 3], 'B': [4, 5, 6]},...                   index=['a', 'b', 'c'])  # doctest: +SKIP\n&gt;&gt;&gt; df.to_hdf('data.h5', key='df', mode='w')  # doctest: +SKIP\n</code></pre> <p>We can add another object to the same file:</p> <pre><code>&gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])  # doctest: +SKIP\n&gt;&gt;&gt; s.to_hdf('data.h5', key='s')  # doctest: +SKIP\n</code></pre> <p>Reading from HDF file:</p> <pre><code>&gt;&gt;&gt; pd.read_hdf('data.h5', 'df')  # doctest: +SKIP\nA  B\na  1  4\nb  2  5\nc  3  6\n&gt;&gt;&gt; pd.read_hdf('data.h5', 's')  # doctest: +SKIP\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n</code></pre> method &lt;/&gt; <p>Write records stored in a DataFrame to a SQL database.</p><p>Databases supported by SQLAlchemy [1]_ are supported. Tables can be newly created, appended to, or overwritten.</p> Parameters <ul> <li><code>name</code> (str) \u2014 Name of SQL table.</li> <li><code>con</code> (sqlalchemy.engine.(Engine or Connection) or sqlite3.Connection) \u2014 Using SQLAlchemy makes it possible to use any DB supported by thatlibrary. Legacy support is provided for sqlite3.Connection objects. The user is responsible for engine disposal and connection closure for the SQLAlchemy connectable. See <code>here                 &lt;https://docs.sqlalchemy.org/en/20/core/connections.html&gt;</code>_. If passing a sqlalchemy.engine.Connection which is already in a transaction, the transaction will not be committed.  If passing a sqlite3.Connection, it will not be possible to roll back the record insertion. </li> <li><code>schema</code> (str, optional) \u2014 Specify the schema (if database flavor supports this). If None, usedefault schema. </li> <li><code>if_exists</code> ({'fail', 'replace', 'append'}, default 'fail') \u2014 How to behave if the table already exists.<ul> <li>fail: Raise a ValueError.</li> <li>replace: Drop the table before inserting new values.</li> <li>append: Insert new values to the existing table.</li> </ul> </li> <li><code>index</code> (bool, default True) \u2014 Write DataFrame index as a column. Uses <code>index_label</code> as the columnname in the table. Creates a table index for this column. </li> <li><code>index_label</code> (str or sequence, default None) \u2014 Column label for index column(s). If None is given (default) and<code>index</code> is True, then the index names are used. A sequence should be given if the DataFrame uses MultiIndex. </li> <li><code>chunksize</code> (int, optional) \u2014 Specify the number of rows in each batch to be written at a time.By default, all rows will be written at once. </li> <li><code>dtype</code> (dict or scalar, optional) \u2014 Specifying the datatype for columns. If a dictionary is used, thekeys should be the column names and the values should be the SQLAlchemy types or strings for the sqlite3 legacy mode. If a scalar is provided, it will be applied to all columns. </li> <li><code>method</code> ({None, 'multi', callable}, optional) \u2014 Controls the SQL insertion clause used:<ul> <li>None : Uses standard SQL <code>INSERT</code> clause (one per row).</li> <li>'multi': Pass multiple values in a single <code>INSERT</code> clause.</li> <li>callable with signature <code>(pd_table, conn, keys, data_iter)</code>.</li> </ul> Details and a sample callable implementation can be found in the section :ref:<code>insert method &lt;io.sql.method&gt;</code>. </li> </ul> Returns (None or int) <p>Number of rows affected by to_sql. None is returned if the callablepassed into <code>method</code> does not return an integer number of rows.</p> <p>The number of returned rows affected is the sum of the <code>rowcount</code> attribute of <code>sqlite3.Cursor</code> or SQLAlchemy connectable which may not reflect the exact number of written rows as stipulated in the <code>sqlite3 &lt;https://docs.python.org/3/library/sqlite3.html#sqlite3.Cursor.rowcount&gt;</code> or <code>SQLAlchemy &lt;https://docs.sqlalchemy.org/en/20/core/connections.html#sqlalchemy.engine.CursorResult.rowcount&gt;</code>.</p> <p>.. versionadded:: 1.4.0</p> Raises <ul> <li><code>ValueError</code> \u2014 When the table already exists and <code>if_exists</code> is 'fail' (thedefault). </li> </ul> See Also <p>read_sql : Read a DataFrame from a table.</p> <p>Notes</p> <p>Timezone aware datetime columns will be written as <code>Timestamp with timezone</code> type with SQLAlchemy if supported by the database. Otherwise, the datetimes will be stored as timezone unaware timestamps local to the original timezone.</p> <p>Not all datastores support <code>method=\"multi\"</code>. Oracle, for example, does not support multi-value insert.</p> References <p>.. [1] https://docs.sqlalchemy.org.. [2] https://www.python.org/dev/peps/pep-0249/</p> Examples <p>Create an in-memory SQLite database.</p><pre><code>&gt;&gt;&gt; from sqlalchemy import create_engine\n&gt;&gt;&gt; engine = create_engine('sqlite://', echo=False)\n</code></pre> <p>Create a table from scratch with 3 rows.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'name' : ['User 1', 'User 2', 'User 3']})\n&gt;&gt;&gt; df\n     name\n0  User 1\n1  User 2\n2  User 3\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_sql(name='users', con=engine)\n3\n&gt;&gt;&gt; from sqlalchemy import text\n&gt;&gt;&gt; with engine.connect() as conn:\n...    conn.execute(text(\"SELECT * FROM users\")).fetchall()\n[(0, 'User 1'), (1, 'User 2'), (2, 'User 3')]\n</code></pre> <p>An <code>sqlalchemy.engine.Connection</code> can also be passed to <code>con</code>:</p> <pre><code>&gt;&gt;&gt; with engine.begin() as connection:\n...     df1 = pd.DataFrame({'name' : ['User 4', 'User 5']})\n...     df1.to_sql(name='users', con=connection, if_exists='append')\n2\n</code></pre> <p>This is allowed to support operations that require that the same DBAPI connection is used for the entire operation.</p> <pre><code>&gt;&gt;&gt; df2 = pd.DataFrame({'name' : ['User 6', 'User 7']})\n&gt;&gt;&gt; df2.to_sql(name='users', con=engine, if_exists='append')\n2\n&gt;&gt;&gt; with engine.connect() as conn:\n...    conn.execute(text(\"SELECT * FROM users\")).fetchall()\n[(0, 'User 1'), (1, 'User 2'), (2, 'User 3'),\n (0, 'User 4'), (1, 'User 5'), (0, 'User 6'),\n (1, 'User 7')]\n</code></pre> <p>Overwrite the table with just <code>df2</code>.</p> <pre><code>&gt;&gt;&gt; df2.to_sql(name='users', con=engine, if_exists='replace',\n...            index_label='id')\n2\n&gt;&gt;&gt; with engine.connect() as conn:\n...    conn.execute(text(\"SELECT * FROM users\")).fetchall()\n[(0, 'User 6'), (1, 'User 7')]\n</code></pre> <p>Use <code>method</code> to define a callable insertion method to do nothing if there's a primary key conflict on a table in a PostgreSQL database.</p> <pre><code>&gt;&gt;&gt; from sqlalchemy.dialects.postgresql import insert\n&gt;&gt;&gt; def insert_on_conflict_nothing(table, conn, keys, data_iter):\n...     # \"a\" is the primary key in \"conflict_table\"\n...     data = [dict(zip(keys, row)) for row in data_iter]\n...     stmt = insert(table.table).values(data).on_conflict_do_nothing(index_elements=[\"a\"])\n...     result = conn.execute(stmt)\n...     return result.rowcount\n&gt;&gt;&gt; df_conflict.to_sql(name=\"conflict_table\", con=conn, if_exists=\"append\", method=insert_on_conflict_nothing)  # doctest: +SKIP\n0\n</code></pre> <p>For MySQL, a callable to update columns <code>b</code> and <code>c</code> if there's a conflict on a primary key.</p> <pre><code>&gt;&gt;&gt; from sqlalchemy.dialects.mysql import insert\n&gt;&gt;&gt; def insert_on_conflict_update(table, conn, keys, data_iter):\n...     # update columns \"b\" and \"c\" on primary key conflict\n...     data = [dict(zip(keys, row)) for row in data_iter]\n...     stmt = (\n...         insert(table.table)\n...         .values(data)\n...     )\n...     stmt = stmt.on_duplicate_key_update(b=stmt.inserted.b, c=stmt.inserted.c)\n...     result = conn.execute(stmt)\n...     return result.rowcount\n&gt;&gt;&gt; df_conflict.to_sql(name=\"conflict_table\", con=conn, if_exists=\"append\", method=insert_on_conflict_update)  # doctest: +SKIP\n2\n</code></pre> <p>Specify the dtype (especially useful for integers with missing values). Notice that while pandas is forced to store the data as floating point, the database supports nullable integers. When fetching the data with Python, we get back integer scalars.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, None, 2]})\n&gt;&gt;&gt; df\n     A\n0  1.0\n1  NaN\n2  2.0\n</code></pre> <pre><code>&gt;&gt;&gt; from sqlalchemy.types import Integer\n&gt;&gt;&gt; df.to_sql(name='integers', con=engine, index=False,\n...           dtype={\"A\": Integer()})\n3\n</code></pre> <pre><code>&gt;&gt;&gt; with engine.connect() as conn:\n...   conn.execute(text(\"SELECT * FROM integers\")).fetchall()\n[(1,), (None,), (2,)]\n</code></pre> method &lt;/&gt; <p>Pickle (serialize) object to file.</p> Parameters <ul> <li><code>path</code> (str, path object, or file-like object) \u2014 String, path object (implementing <code>os.PathLike[str]</code>), or file-likeobject implementing a binary <code>write()</code> function. File path where the pickled object will be stored. </li> <li><code>compression</code> (str or dict, default 'infer') \u2014 For on-the-fly compression of the output data. If 'infer' and 'path' ispath-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', '.xz', '.zst', '.tar', '.tar.gz', '.tar.xz' or '.tar.bz2' (otherwise no compression). Set to <code>None</code> for no compression. Can also be a dict with key <code>'method'</code> set to one of {<code>'zip'</code>, <code>'gzip'</code>, <code>'bz2'</code>, <code>'zstd'</code>, <code>'xz'</code>, <code>'tar'</code>} and other key-value pairs are forwarded to <code>zipfile.ZipFile</code>, <code>gzip.GzipFile</code>, <code>bz2.BZ2File</code>, <code>zstandard.ZstdCompressor</code>, <code>lzma.LZMAFile</code> or <code>tarfile.TarFile</code>, respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: <code>compression={'method': 'gzip', 'compresslevel': 1, 'mtime': 1}</code>. .. versionadded:: 1.5.0     Added support for <code>.tar</code> files. </li> <li><code>protocol</code> (int) \u2014 Int which indicates which protocol should be used by the pickler,default HIGHEST_PROTOCOL (see [1]_ paragraph 12.1.2). The possible values are 0, 1, 2, 3, 4, 5. A negative value for the protocol parameter is equivalent to setting its value to HIGHEST_PROTOCOL. .. [1] https://docs.python.org/3/library/pickle.html. </li> <li><code>storage_options</code> (dict, optional) \u2014 Extra options that make sense for a particular storage connection, e.g.host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to <code>urllib.request.Request</code> as header options. For other URLs (e.g. starting with \"s3://\", and \"gcs://\") the key-value pairs are forwarded to <code>fsspec.open</code>. Please see <code>fsspec</code> and <code>urllib</code> for more details, and for more examples on storage options refer <code>here &lt;https://pandas.pydata.org/docs/user_guide/io.html? highlight=storage_options#reading-writing-remote-files&gt;</code>_. </li> </ul> See Also <p>read_pickle : Load pickled pandas object (or any object) from file.DataFrame.to_hdf : Write DataFrame to an HDF5 file. DataFrame.to_sql : Write DataFrame to a SQL database. DataFrame.to_parquet : Write a DataFrame to the binary parquet format.</p> Examples <pre><code>&gt;&gt;&gt; original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})  # doctest: +SKIP&gt;&gt;&gt; original_df  # doctest: +SKIP\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n&gt;&gt;&gt; original_df.to_pickle(\"./dummy.pkl\")  # doctest: +SKIP\n</code></pre> <pre><code>&gt;&gt;&gt; unpickled_df = pd.read_pickle(\"./dummy.pkl\")  # doctest: +SKIP\n&gt;&gt;&gt; unpickled_df  # doctest: +SKIP\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n</code></pre> method &lt;/&gt; <p>Copy object to the system clipboard.</p><p>Write a text representation of object to the system clipboard. This can be pasted into Excel, for example.</p> Parameters <ul> <li><code>excel</code> (bool, default True) \u2014 Produce output in a csv format for easy pasting into excel.<ul> <li>True, use the provided separator for csv pasting.</li> <li>False, write a string representation of the object to the clipboard.</li> </ul> </li> <li><code>sep</code> (str, default ``'\\t'``) \u2014 Field delimiter.</li> <li><code>**kwargs</code> \u2014 These parameters will be passed to DataFrame.to_csv.</li> </ul> See Also <p>DataFrame.to_csv : Write a DataFrame to a comma-separated values    (csv) file. read_clipboard : Read text from clipboard and pass to read_csv.</p> <p>Notes</p> <p>Requirements for your platform.</p> <ul> <li>Linux : <code>xclip</code>, or <code>xsel</code> (with <code>PyQt4</code> modules)</li> <li>Windows : none</li> <li>macOS : none</li> </ul> <p>This method uses the processes developed for the package <code>pyperclip</code>. A solution to render any output string format is given in the examples.</p> Examples <p>Copy the contents of a DataFrame to the clipboard.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=['A', 'B', 'C'])\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_clipboard(sep=',')  # doctest: +SKIP\n... # Wrote the following to the system clipboard:\n... # ,A,B,C\n... # 0,1,2,3\n... # 1,4,5,6\n</code></pre> <p>We can omit the index by passing the keyword <code>index</code> and setting it to false.</p> <pre><code>&gt;&gt;&gt; df.to_clipboard(sep=',', index=False)  # doctest: +SKIP\n... # Wrote the following to the system clipboard:\n... # A,B,C\n... # 1,2,3\n... # 4,5,6\n</code></pre> <p>Using the original <code>pyperclip</code> package for any string output format.</p> <p>.. code-block:: python</p> <p>import pyperclip    html = df.style.to_html()    pyperclip.copy(html)</p> method &lt;/&gt; <p>Return an xarray object from the pandas object.</p> Returns (xarray.DataArray or xarray.Dataset) <p>Data in the pandas structure converted to Dataset if the object isa DataFrame, or a DataArray if the object is a Series.</p> See Also <p>DataFrame.to_hdf : Write DataFrame to an HDF5 file.DataFrame.to_parquet : Write a DataFrame to the binary parquet format.</p> <p>Notes</p> <p>See the <code>xarray docs &lt;https://xarray.pydata.org/en/stable/&gt;</code>__</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([('falcon', 'bird', 389.0, 2),...                    ('parrot', 'bird', 24.0, 2),\n...                    ('lion', 'mammal', 80.5, 4),\n...                    ('monkey', 'mammal', np.nan, 4)],\n...                   columns=['name', 'class', 'max_speed',\n...                            'num_legs'])\n&gt;&gt;&gt; df\n     name   class  max_speed  num_legs\n0  falcon    bird      389.0         2\n1  parrot    bird       24.0         2\n2    lion  mammal       80.5         4\n3  monkey  mammal        NaN         4\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_xarray()  # doctest: +SKIP\n&lt;xarray.Dataset&gt;\nDimensions:    (index: 4)\nCoordinates:\n  * index      (index) int64 32B 0 1 2 3\nData variables:\n    name       (index) object 32B 'falcon' 'parrot' 'lion' 'monkey'\n    class      (index) object 32B 'bird' 'bird' 'mammal' 'mammal'\n    max_speed  (index) float64 32B 389.0 24.0 80.5 nan\n    num_legs   (index) int64 32B 2 2 4 4\n</code></pre> <pre><code>&gt;&gt;&gt; df['max_speed'].to_xarray()  # doctest: +SKIP\n&lt;xarray.DataArray 'max_speed' (index: 4)&gt;\narray([389. ,  24. ,  80.5,   nan])\nCoordinates:\n  * index    (index) int64 0 1 2 3\n</code></pre> <pre><code>&gt;&gt;&gt; dates = pd.to_datetime(['2018-01-01', '2018-01-01',\n...                         '2018-01-02', '2018-01-02'])\n&gt;&gt;&gt; df_multiindex = pd.DataFrame({'date': dates,\n...                               'animal': ['falcon', 'parrot',\n...                                          'falcon', 'parrot'],\n...                               'speed': [350, 18, 361, 15]})\n&gt;&gt;&gt; df_multiindex = df_multiindex.set_index(['date', 'animal'])\n</code></pre> <pre><code>&gt;&gt;&gt; df_multiindex\n                   speed\ndate       animal\n2018-01-01 falcon    350\n           parrot     18\n2018-01-02 falcon    361\n           parrot     15\n</code></pre> <pre><code>&gt;&gt;&gt; df_multiindex.to_xarray()  # doctest: +SKIP\n&lt;xarray.Dataset&gt;\nDimensions:  (date: 2, animal: 2)\nCoordinates:\n  * date     (date) datetime64[ns] 2018-01-01 2018-01-02\n  * animal   (animal) object 'falcon' 'parrot'\nData variables:\n    speed    (date, animal) int64 350 18 361 15\n</code></pre> method &lt;/&gt; <p>Render object to a LaTeX tabular, longtable, or nested table.</p><p>Requires <code>\\usepackage{{booktabs}}</code>.  The output can be copy/pasted into a main LaTeX document or read from an external file with <code>\\input{{table.tex}}</code>.</p> <p>.. versionchanged:: 2.0.0    Refactored to use the Styler implementation via jinja2 templating.</p> Parameters <ul> <li><code>buf</code> (str, Path or StringIO-like, optional, default None) \u2014 Buffer to write to. If None, the output is returned as a string.</li> <li><code>columns</code> (list of label, optional) \u2014 The subset of columns to write. Writes all columns by default.</li> <li><code>header</code> (bool or list of str, default True) \u2014 Write out the column names. If a list of strings is given,it is assumed to be aliases for the column names. </li> <li><code>index</code> (bool, default True) \u2014 Write row names (index).</li> <li><code>na_rep</code> (str, default 'NaN') \u2014 Missing data representation.</li> <li><code>formatters</code> (list of functions or dict of {{str: function}}, optional) \u2014 Formatter functions to apply to columns' elements by position orname. The result of each function must be a unicode string. List must be of length equal to the number of columns. </li> <li><code>float_format</code> (one-parameter function or str, optional, default None) \u2014 Formatter for floating point numbers. For example<code>float_format=\"%.2f\"</code> and <code>float_format=\"{{:0.2f}}\".format</code> will both result in 0.1234 being formatted as 0.12. </li> <li><code>sparsify</code> (bool, optional) \u2014 Set to False for a DataFrame with a hierarchical index to printevery multiindex key at each row. By default, the value will be read from the config module. </li> <li><code>index_names</code> (bool, default True) \u2014 Prints the names of the indexes.</li> <li><code>bold_rows</code> (bool, default False) \u2014 Make the row labels bold in the output.</li> <li><code>column_format</code> (str, optional) \u2014 The columns format as specified in <code>LaTeX table format&lt;https://en.wikibooks.org/wiki/LaTeX/Tables&gt;</code>__ e.g. 'rcl' for 3 columns. By default, 'l' will be used for all columns except columns of numbers, which default to 'r'. </li> <li><code>longtable</code> (bool, optional) \u2014 Use a longtable environment instead of tabular. Requiresadding a \\usepackage{{longtable}} to your LaTeX preamble. By default, the value will be read from the pandas config module, and set to <code>True</code> if the option <code>styler.latex.environment</code> is <code>\"longtable\"</code>. .. versionchanged:: 2.0.0    The pandas option affecting this argument has changed. </li> <li><code>escape</code> (bool, optional) \u2014 By default, the value will be read from the pandas configmodule and set to <code>True</code> if the option <code>styler.format.escape</code> is <code>\"latex\"</code>. When set to False prevents from escaping latex special characters in column names. .. versionchanged:: 2.0.0    The pandas option affecting this argument has changed, as has the    default value to <code>False</code>. </li> <li><code>encoding</code> (str, optional) \u2014 A string representing the encoding to use in the output file,defaults to 'utf-8'. </li> <li><code>decimal</code> (str, default '.') \u2014 Character recognized as decimal separator, e.g. ',' in Europe.</li> <li><code>multicolumn</code> (bool, default True) \u2014 Use \\multicolumn to enhance MultiIndex columns.The default will be read from the config module, and is set as the option <code>styler.sparse.columns</code>. .. versionchanged:: 2.0.0    The pandas option affecting this argument has changed. </li> <li><code>multicolumn_format</code> (str, default 'r') \u2014 The alignment for multicolumns, similar to <code>column_format</code>The default will be read from the config module, and is set as the option <code>styler.latex.multicol_align</code>. .. versionchanged:: 2.0.0    The pandas option affecting this argument has changed, as has the    default value to \"r\". </li> <li><code>multirow</code> (bool, default True) \u2014 Use \\multirow to enhance MultiIndex rows. Requires adding a\\usepackage{{multirow}} to your LaTeX preamble. Will print centered labels (instead of top-aligned) across the contained rows, separating groups via clines. The default will be read from the pandas config module, and is set as the option <code>styler.sparse.index</code>. .. versionchanged:: 2.0.0    The pandas option affecting this argument has changed, as has the    default value to <code>True</code>. </li> <li><code>caption</code> (str or tuple, optional) \u2014 Tuple (full_caption, short_caption),which results in <code>\\caption[short_caption]{{full_caption}}</code>; if a single string is passed, no short caption will be set. </li> <li><code>label</code> (str, optional) \u2014 The LaTeX label to be placed inside <code>\\label{{}}</code> in the output.This is used with <code>\\ref{{}}</code> in the main <code>.tex</code> file. </li> <li><code>position</code> (str, optional) \u2014 The LaTeX positional argument for tables, to be placed after<code>\\begin{{}}</code> in the output. </li> </ul> Returns (str or None) <p>If buf is None, returns the result as a string. Otherwise returns None.</p> See Also <p>io.formats.style.Styler.to_latex : Render a DataFrame to LaTeX    with conditional formatting. DataFrame.to_string : Render a DataFrame to a console-friendly     tabular output. DataFrame.to_html : Render a DataFrame as an HTML table.</p> <p>Notes</p> <p>As of v2.0.0 this method has changed to use the Styler implementation as part of :meth:<code>.Styler.to_latex</code> via <code>jinja2</code> templating. This means that <code>jinja2</code> is a requirement, and needs to be installed, for this method to function. It is advised that users switch to using Styler, since that implementation is more frequently updated and contains much more flexibility with the output.</p> Examples <p>Convert a general DataFrame to LaTeX with formatting:</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame(dict(name=['Raphael', 'Donatello'],\n...                        age=[26, 45],\n...                        height=[181.23, 177.65]))\n&gt;&gt;&gt; print(df.to_latex(index=False,\n...                   formatters={\"name\": str.upper},\n...                   float_format=\"{:.1f}\".format,\n... ))  # doctest: +SKIP\n\\begin{tabular}{lrr}\n\\toprule\nname &amp; age &amp; height \\\\\n\\midrule\nRAPHAEL &amp; 26 &amp; 181.2 \\\\\nDONATELLO &amp; 45 &amp; 177.7 \\\\\n\\bottomrule\n\\end{tabular}\n</code></pre> method &lt;/&gt; <p>Write object to a comma-separated values (csv) file.</p> Parameters <ul> <li><code>path_or_buf</code> (str, path object, file-like object, or None, default None) \u2014 String, path object (implementing os.PathLike[str]), or file-likeobject implementing a write() function. If None, the result is returned as a string. If a non-binary file object is passed, it should be opened with <code>newline=''</code>, disabling universal newlines. If a binary file object is passed, <code>mode</code> might need to contain a <code>'b'</code>. </li> <li><code>sep</code> (str, default ',') \u2014 String of length 1. Field delimiter for the output file.</li> <li><code>na_rep</code> (str, default '') \u2014 Missing data representation.</li> <li><code>float_format</code> (str, Callable, default None) \u2014 Format string for floating point numbers. If a Callable is given, it takesprecedence over other numeric formatting parameters, like decimal. </li> <li><code>columns</code> (sequence, optional) \u2014 Columns to write.</li> <li><code>header</code> (bool or list of str, default True) \u2014 Write out the column names. If a list of strings is given it isassumed to be aliases for the column names. </li> <li><code>index</code> (bool, default True) \u2014 Write row names (index).</li> <li><code>index_label</code> (str or sequence, or False, default None) \u2014 Column label for index column(s) if desired. If None is given, and<code>header</code> and <code>index</code> are True, then the index names are used. A sequence should be given if the object uses MultiIndex. If False do not print fields for index names. Use index_label=False for easier importing in R. </li> <li><code>mode</code> ({'w', 'x', 'a'}, default 'w') \u2014 Forwarded to either <code>open(mode=)</code> or <code>fsspec.open(mode=)</code> to controlthe file opening. Typical values include: <ul> <li>'w', truncate the file first.</li> <li>'x', exclusive creation, failing if the file already exists.</li> <li>'a', append to the end of file if it exists.</li> </ul> </li> <li><code>encoding</code> (str, optional) \u2014 A string representing the encoding to use in the output file,defaults to 'utf-8'. <code>encoding</code> is not supported if <code>path_or_buf</code> is a non-binary file object. </li> <li><code>compression</code> (str or dict, default 'infer') \u2014 For on-the-fly compression of the output data. If 'infer' and 'path_or_buf' ispath-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', '.xz', '.zst', '.tar', '.tar.gz', '.tar.xz' or '.tar.bz2' (otherwise no compression). Set to <code>None</code> for no compression. Can also be a dict with key <code>'method'</code> set to one of {<code>'zip'</code>, <code>'gzip'</code>, <code>'bz2'</code>, <code>'zstd'</code>, <code>'xz'</code>, <code>'tar'</code>} and other key-value pairs are forwarded to <code>zipfile.ZipFile</code>, <code>gzip.GzipFile</code>, <code>bz2.BZ2File</code>, <code>zstandard.ZstdCompressor</code>, <code>lzma.LZMAFile</code> or <code>tarfile.TarFile</code>, respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: <code>compression={'method': 'gzip', 'compresslevel': 1, 'mtime': 1}</code>. .. versionadded:: 1.5.0     Added support for <code>.tar</code> files. May be a dict with key 'method' as compression mode    and other entries as additional compression options if    compression mode is 'zip'. Passing compression options as keys in dict is    supported for compression modes 'gzip', 'bz2', 'zstd', and 'zip'. </li> <li><code>quoting</code> (optional constant from csv module) \u2014 Defaults to csv.QUOTE_MINIMAL. If you have set a <code>float_format</code>then floats are converted to strings and thus csv.QUOTE_NONNUMERIC will treat them as non-numeric. </li> <li><code>quotechar</code> (str, default '\\\"') \u2014 String of length 1. Character used to quote fields.</li> <li><code>lineterminator</code> (str, optional) \u2014 The newline character or character sequence to use in the outputfile. Defaults to <code>os.linesep</code>, which depends on the OS in which this method is called ('\\n' for linux, '\\r\\n' for Windows, i.e.). .. versionchanged:: 1.5.0 <pre><code>Previously was line_terminator, changed for consistency with\nread_csv and the standard library 'csv' module.\n</code></pre> </li> <li><code>chunksize</code> (int or None) \u2014 Rows to write at a time.</li> <li><code>date_format</code> (str, default None) \u2014 Format string for datetime objects.</li> <li><code>doublequote</code> (bool, default True) \u2014 Control quoting of <code>quotechar</code> inside a field.</li> <li><code>escapechar</code> (str, default None) \u2014 String of length 1. Character used to escape <code>sep</code> and <code>quotechar</code>when appropriate. </li> <li><code>decimal</code> (str, default '.') \u2014 Character recognized as decimal separator. E.g. use ',' forEuropean data. </li> <li><code>errors</code> (str, default 'strict') \u2014 Specifies how encoding and decoding errors are to be handled.See the errors argument for :func:<code>open</code> for a full list of options. </li> <li><code>storage_options</code> (dict, optional) \u2014 Extra options that make sense for a particular storage connection, e.g.host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to <code>urllib.request.Request</code> as header options. For other URLs (e.g. starting with \"s3://\", and \"gcs://\") the key-value pairs are forwarded to <code>fsspec.open</code>. Please see <code>fsspec</code> and <code>urllib</code> for more details, and for more examples on storage options refer <code>here &lt;https://pandas.pydata.org/docs/user_guide/io.html? highlight=storage_options#reading-writing-remote-files&gt;</code>_. </li> </ul> Returns (None or str) <p>If path_or_buf is None, returns the resulting csv format as astring. Otherwise returns None.</p> See Also <p>read_csv : Load a CSV file into a DataFrame.to_excel : Write DataFrame to an Excel file.</p> Examples <p>Create 'out.csv' containing 'df' without indices</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame({'name': ['Raphael', 'Donatello'],\n...                    'mask': ['red', 'purple'],\n...                    'weapon': ['sai', 'bo staff']})\n&gt;&gt;&gt; df.to_csv('out.csv', index=False)  # doctest: +SKIP\n</code></pre> <p>Create 'out.zip' containing 'out.csv'</p> <pre><code>&gt;&gt;&gt; df.to_csv(index=False)\n'name,mask,weapon\\nRaphael,red,sai\\nDonatello,purple,bo staff\\n'\n&gt;&gt;&gt; compression_opts = dict(method='zip',\n...                         archive_name='out.csv')  # doctest: +SKIP\n&gt;&gt;&gt; df.to_csv('out.zip', index=False,\n...           compression=compression_opts)  # doctest: +SKIP\n</code></pre> <p>To write a csv file to a new folder or nested folder you will first need to create it using either Pathlib or os:</p> <pre><code>&gt;&gt;&gt; from pathlib import Path  # doctest: +SKIP\n&gt;&gt;&gt; filepath = Path('folder/subfolder/out.csv')  # doctest: +SKIP\n&gt;&gt;&gt; filepath.parent.mkdir(parents=True, exist_ok=True)  # doctest: +SKIP\n&gt;&gt;&gt; df.to_csv(filepath)  # doctest: +SKIP\n</code></pre> <pre><code>&gt;&gt;&gt; import os  # doctest: +SKIP\n&gt;&gt;&gt; os.makedirs('folder/subfolder', exist_ok=True)  # doctest: +SKIP\n&gt;&gt;&gt; df.to_csv('folder/subfolder/out.csv')  # doctest: +SKIP\n</code></pre> method &lt;/&gt; <p>Return the elements in the given positional indices along an axis.</p><p>This means that we are not indexing according to actual values in the index attribute of the object. We are indexing according to the actual position of the element in the object.</p> Parameters <ul> <li><code>indices</code> (array-like) \u2014 An array of ints indicating which positions to take.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default 0) \u2014 The axis on which to select elements. <code>0</code> means that we areselecting rows, <code>1</code> means that we are selecting columns. For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>**kwargs</code> \u2014 For compatibility with :meth:<code>numpy.take</code>. Has no effect on theoutput. </li> </ul> Returns (same type as caller) <p>An array-like containing the elements taken from the object.</p> See Also <p>DataFrame.loc : Select a subset of a DataFrame by labels.DataFrame.iloc : Select a subset of a DataFrame by positions. numpy.take : Take elements from an array along an axis.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([('falcon', 'bird', 389.0),...                    ('parrot', 'bird', 24.0),\n...                    ('lion', 'mammal', 80.5),\n...                    ('monkey', 'mammal', np.nan)],\n...                   columns=['name', 'class', 'max_speed'],\n...                   index=[0, 2, 3, 1])\n&gt;&gt;&gt; df\n     name   class  max_speed\n0  falcon    bird      389.0\n2  parrot    bird       24.0\n3    lion  mammal       80.5\n1  monkey  mammal        NaN\n</code></pre> <p>Take elements at positions 0 and 3 along the axis 0 (default).</p> <p>Note how the actual indices selected (0 and 1) do not correspond to our selected indices 0 and 3. That's because we are selecting the 0th and 3rd rows, not rows whose indices equal 0 and 3.</p> <pre><code>&gt;&gt;&gt; df.take([0, 3])\n     name   class  max_speed\n0  falcon    bird      389.0\n1  monkey  mammal        NaN\n</code></pre> <p>Take elements at indices 1 and 2 along the axis 1 (column selection).</p> <pre><code>&gt;&gt;&gt; df.take([1, 2], axis=1)\n    class  max_speed\n0    bird      389.0\n2    bird       24.0\n3  mammal       80.5\n1  mammal        NaN\n</code></pre> <p>We may take elements using negative integers for positive indices, starting from the end of the object, just like with Python lists.</p> <pre><code>&gt;&gt;&gt; df.take([-1, -2])\n     name   class  max_speed\n1  monkey  mammal        NaN\n3    lion  mammal       80.5\n</code></pre> method &lt;/&gt; <p>Return cross-section from the Series/DataFrame.</p><p>This method takes a <code>key</code> argument to select data at a particular level of a MultiIndex.</p> Parameters <ul> <li><code>key</code> (label or tuple of label) \u2014 Label contained in the index, or partially in a MultiIndex.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Axis to retrieve cross-section on.</li> <li><code>level</code> (object, defaults to first n levels (n=1 or len(key))) \u2014 In case of a key partially contained in a MultiIndex, indicatewhich levels are used. Levels can be referred by label or position. </li> <li><code>drop_level</code> (bool, default True) \u2014 If False, returns object with same levels as self.</li> </ul> Returns (Series or DataFrame) <p>Cross-section from the original Series or DataFramecorresponding to the selected index levels.</p> See Also <p>DataFrame.loc : Access a group of rows and columns    by label(s) or a boolean array. DataFrame.iloc : Purely integer-location based indexing     for selection by position.</p> <p>Notes</p> <p><code>xs</code> can not be used to set values.</p> <p>MultiIndex Slicers is a generic way to get/set values on any level or levels. It is a superset of <code>xs</code> functionality, see :ref:<code>MultiIndex Slicers &lt;advanced.mi_slicers&gt;</code>.</p> Examples <pre><code>&gt;&gt;&gt; d = {'num_legs': [4, 4, 2, 2],...      'num_wings': [0, 0, 2, 2],\n...      'class': ['mammal', 'mammal', 'mammal', 'bird'],\n...      'animal': ['cat', 'dog', 'bat', 'penguin'],\n...      'locomotion': ['walks', 'walks', 'flies', 'walks']}\n&gt;&gt;&gt; df = pd.DataFrame(data=d)\n&gt;&gt;&gt; df = df.set_index(['class', 'animal', 'locomotion'])\n&gt;&gt;&gt; df\n                           num_legs  num_wings\nclass  animal  locomotion\nmammal cat     walks              4          0\n       dog     walks              4          0\n       bat     flies              2          2\nbird   penguin walks              2          2\n</code></pre> <p>Get values at specified index</p> <pre><code>&gt;&gt;&gt; df.xs('mammal')\n                   num_legs  num_wings\nanimal locomotion\ncat    walks              4          0\ndog    walks              4          0\nbat    flies              2          2\n</code></pre> <p>Get values at several indexes</p> <pre><code>&gt;&gt;&gt; df.xs(('mammal', 'dog', 'walks'))\nnum_legs     4\nnum_wings    0\nName: (mammal, dog, walks), dtype: int64\n</code></pre> <p>Get values at specified index and level</p> <pre><code>&gt;&gt;&gt; df.xs('cat', level=1)\n                   num_legs  num_wings\nclass  locomotion\nmammal walks              4          0\n</code></pre> <p>Get values at several indexes and levels</p> <pre><code>&gt;&gt;&gt; df.xs(('bird', 'walks'),\n...       level=[0, 'locomotion'])\n         num_legs  num_wings\nanimal\npenguin         2          2\n</code></pre> <p>Get values at specified column and axis</p> <pre><code>&gt;&gt;&gt; df.xs('num_wings', axis=1)\nclass   animal   locomotion\nmammal  cat      walks         0\n        dog      walks         0\n        bat      flies         2\nbird    penguin  walks         2\nName: num_wings, dtype: int64\n</code></pre> method &lt;/&gt; <p>Delete item</p> method &lt;/&gt; <p>Get item from object for given key (ex: DataFrame column).</p><p>Returns default value if not found.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(...     [\n...         [24.3, 75.7, \"high\"],\n...         [31, 87.8, \"high\"],\n...         [22, 71.6, \"medium\"],\n...         [35, 95, \"medium\"],\n...     ],\n...     columns=[\"temp_celsius\", \"temp_fahrenheit\", \"windspeed\"],\n...     index=pd.date_range(start=\"2014-02-12\", end=\"2014-02-15\", freq=\"D\"),\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; df\n            temp_celsius  temp_fahrenheit windspeed\n2014-02-12          24.3             75.7      high\n2014-02-13          31.0             87.8      high\n2014-02-14          22.0             71.6    medium\n2014-02-15          35.0             95.0    medium\n</code></pre> <pre><code>&gt;&gt;&gt; df.get([\"temp_celsius\", \"windspeed\"])\n            temp_celsius windspeed\n2014-02-12          24.3      high\n2014-02-13          31.0      high\n2014-02-14          22.0    medium\n2014-02-15          35.0    medium\n</code></pre> <pre><code>&gt;&gt;&gt; ser = df['windspeed']\n&gt;&gt;&gt; ser.get('2014-02-13')\n'high'\n</code></pre> <p>If the key isn't found, the default value will be used.</p> <pre><code>&gt;&gt;&gt; df.get([\"temp_celsius\", \"temp_kelvin\"], default=\"default_value\")\n'default_value'\n</code></pre> <pre><code>&gt;&gt;&gt; ser.get('2014-02-10', '[unknown]')\n'[unknown]'\n</code></pre> method &lt;/&gt; <p>Return an object with matching indices as other object.</p><p>Conform the object to the same index on all axes. Optional filling logic, placing NaN in locations having no value in the previous index. A new object is produced unless the new index is equivalent to the current one and copy=False.</p> Parameters <ul> <li><code>other</code> (Object of the same data type) \u2014 Its row and column indices are used to define the new indicesof this object. </li> <li><code>method</code> ({None, 'backfill'/'bfill', 'pad'/'ffill', 'nearest'}) \u2014 Method to use for filling holes in reindexed DataFrame.Please note: this is only applicable to DataFrames/Series with a monotonically increasing/decreasing index. <ul> <li>None (default): don't fill gaps</li> <li>pad / ffill: propagate last valid observation forward to next   valid</li> <li>backfill / bfill: use next valid observation to fill gap</li> <li>nearest: use nearest valid observations to fill gap.</li> </ul> </li> <li><code>copy</code> (bool, default True) \u2014 Return a new object, even if the passed indexes are the same... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> <li><code>limit</code> (int, default None) \u2014 Maximum number of consecutive labels to fill for inexact matches.</li> <li><code>tolerance</code> (optional) \u2014 Maximum distance between original and new labels for inexactmatches. The values of the index at the matching locations must satisfy the equation <code>abs(index[indexer] - target) &lt;= tolerance</code>. Tolerance may be a scalar value, which applies the same tolerance to all values, or list-like, which applies variable tolerance per element. List-like includes list, tuple, array, Series, and must be the same size as the index and its dtype must exactly match the index's type. </li> </ul> Returns (Series or DataFrame) <p>Same type as caller, but with changed indices on each axis.</p> See Also <p>DataFrame.set_index : Set row labels.DataFrame.reset_index : Remove row labels or move them to new columns. DataFrame.reindex : Change to new indices or expand indices.</p> <p>Notes</p> <p>Same as calling <code>.reindex(index=other.index, columns=other.columns,...)</code>.</p> Examples <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame([[24.3, 75.7, 'high'],...                     [31, 87.8, 'high'],\n...                     [22, 71.6, 'medium'],\n...                     [35, 95, 'medium']],\n...                    columns=['temp_celsius', 'temp_fahrenheit',\n...                             'windspeed'],\n...                    index=pd.date_range(start='2014-02-12',\n...                                        end='2014-02-15', freq='D'))\n</code></pre> <pre><code>&gt;&gt;&gt; df1\n            temp_celsius  temp_fahrenheit windspeed\n2014-02-12          24.3             75.7      high\n2014-02-13          31.0             87.8      high\n2014-02-14          22.0             71.6    medium\n2014-02-15          35.0             95.0    medium\n</code></pre> <pre><code>&gt;&gt;&gt; df2 = pd.DataFrame([[28, 'low'],\n...                     [30, 'low'],\n...                     [35.1, 'medium']],\n...                    columns=['temp_celsius', 'windspeed'],\n...                    index=pd.DatetimeIndex(['2014-02-12', '2014-02-13',\n...                                            '2014-02-15']))\n</code></pre> <pre><code>&gt;&gt;&gt; df2\n            temp_celsius windspeed\n2014-02-12          28.0       low\n2014-02-13          30.0       low\n2014-02-15          35.1    medium\n</code></pre> <pre><code>&gt;&gt;&gt; df2.reindex_like(df1)\n            temp_celsius  temp_fahrenheit windspeed\n2014-02-12          28.0              NaN       low\n2014-02-13          30.0              NaN       low\n2014-02-14           NaN              NaN       NaN\n2014-02-15          35.1              NaN    medium\n</code></pre> method &lt;/&gt; <p>Prefix labels with string <code>prefix</code>.</p><p>For Series, the row labels are prefixed. For DataFrame, the column labels are prefixed.</p> Parameters <ul> <li><code>prefix</code> (str) \u2014 The string to add before each label.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default None) \u2014 Axis to add prefix on.. versionadded:: 2.0.0 </li> </ul> Returns (Series or DataFrame) <p>New Series or DataFrame with updated labels.</p> See Also <p>Series.add_suffix: Suffix row labels with string <code>suffix</code>.DataFrame.add_suffix: Suffix column labels with string <code>suffix</code>.</p> Examples <pre><code>&gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])&gt;&gt;&gt; s\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s.add_prefix('item_')\nitem_0    1\nitem_1    2\nitem_2    3\nitem_3    4\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2, 3, 4], 'B': [3, 4, 5, 6]})\n&gt;&gt;&gt; df\n   A  B\n0  1  3\n1  2  4\n2  3  5\n3  4  6\n</code></pre> <pre><code>&gt;&gt;&gt; df.add_prefix('col_')\n     col_A  col_B\n0       1       3\n1       2       4\n2       3       5\n3       4       6\n</code></pre> method &lt;/&gt; <p>Suffix labels with string <code>suffix</code>.</p><p>For Series, the row labels are suffixed. For DataFrame, the column labels are suffixed.</p> Parameters <ul> <li><code>suffix</code> (str) \u2014 The string to add after each label.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default None) \u2014 Axis to add suffix on.. versionadded:: 2.0.0 </li> </ul> Returns (Series or DataFrame) <p>New Series or DataFrame with updated labels.</p> See Also <p>Series.add_prefix: Prefix row labels with string <code>prefix</code>.DataFrame.add_prefix: Prefix column labels with string <code>prefix</code>.</p> Examples <pre><code>&gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])&gt;&gt;&gt; s\n0    1\n1    2\n2    3\n3    4\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s.add_suffix('_item')\n0_item    1\n1_item    2\n2_item    3\n3_item    4\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2, 3, 4], 'B': [3, 4, 5, 6]})\n&gt;&gt;&gt; df\n   A  B\n0  1  3\n1  2  4\n2  3  5\n3  4  6\n</code></pre> <pre><code>&gt;&gt;&gt; df.add_suffix('_col')\n     A_col  B_col\n0       1       3\n1       2       4\n2       3       5\n3       4       6\n</code></pre> method &lt;/&gt; <p>Subset the dataframe rows or columns according to the specified index labels.</p><p>Note that this routine does not filter a dataframe on its contents. The filter is applied to the labels of the index.</p> Parameters <ul> <li><code>items</code> (list-like) \u2014 Keep labels from axis which are in items.</li> <li><code>like</code> (str) \u2014 Keep labels from axis for which \"like in label == True\".</li> <li><code>regex</code> (str (regular expression)) \u2014 Keep labels from axis for which re.search(regex, label) == True.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default None) \u2014 The axis to filter on, expressed either as an index (int)or axis name (str). By default this is the info axis, 'columns' for DataFrame. For <code>Series</code> this parameter is unused and defaults to <code>None</code>. </li> </ul> See Also <p>DataFrame.loc : Access a group of rows and columns    by label(s) or a boolean array.</p> <p>Notes</p> <p>The <code>items</code>, <code>like</code>, and <code>regex</code> parameters are enforced to be mutually exclusive.</p> <p><code>axis</code> defaults to the info axis that is used when indexing with <code>[]</code>.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.array(([1, 2, 3], [4, 5, 6])),...                   index=['mouse', 'rabbit'],\n...                   columns=['one', 'two', 'three'])\n&gt;&gt;&gt; df\n        one  two  three\nmouse     1    2      3\nrabbit    4    5      6\n</code></pre> <pre><code>&gt;&gt;&gt; # select columns by name\n&gt;&gt;&gt; df.filter(items=['one', 'three'])\n         one  three\nmouse     1      3\nrabbit    4      6\n</code></pre> <pre><code>&gt;&gt;&gt; # select columns by regular expression\n&gt;&gt;&gt; df.filter(regex='e$', axis=1)\n         one  three\nmouse     1      3\nrabbit    4      6\n</code></pre> <pre><code>&gt;&gt;&gt; # select rows containing 'bbi'\n&gt;&gt;&gt; df.filter(like='bbi', axis=0)\n         one  two  three\nrabbit    4    5      6\n</code></pre> method &lt;/&gt; <p>Return the first <code>n</code> rows.</p><p>This function returns the first <code>n</code> rows for the object based on position. It is useful for quickly testing if your object has the right type of data in it.</p> <p>For negative values of <code>n</code>, this function returns all rows except the last <code>|n|</code> rows, equivalent to <code>df[:n]</code>.</p> <p>If n is larger than the number of rows, this function returns all rows.</p> Parameters <ul> <li><code>n</code> (int, default 5) \u2014 Number of rows to select.</li> </ul> Returns (same type as caller) <p>The first <code>n</code> rows of the caller object.</p> See Also <p>DataFrame.tail: Returns the last <code>n</code> rows.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'animal': ['alligator', 'bee', 'falcon', 'lion',...                    'monkey', 'parrot', 'shark', 'whale', 'zebra']})\n&gt;&gt;&gt; df\n      animal\n0  alligator\n1        bee\n2     falcon\n3       lion\n4     monkey\n5     parrot\n6      shark\n7      whale\n8      zebra\n</code></pre> <p>Viewing the first 5 lines</p> <pre><code>&gt;&gt;&gt; df.head()\n      animal\n0  alligator\n1        bee\n2     falcon\n3       lion\n4     monkey\n</code></pre> <p>Viewing the first <code>n</code> lines (three in this case)</p> <pre><code>&gt;&gt;&gt; df.head(3)\n      animal\n0  alligator\n1        bee\n2     falcon\n</code></pre> <p>For negative values of <code>n</code></p> <pre><code>&gt;&gt;&gt; df.head(-3)\n      animal\n0  alligator\n1        bee\n2     falcon\n3       lion\n4     monkey\n5     parrot\n</code></pre> method &lt;/&gt; <p>Return the last <code>n</code> rows.</p><p>This function returns last <code>n</code> rows from the object based on position. It is useful for quickly verifying data, for example, after sorting or appending rows.</p> <p>For negative values of <code>n</code>, this function returns all rows except the first <code>|n|</code> rows, equivalent to <code>df[|n|:]</code>.</p> <p>If n is larger than the number of rows, this function returns all rows.</p> Parameters <ul> <li><code>n</code> (int, default 5) \u2014 Number of rows to select.</li> </ul> Returns (type of caller) <p>The last <code>n</code> rows of the caller object.</p> See Also <p>DataFrame.head : The first <code>n</code> rows of the caller object.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'animal': ['alligator', 'bee', 'falcon', 'lion',...                    'monkey', 'parrot', 'shark', 'whale', 'zebra']})\n&gt;&gt;&gt; df\n      animal\n0  alligator\n1        bee\n2     falcon\n3       lion\n4     monkey\n5     parrot\n6      shark\n7      whale\n8      zebra\n</code></pre> <p>Viewing the last 5 lines</p> <pre><code>&gt;&gt;&gt; df.tail()\n   animal\n4  monkey\n5  parrot\n6   shark\n7   whale\n8   zebra\n</code></pre> <p>Viewing the last <code>n</code> lines (three in this case)</p> <pre><code>&gt;&gt;&gt; df.tail(3)\n  animal\n6  shark\n7  whale\n8  zebra\n</code></pre> <p>For negative values of <code>n</code></p> <pre><code>&gt;&gt;&gt; df.tail(-3)\n   animal\n3    lion\n4  monkey\n5  parrot\n6   shark\n7   whale\n8   zebra\n</code></pre> method &lt;/&gt; <p>Return a random sample of items from an axis of object.</p><p>You can use <code>random_state</code> for reproducibility.</p> Parameters <ul> <li><code>n</code> (int, optional) \u2014 Number of items from axis to return. Cannot be used with <code>frac</code>.Default = 1 if <code>frac</code> = None. </li> <li><code>frac</code> (float, optional) \u2014 Fraction of axis items to return. Cannot be used with <code>n</code>.</li> <li><code>replace</code> (bool, default False) \u2014 Allow or disallow sampling of the same row more than once.</li> <li><code>weights</code> (str or ndarray-like, optional) \u2014 Default 'None' results in equal probability weighting.If passed a Series, will align with target object on index. Index values in weights not found in sampled object will be ignored and index values in sampled object not in weights will be assigned weights of zero. If called on a DataFrame, will accept the name of a column when axis = 0. Unless weights are a Series, weights must be same length as axis being sampled. If weights do not sum to 1, they will be normalized to sum to 1. Missing values in the weights column will be treated as zero. Infinite values not allowed. </li> <li><code>random_state</code> (int, array-like, BitGenerator, np.random.RandomState, np.random.Generator, optional) \u2014 If int, array-like, or BitGenerator, seed for random number generator.If np.random.RandomState or np.random.Generator, use as given. .. versionchanged:: 1.4.0 <pre><code>np.random.Generator objects now accepted\n</code></pre> </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default None) \u2014 Axis to sample. Accepts axis number or name. Default is stat axisfor given data type. For <code>Series</code> this parameter is unused and defaults to <code>None</code>. </li> <li><code>ignore_index</code> (bool, default False) \u2014 If True, the resulting index will be labeled 0, 1, \u2026, n - 1... versionadded:: 1.3.0 </li> </ul> Returns (Series or DataFrame) <p>A new object of same type as caller containing <code>n</code> items randomlysampled from the caller object.</p> See Also <p>DataFrameGroupBy.sample: Generates random samples from each group of a    DataFrame object. SeriesGroupBy.sample: Generates random samples from each group of a     Series object. numpy.random.choice: Generates a random sample from a given 1-D numpy     array.</p> <p>Notes</p> <p>If <code>frac</code> &gt; 1, <code>replacement</code> should be set to <code>True</code>.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'num_legs': [2, 4, 8, 0],...                    'num_wings': [2, 0, 0, 0],\n...                    'num_specimen_seen': [10, 2, 1, 8]},\n...                   index=['falcon', 'dog', 'spider', 'fish'])\n&gt;&gt;&gt; df\n        num_legs  num_wings  num_specimen_seen\nfalcon         2          2                 10\ndog            4          0                  2\nspider         8          0                  1\nfish           0          0                  8\n</code></pre> <p>Extract 3 random elements from the <code>Series</code> <code>df['num_legs']</code>: Note that we use <code>random_state</code> to ensure the reproducibility of the examples.</p> <pre><code>&gt;&gt;&gt; df['num_legs'].sample(n=3, random_state=1)\nfish      0\nspider    8\nfalcon    2\nName: num_legs, dtype: int64\n</code></pre> <p>A random 50% sample of the <code>DataFrame</code> with replacement:</p> <pre><code>&gt;&gt;&gt; df.sample(frac=0.5, replace=True, random_state=1)\n      num_legs  num_wings  num_specimen_seen\ndog          4          0                  2\nfish         0          0                  8\n</code></pre> <p>An upsample sample of the <code>DataFrame</code> with replacement: Note that <code>replace</code> parameter has to be <code>True</code> for <code>frac</code> parameter &gt; 1.</p> <pre><code>&gt;&gt;&gt; df.sample(frac=2, replace=True, random_state=1)\n        num_legs  num_wings  num_specimen_seen\ndog            4          0                  2\nfish           0          0                  8\nfalcon         2          2                 10\nfalcon         2          2                 10\nfish           0          0                  8\ndog            4          0                  2\nfish           0          0                  8\ndog            4          0                  2\n</code></pre> <p>Using a DataFrame column as weights. Rows with larger value in the <code>num_specimen_seen</code> column are more likely to be sampled.</p> <pre><code>&gt;&gt;&gt; df.sample(n=2, weights='num_specimen_seen', random_state=1)\n        num_legs  num_wings  num_specimen_seen\nfalcon         2          2                 10\nfish           0          0                  8\n</code></pre> method &lt;/&gt; <p>Apply chainable functions that expect Series or DataFrames.</p> Parameters <ul> <li><code>func</code> (function) \u2014 Function to apply to the Series/DataFrame.<code>args</code>, and <code>kwargs</code> are passed into <code>func</code>. Alternatively a <code>(callable, data_keyword)</code> tuple where <code>data_keyword</code> is a string indicating the keyword of <code>callable</code> that expects the Series/DataFrame. </li> <li><code>*args</code> (iterable, optional) \u2014 Positional arguments passed into <code>func</code>.</li> <li><code>**kwargs</code> (mapping, optional) \u2014 A dictionary of keyword arguments passed into <code>func</code>.</li> </ul> See Also <p>DataFrame.apply : Apply a function along input axis of DataFrame.DataFrame.map : Apply a function elementwise on a whole DataFrame. Series.map : Apply a mapping correspondence on a     :class:<code>~pandas.Series</code>.</p> <p>Notes</p> <p>Use <code>.pipe</code> when chaining together functions that expect Series, DataFrames or GroupBy objects.</p> Examples <p>Constructing a income DataFrame from a dictionary.</p><pre><code>&gt;&gt;&gt; data = [[8000, 1000], [9500, np.nan], [5000, 2000]]\n&gt;&gt;&gt; df = pd.DataFrame(data, columns=['Salary', 'Others'])\n&gt;&gt;&gt; df\n   Salary  Others\n0    8000  1000.0\n1    9500     NaN\n2    5000  2000.0\n</code></pre> <p>Functions that perform tax reductions on an income DataFrame.</p> <pre><code>&gt;&gt;&gt; def subtract_federal_tax(df):\n...     return df * 0.9\n&gt;&gt;&gt; def subtract_state_tax(df, rate):\n...     return df * (1 - rate)\n&gt;&gt;&gt; def subtract_national_insurance(df, rate, rate_increase):\n...     new_rate = rate + rate_increase\n...     return df * (1 - new_rate)\n</code></pre> <p>Instead of writing</p> <pre><code>&gt;&gt;&gt; subtract_national_insurance(\n...     subtract_state_tax(subtract_federal_tax(df), rate=0.12),\n...     rate=0.05,\n...     rate_increase=0.02)  # doctest: +SKIP\n</code></pre> <p>You can write</p> <pre><code>&gt;&gt;&gt; (\n...     df.pipe(subtract_federal_tax)\n...     .pipe(subtract_state_tax, rate=0.12)\n...     .pipe(subtract_national_insurance, rate=0.05, rate_increase=0.02)\n... )\n    Salary   Others\n0  5892.48   736.56\n1  6997.32      NaN\n2  3682.80  1473.12\n</code></pre> <p>If you have a function that takes the data as (say) the second argument, pass a tuple indicating which keyword expects the data. For example, suppose <code>national_insurance</code> takes its data as <code>df</code> in the second argument:</p> <pre><code>&gt;&gt;&gt; def subtract_national_insurance(rate, df, rate_increase):\n...     new_rate = rate + rate_increase\n...     return df * (1 - new_rate)\n&gt;&gt;&gt; (\n...     df.pipe(subtract_federal_tax)\n...     .pipe(subtract_state_tax, rate=0.12)\n...     .pipe(\n...         (subtract_national_insurance, 'df'),\n...         rate=0.05,\n...         rate_increase=0.02\n...     )\n... )\n    Salary   Others\n0  5892.48   736.56\n1  6997.32      NaN\n2  3682.80  1473.12\n</code></pre> method &lt;/&gt; <p>Propagate metadata from other to self.</p> Parameters <ul> <li><code>other</code> (the object from which to get the attributes that we are going) \u2014 to propagate</li> <li><code>method</code> (str, optional) \u2014 A passed method name providing context on where <code>__finalize__</code>was called. .. warning:: The value passed as <code>method</code> are not currently considered    stable across pandas releases. </li> </ul> method &lt;/&gt; <p>After regular attribute access, try looking up the nameThis allows simpler access to columns for interactive use.</p> method &lt;/&gt; <p>After regular attribute access, try setting the nameThis allows simpler access to columns for interactive use.</p> method &lt;/&gt; <p>Cast a pandas object to a specified dtype <code>dtype</code>.</p> Parameters <ul> <li><code>dtype</code> (str, data type, Series or Mapping of column name -&gt; data type) \u2014 Use a str, numpy.dtype, pandas.ExtensionDtype or Python type tocast entire pandas object to the same type. Alternatively, use a mapping, e.g. {col: dtype, ...}, where col is a column label and dtype is a numpy.dtype or Python type to cast one or more of the DataFrame's columns to column-specific types. </li> <li><code>copy</code> (bool, default True) \u2014 Return a copy when <code>copy=True</code> (be very careful setting<code>copy=False</code> as changes to values then may propagate to other pandas objects). .. note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> <li><code>errors</code> ({'raise', 'ignore'}, default 'raise') \u2014 Control raising of exceptions on invalid data for provided dtype.<ul> <li><code>raise</code> : allow exceptions to be raised</li> <li><code>ignore</code> : suppress exceptions. On error return original object.</li> </ul> </li> </ul> See Also <p>to_datetime : Convert argument to datetime.to_timedelta : Convert argument to timedelta. to_numeric : Convert argument to a numeric type. numpy.ndarray.astype : Cast a numpy array to a specified type.</p> <p>Notes</p> <p>.. versionchanged:: 2.0.0</p> <pre><code>Using ``astype`` to convert from timezone-naive dtype to\ntimezone-aware dtype will raise an exception.\nUse :meth:`Series.dt.tz_localize` instead.\n</code></pre> Examples <p>Create a DataFrame:</p><pre><code>&gt;&gt;&gt; d = {'col1': [1, 2], 'col2': [3, 4]}\n&gt;&gt;&gt; df = pd.DataFrame(data=d)\n&gt;&gt;&gt; df.dtypes\ncol1    int64\ncol2    int64\ndtype: object\n</code></pre> <p>Cast all columns to int32:</p> <pre><code>&gt;&gt;&gt; df.astype('int32').dtypes\ncol1    int32\ncol2    int32\ndtype: object\n</code></pre> <p>Cast col1 to int32 using a dictionary:</p> <pre><code>&gt;&gt;&gt; df.astype({'col1': 'int32'}).dtypes\ncol1    int32\ncol2    int64\ndtype: object\n</code></pre> <p>Create a series:</p> <pre><code>&gt;&gt;&gt; ser = pd.Series([1, 2], dtype='int32')\n&gt;&gt;&gt; ser\n0    1\n1    2\ndtype: int32\n&gt;&gt;&gt; ser.astype('int64')\n0    1\n1    2\ndtype: int64\n</code></pre> <p>Convert to categorical type:</p> <pre><code>&gt;&gt;&gt; ser.astype('category')\n0    1\n1    2\ndtype: category\nCategories (2, int32): [1, 2]\n</code></pre> <p>Convert to ordered categorical type with custom ordering:</p> <pre><code>&gt;&gt;&gt; from pandas.api.types import CategoricalDtype\n&gt;&gt;&gt; cat_dtype = CategoricalDtype(\n...     categories=[2, 1], ordered=True)\n&gt;&gt;&gt; ser.astype(cat_dtype)\n0    1\n1    2\ndtype: category\nCategories (2, int64): [2 &lt; 1]\n</code></pre> <p>Create a series of dates:</p> <pre><code>&gt;&gt;&gt; ser_date = pd.Series(pd.date_range('20200101', periods=3))\n&gt;&gt;&gt; ser_date\n0   2020-01-01\n1   2020-01-02\n2   2020-01-03\ndtype: datetime64[ns]\n</code></pre> method &lt;/&gt; <p>Make a copy of this object's indices and data.</p><p>When <code>deep=True</code> (default), a new object will be created with a copy of the calling object's data and indices. Modifications to the data or indices of the copy will not be reflected in the original object (see notes below).</p> <p>When <code>deep=False</code>, a new object will be created without copying the calling object's data or index (only references to the data and index are copied). Any changes to the data of the original will be reflected in the shallow copy (and vice versa).</p> <p>.. note::     The <code>deep=False</code> behaviour as described above will change     in pandas 3.0. <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that the \"shallow\" copy     is that is returned with <code>deep=False</code> will still avoid making     an eager copy, but changes to the data of the original will no     longer be reflected in the shallow copy (or vice versa). Instead,     it makes use of a lazy (deferred) copy mechanism that will copy     the data only when any changes to the original or shallow copy is     made.</p> <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> Parameters <ul> <li><code>deep</code> (bool, default True) \u2014 Make a deep copy, including a copy of the data and the indices.With <code>deep=False</code> neither the indices nor the data are copied. </li> </ul> Returns (Series or DataFrame) <p>Object type matches caller.</p> <p>Notes</p> <p>When <code>deep=True</code>, data is copied but actual Python objects will not be copied recursively, only the reference to the object. This is in contrast to <code>copy.deepcopy</code> in the Standard Library, which recursively copies object data (see examples below).</p> <p>While <code>Index</code> objects are copied when <code>deep=True</code>, the underlying numpy array is not copied for performance reasons. Since <code>Index</code> is immutable, the underlying data can be safely shared and a copy is not needed.</p> <p>Since pandas is not thread safe, see the :ref:<code>gotchas &lt;gotchas.thread-safety&gt;</code> when copying in a threading environment.</p> <p>When <code>copy_on_write</code> in pandas config is set to <code>True</code>, the <code>copy_on_write</code> config takes effect even when <code>deep=False</code>. This means that any changes to the copied data would make a new copy of the data upon write (and vice versa). Changes made to either the original or copied variable would not be reflected in the counterpart. See :ref:<code>Copy_on_Write &lt;copy_on_write&gt;</code> for more information.</p> Examples <pre><code>&gt;&gt;&gt; s = pd.Series([1, 2], index=[\"a\", \"b\"])&gt;&gt;&gt; s\na    1\nb    2\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s_copy = s.copy()\n&gt;&gt;&gt; s_copy\na    1\nb    2\ndtype: int64\n</code></pre> <p>Shallow copy versus default (deep) copy:</p> <pre><code>&gt;&gt;&gt; s = pd.Series([1, 2], index=[\"a\", \"b\"])\n&gt;&gt;&gt; deep = s.copy()\n&gt;&gt;&gt; shallow = s.copy(deep=False)\n</code></pre> <p>Shallow copy shares data and index with original.</p> <pre><code>&gt;&gt;&gt; s is shallow\nFalse\n&gt;&gt;&gt; s.values is shallow.values and s.index is shallow.index\nTrue\n</code></pre> <p>Deep copy has own copy of data and index.</p> <pre><code>&gt;&gt;&gt; s is deep\nFalse\n&gt;&gt;&gt; s.values is deep.values or s.index is deep.index\nFalse\n</code></pre> <p>Updates to the data shared by shallow copy and original is reflected in both (NOTE: this will no longer be true for pandas &gt;= 3.0); deep copy remains unchanged.</p> <pre><code>&gt;&gt;&gt; s.iloc[0] = 3\n&gt;&gt;&gt; shallow.iloc[1] = 4\n&gt;&gt;&gt; s\na    3\nb    4\ndtype: int64\n&gt;&gt;&gt; shallow\na    3\nb    4\ndtype: int64\n&gt;&gt;&gt; deep\na    1\nb    2\ndtype: int64\n</code></pre> <p>Note that when copying an object containing Python objects, a deep copy will copy the data, but will not do so recursively. Updating a nested data object will be reflected in the deep copy.</p> <pre><code>&gt;&gt;&gt; s = pd.Series([[1, 2], [3, 4]])\n&gt;&gt;&gt; deep = s.copy()\n&gt;&gt;&gt; s[0][0] = 10\n&gt;&gt;&gt; s\n0    [10, 2]\n1     [3, 4]\ndtype: object\n&gt;&gt;&gt; deep\n0    [10, 2]\n1     [3, 4]\ndtype: object\n</code></pre> <p>Copy-on-Write is set to true, the shallow copy is not modified when the original data is changed:</p> <pre><code>&gt;&gt;&gt; with pd.option_context(\"mode.copy_on_write\", True):\n...     s = pd.Series([1, 2], index=[\"a\", \"b\"])\n...     copy = s.copy(deep=False)\n...     s.iloc[0] = 100\n...     s\na    100\nb      2\ndtype: int64\n&gt;&gt;&gt; copy\na    1\nb    2\ndtype: int64\n</code></pre> method &lt;/&gt; method &lt;/&gt; <p>Attempt to infer better dtypes for object columns.</p><p>Attempts soft conversion of object-dtyped columns, leaving non-object and unconvertible columns unchanged. The inference rules are the same as during normal Series/DataFrame construction.</p> Parameters <ul> <li><code>copy</code> (bool, default True) \u2014 Whether to make a copy for non-object or non-inferable columnsor Series. .. note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> </ul> See Also <p>to_datetime : Convert argument to datetime.to_timedelta : Convert argument to timedelta. to_numeric : Convert argument to numeric type. convert_dtypes : Convert argument to best possible dtype.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [\"a\", 1, 2, 3]})&gt;&gt;&gt; df = df.iloc[1:]\n&gt;&gt;&gt; df\n   A\n1  1\n2  2\n3  3\n</code></pre> <pre><code>&gt;&gt;&gt; df.dtypes\nA    object\ndtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; df.infer_objects().dtypes\nA    int64\ndtype: object\n</code></pre> method &lt;/&gt; <p>Convert columns to the best possible dtypes using dtypes supporting <code>pd.NA</code>.</p> Parameters <ul> <li><code>infer_objects</code> (bool, default True) \u2014 Whether object dtypes should be converted to the best possible types.</li> <li><code>convert_string</code> (bool, default True) \u2014 Whether object dtypes should be converted to <code>StringDtype()</code>.</li> <li><code>convert_integer</code> (bool, default True) \u2014 Whether, if possible, conversion can be done to integer extension types.</li> <li><code>convert_boolean</code> (bool, defaults True) \u2014 Whether object dtypes should be converted to <code>BooleanDtypes()</code>.</li> <li><code>convert_floating</code> (bool, defaults True) \u2014 Whether, if possible, conversion can be done to floating extension types.If <code>convert_integer</code> is also True, preference will be give to integer dtypes if the floats can be faithfully casted to integers. </li> <li><code>dtype_backend</code> ({'numpy_nullable', 'pyarrow'}, default 'numpy_nullable') \u2014 Back-end data type applied to the resultant :class:<code>DataFrame</code>(still experimental). Behaviour is as follows: <ul> <li><code>\"numpy_nullable\"</code>: returns nullable-dtype-backed :class:<code>DataFrame</code>   (default).</li> <li><code>\"pyarrow\"</code>: returns pyarrow-backed nullable :class:<code>ArrowDtype</code>   DataFrame.</li> </ul> .. versionadded:: 2.0 </li> </ul> Returns (Series or DataFrame) <p>Copy of input object with new dtype.</p> See Also <p>infer_objects : Infer dtypes of objects.to_datetime : Convert argument to datetime. to_timedelta : Convert argument to timedelta. to_numeric : Convert argument to a numeric type.</p> <p>Notes</p> <p>By default, <code>convert_dtypes</code> will attempt to convert a Series (or each Series in a DataFrame) to dtypes that support <code>pd.NA</code>. By using the options <code>convert_string</code>, <code>convert_integer</code>, <code>convert_boolean</code> and <code>convert_floating</code>, it is possible to turn off individual conversions to <code>StringDtype</code>, the integer extension types, <code>BooleanDtype</code> or floating extension types, respectively.</p> <p>For object-dtyped columns, if <code>infer_objects</code> is <code>True</code>, use the inference rules as during normal Series/DataFrame construction.  Then, if possible, convert to <code>StringDtype</code>, <code>BooleanDtype</code> or an appropriate integer or floating extension type, otherwise leave as <code>object</code>.</p> <p>If the dtype is integer, convert to an appropriate integer extension type.</p> <p>If the dtype is numeric, and consists of all integers, convert to an appropriate integer extension type. Otherwise, convert to an appropriate floating extension type.</p> <p>In the future, as new dtypes are added that support <code>pd.NA</code>, the results of this method will change to support those new dtypes.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(...     {\n...         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int32\")),\n...         \"b\": pd.Series([\"x\", \"y\", \"z\"], dtype=np.dtype(\"O\")),\n...         \"c\": pd.Series([True, False, np.nan], dtype=np.dtype(\"O\")),\n...         \"d\": pd.Series([\"h\", \"i\", np.nan], dtype=np.dtype(\"O\")),\n...         \"e\": pd.Series([10, np.nan, 20], dtype=np.dtype(\"float\")),\n...         \"f\": pd.Series([np.nan, 100.5, 200], dtype=np.dtype(\"float\")),\n...     }\n... )\n</code></pre> <p>Start with a DataFrame with default dtypes.</p> <pre><code>&gt;&gt;&gt; df\n   a  b      c    d     e      f\n0  1  x   True    h  10.0    NaN\n1  2  y  False    i   NaN  100.5\n2  3  z    NaN  NaN  20.0  200.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.dtypes\na      int32\nb     object\nc     object\nd     object\ne    float64\nf    float64\ndtype: object\n</code></pre> <p>Convert the DataFrame to use best possible dtypes.</p> <pre><code>&gt;&gt;&gt; dfn = df.convert_dtypes()\n&gt;&gt;&gt; dfn\n   a  b      c     d     e      f\n0  1  x   True     h    10   &lt;NA&gt;\n1  2  y  False     i  &lt;NA&gt;  100.5\n2  3  z   &lt;NA&gt;  &lt;NA&gt;    20  200.0\n</code></pre> <pre><code>&gt;&gt;&gt; dfn.dtypes\na             Int32\nb    string[python]\nc           boolean\nd    string[python]\ne             Int64\nf           Float64\ndtype: object\n</code></pre> <p>Start with a Series of strings and missing data represented by <code>np.nan</code>.</p> <pre><code>&gt;&gt;&gt; s = pd.Series([\"a\", \"b\", np.nan])\n&gt;&gt;&gt; s\n0      a\n1      b\n2    NaN\ndtype: object\n</code></pre> <p>Obtain a Series with dtype <code>StringDtype</code>.</p> <pre><code>&gt;&gt;&gt; s.convert_dtypes()\n0       a\n1       b\n2    &lt;NA&gt;\ndtype: string\n</code></pre> method &lt;/&gt; <p>Fill NA/NaN values using the specified method.</p> Parameters <ul> <li><code>value</code> (scalar, dict, Series, or DataFrame) \u2014 Value to use to fill holes (e.g. 0), alternately adict/Series/DataFrame of values specifying which value to use for each index (for a Series) or column (for a DataFrame).  Values not in the dict/Series/DataFrame will not be filled. This value cannot be a list. </li> <li><code>method</code> ({'backfill', 'bfill', 'ffill', None}, default None) \u2014 Method to use for filling holes in reindexed Series:<ul> <li>ffill: propagate last valid observation forward to next valid.</li> <li>backfill / bfill: use next valid observation to fill gap.</li> </ul> .. deprecated:: 2.1.0     Use ffill or bfill instead. </li> <li><code>axis</code> ({0 or 'index'} for Series, {0 or 'index', 1 or 'columns'} for DataFrame) \u2014 Axis along which to fill missing values. For <code>Series</code>this parameter is unused and defaults to 0. </li> <li><code>inplace</code> (bool, default False) \u2014 If True, fill in-place. Note: this will modify anyother views on this object (e.g., a no-copy slice for a column in a DataFrame). </li> <li><code>limit</code> (int, default None) \u2014 If method is specified, this is the maximum number of consecutiveNaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled. Must be greater than 0 if not None. </li> <li><code>downcast</code> (dict, default is None) \u2014 A dict of item-&gt;dtype of what to downcast if possible,or the string 'infer' which will try to downcast to an appropriate equal type (e.g. float64 to int64 if possible). .. deprecated:: 2.2.0 </li> </ul> Returns (Series/DataFrame or None) <p>Object with missing values filled or None if <code>inplace=True</code>.</p> See Also <p>ffill : Fill values by propagating the last valid observation to next valid.bfill : Fill values by using the next valid observation to fill the gap. interpolate : Fill NaN values using interpolation. reindex : Conform object to new index. asfreq : Convert TimeSeries to specified frequency.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[np.nan, 2, np.nan, 0],...                    [3, 4, np.nan, 1],\n...                    [np.nan, np.nan, np.nan, np.nan],\n...                    [np.nan, 3, np.nan, 4]],\n...                   columns=list(\"ABCD\"))\n&gt;&gt;&gt; df\n     A    B   C    D\n0  NaN  2.0 NaN  0.0\n1  3.0  4.0 NaN  1.0\n2  NaN  NaN NaN  NaN\n3  NaN  3.0 NaN  4.0\n</code></pre> <p>Replace all NaN elements with 0s.</p> <pre><code>&gt;&gt;&gt; df.fillna(0)\n     A    B    C    D\n0  0.0  2.0  0.0  0.0\n1  3.0  4.0  0.0  1.0\n2  0.0  0.0  0.0  0.0\n3  0.0  3.0  0.0  4.0\n</code></pre> <p>Replace all NaN elements in column 'A', 'B', 'C', and 'D', with 0, 1, 2, and 3 respectively.</p> <pre><code>&gt;&gt;&gt; values = {\"A\": 0, \"B\": 1, \"C\": 2, \"D\": 3}\n&gt;&gt;&gt; df.fillna(value=values)\n     A    B    C    D\n0  0.0  2.0  2.0  0.0\n1  3.0  4.0  2.0  1.0\n2  0.0  1.0  2.0  3.0\n3  0.0  3.0  2.0  4.0\n</code></pre> <p>Only replace the first NaN element.</p> <pre><code>&gt;&gt;&gt; df.fillna(value=values, limit=1)\n     A    B    C    D\n0  0.0  2.0  2.0  0.0\n1  3.0  4.0  NaN  1.0\n2  NaN  1.0  NaN  3.0\n3  NaN  3.0  NaN  4.0\n</code></pre> <p>When filling using a DataFrame, replacement happens along the same column names and same indices</p> <pre><code>&gt;&gt;&gt; df2 = pd.DataFrame(np.zeros((4, 4)), columns=list(\"ABCE\"))\n&gt;&gt;&gt; df.fillna(df2)\n     A    B    C    D\n0  0.0  2.0  0.0  0.0\n1  3.0  4.0  0.0  1.0\n2  0.0  0.0  0.0  NaN\n3  0.0  3.0  0.0  4.0\n</code></pre> <p>Note that column D is not affected since it is not present in df2.</p> method &lt;/&gt; <p>Fill NA/NaN values by propagating the last valid observation to next valid.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index'} for Series, {0 or 'index', 1 or 'columns'} for DataFrame) \u2014 Axis along which to fill missing values. For <code>Series</code>this parameter is unused and defaults to 0. </li> <li><code>inplace</code> (bool, default False) \u2014 If True, fill in-place. Note: this will modify anyother views on this object (e.g., a no-copy slice for a column in a DataFrame). </li> <li><code>limit</code> (int, default None) \u2014 If method is specified, this is the maximum number of consecutiveNaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled. Must be greater than 0 if not None. </li> <li><code>limit_area</code> ({`None`, 'inside', 'outside'}, default None) \u2014 If limit is specified, consecutive NaNs will be filled with thisrestriction. <ul> <li><code>None</code>: No fill restriction.</li> <li>'inside': Only fill NaNs surrounded by valid values   (interpolate).</li> <li>'outside': Only fill NaNs outside valid values (extrapolate).</li> </ul> .. versionadded:: 2.2.0 </li> <li><code>downcast</code> (dict, default is None) \u2014 A dict of item-&gt;dtype of what to downcast if possible,or the string 'infer' which will try to downcast to an appropriate equal type (e.g. float64 to int64 if possible). .. deprecated:: 2.2.0 </li> </ul> Returns (Series/DataFrame or None) <p>Object with missing values filled or None if <code>inplace=True</code>.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[np.nan, 2, np.nan, 0],...                    [3, 4, np.nan, 1],\n...                    [np.nan, np.nan, np.nan, np.nan],\n...                    [np.nan, 3, np.nan, 4]],\n...                   columns=list(\"ABCD\"))\n&gt;&gt;&gt; df\n     A    B   C    D\n0  NaN  2.0 NaN  0.0\n1  3.0  4.0 NaN  1.0\n2  NaN  NaN NaN  NaN\n3  NaN  3.0 NaN  4.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.ffill()\n     A    B   C    D\n0  NaN  2.0 NaN  0.0\n1  3.0  4.0 NaN  1.0\n2  3.0  4.0 NaN  1.0\n3  3.0  3.0 NaN  4.0\n</code></pre> <pre><code>&gt;&gt;&gt; ser = pd.Series([1, np.nan, 2, 3])\n&gt;&gt;&gt; ser.ffill()\n0   1.0\n1   1.0\n2   2.0\n3   3.0\ndtype: float64\n</code></pre> method &lt;/&gt; <p>Fill NA/NaN values by propagating the last valid observation to next valid.</p><p>.. deprecated:: 2.0</p> <pre><code>Series/DataFrame.pad is deprecated. Use Series/DataFrame.ffill instead.\n</code></pre> Returns (Series/DataFrame or None) <p>Object with missing values filled or None if <code>inplace=True</code>.</p> Examples <p>Please see examples for :meth:<code>DataFrame.ffill</code> or :meth:<code>Series.ffill</code>.</p> method &lt;/&gt; <p>Fill NA/NaN values by using the next valid observation to fill the gap.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index'} for Series, {0 or 'index', 1 or 'columns'} for DataFrame) \u2014 Axis along which to fill missing values. For <code>Series</code>this parameter is unused and defaults to 0. </li> <li><code>inplace</code> (bool, default False) \u2014 If True, fill in-place. Note: this will modify anyother views on this object (e.g., a no-copy slice for a column in a DataFrame). </li> <li><code>limit</code> (int, default None) \u2014 If method is specified, this is the maximum number of consecutiveNaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled. Must be greater than 0 if not None. </li> <li><code>limit_area</code> ({`None`, 'inside', 'outside'}, default None) \u2014 If limit is specified, consecutive NaNs will be filled with thisrestriction. <ul> <li><code>None</code>: No fill restriction.</li> <li>'inside': Only fill NaNs surrounded by valid values   (interpolate).</li> <li>'outside': Only fill NaNs outside valid values (extrapolate).</li> </ul> .. versionadded:: 2.2.0 </li> <li><code>downcast</code> (dict, default is None) \u2014 A dict of item-&gt;dtype of what to downcast if possible,or the string 'infer' which will try to downcast to an appropriate equal type (e.g. float64 to int64 if possible). .. deprecated:: 2.2.0 </li> </ul> Returns (Series/DataFrame or None) <p>Object with missing values filled or None if <code>inplace=True</code>.</p> Examples <p>For Series:</p><pre><code>&gt;&gt;&gt; s = pd.Series([1, None, None, 2])\n&gt;&gt;&gt; s.bfill()\n0    1.0\n1    2.0\n2    2.0\n3    2.0\ndtype: float64\n&gt;&gt;&gt; s.bfill(limit=1)\n0    1.0\n1    NaN\n2    2.0\n3    2.0\ndtype: float64\n</code></pre> <p>With DataFrame:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, None, None, 4], 'B': [None, 5, None, 7]})\n&gt;&gt;&gt; df\n      A     B\n0   1.0   NaN\n1   NaN   5.0\n2   NaN   NaN\n3   4.0   7.0\n&gt;&gt;&gt; df.bfill()\n      A     B\n0   1.0   5.0\n1   4.0   5.0\n2   4.0   7.0\n3   4.0   7.0\n&gt;&gt;&gt; df.bfill(limit=1)\n      A     B\n0   1.0   5.0\n1   NaN   5.0\n2   4.0   7.0\n3   4.0   7.0\n</code></pre> method &lt;/&gt; <p>Fill NA/NaN values by using the next valid observation to fill the gap.</p><p>.. deprecated:: 2.0</p> <pre><code>Series/DataFrame.backfill is deprecated. Use Series/DataFrame.bfill instead.\n</code></pre> Returns (Series/DataFrame or None) <p>Object with missing values filled or None if <code>inplace=True</code>.</p> Examples <p>Please see examples for :meth:<code>DataFrame.bfill</code> or :meth:<code>Series.bfill</code>.</p> method &lt;/&gt; <p>Replace values given in <code>to_replace</code> with <code>value</code>.</p><p>Values of the Series/DataFrame are replaced with other values dynamically. This differs from updating with <code>.loc</code> or <code>.iloc</code>, which require you to specify a location to update with some value.</p> Parameters <ul> <li><code>to_replace</code> (str, regex, list, dict, Series, int, float, or None) \u2014 How to find the values that will be replaced.<ul> <li> numeric, str or regex: <ul> <li>numeric: numeric values equal to <code>to_replace</code> will be   replaced with <code>value</code></li> <li>str: string exactly matching <code>to_replace</code> will be replaced   with <code>value</code></li> <li>regex: regexs matching <code>to_replace</code> will be replaced with   <code>value</code></li> </ul> </li> <li> list of str, regex, or numeric: <ul> <li>First, if <code>to_replace</code> and <code>value</code> are both lists, they   must be the same length.</li> <li>Second, if <code>regex=True</code> then all of the strings in both   lists will be interpreted as regexs otherwise they will match   directly. This doesn't matter much for <code>value</code> since there   are only a few possible substitution regexes you can use.</li> <li>str, regex and numeric rules apply as above.</li> </ul> </li> <li> dict: <ul> <li>Dicts can be used to specify different replacement values   for different existing values. For example,   <code>{'a': 'b', 'y': 'z'}</code> replaces the value 'a' with 'b' and   'y' with 'z'. To use a dict in this way, the optional <code>value</code>   parameter should not be given.</li> <li>For a DataFrame a dict can specify that different values   should be replaced in different columns. For example,   <code>{'a': 1, 'b': 'z'}</code> looks for the value 1 in column 'a'   and the value 'z' in column 'b' and replaces these values   with whatever is specified in <code>value</code>. The <code>value</code> parameter   should not be <code>None</code> in this case. You can treat this as a   special case of passing two lists except that you are   specifying the column to search in.</li> <li>For a DataFrame nested dictionaries, e.g.,   <code>{'a': {'b': np.nan}}</code>, are read as follows: look in column   'a' for the value 'b' and replace it with NaN. The optional <code>value</code>   parameter should not be specified to use a nested dict in this   way. You can nest regular expressions as well. Note that   column names (the top-level dictionary keys in a nested   dictionary) cannot be regular expressions.</li> </ul> </li> <li> None: <ul> <li>This means that the <code>regex</code> argument must be a string,   compiled regular expression, or list, dict, ndarray or   Series of such elements. If <code>value</code> is also <code>None</code> then   this must be a nested dictionary or Series.</li> </ul> </li> </ul> See the examples section for examples of each of these. </li> <li><code>value</code> (scalar, dict, list, str, regex, default None) \u2014 Value to replace any values matching <code>to_replace</code> with.For a DataFrame a dict of values can be used to specify which value to use for each column (columns not in the dict will not be filled). Regular expressions, strings and lists or dicts of such objects are also allowed. </li> <li><code>inplace</code> (bool, default False) \u2014 If True, performs operation inplace and returns None.</li> <li><code>limit</code> (int, default None) \u2014 Maximum size gap to forward or backward fill... deprecated:: 2.1.0 </li> <li><code>regex</code> (bool or same types as `to_replace`, default False) \u2014 Whether to interpret <code>to_replace</code> and/or <code>value</code> as regularexpressions. Alternatively, this could be a regular expression or a list, dict, or array of regular expressions in which case <code>to_replace</code> must be <code>None</code>. </li> <li><code>method</code> ({'pad', 'ffill', 'bfill'}) \u2014 The method to use when for replacement, when <code>to_replace</code> is ascalar, list or tuple and <code>value</code> is <code>None</code>. .. deprecated:: 2.1.0 </li> </ul> Returns (Series/DataFrame) <p>Object after replacement.</p> Raises <ul> <li><code>AssertionError</code> \u2014 <ul><li>If <code>regex</code> is not a <code>bool</code> and <code>to_replace</code> is not   <code>None</code>.</li> </ul> </li> <li><code>TypeError</code> \u2014 <ul><li>If <code>to_replace</code> is not a scalar, array-like, <code>dict</code>, or <code>None</code></li> <li>If <code>to_replace</code> is a <code>dict</code> and <code>value</code> is not a <code>list</code>,   <code>dict</code>, <code>ndarray</code>, or <code>Series</code></li> <li>If <code>to_replace</code> is <code>None</code> and <code>regex</code> is not compilable   into a regular expression or is a list, dict, ndarray, or   Series.</li> <li>When replacing multiple <code>bool</code> or <code>datetime64</code> objects and   the arguments to <code>to_replace</code> does not match the type of the   value being replaced</li> </ul> </li> <li><code>ValueError</code> \u2014 <ul><li>If a <code>list</code> or an <code>ndarray</code> is passed to <code>to_replace</code> and   <code>value</code> but they are not the same length.</li> </ul> </li> </ul> See Also <p>Series.fillna : Fill NA values.DataFrame.fillna : Fill NA values. Series.where : Replace values based on boolean condition. DataFrame.where : Replace values based on boolean condition. DataFrame.map: Apply a function to a Dataframe elementwise. Series.map: Map values of Series according to an input mapping or function. Series.str.replace : Simple string replacement.</p> <p>Notes</p> <ul> <li>Regex substitution is performed under the hood with <code>re.sub</code>. The   rules for substitution for <code>re.sub</code> are the same.</li> <li>Regular expressions will only substitute on strings, meaning you   cannot provide, for example, a regular expression matching floating   point numbers and expect the columns in your frame that have a   numeric dtype to be matched. However, if those floating point   numbers are strings, then you can do this.</li> <li>This method has a lot of options. You are encouraged to experiment   and play with this method to gain intuition about how it works.</li> <li>When dict is used as the <code>to_replace</code> value, it is like   key(s) in the dict are the to_replace part and   value(s) in the dict are the value parameter.</li> </ul> Examples <p>*</p><p>) ) 5 2 3 4 5 4</p> <p>, , ) ) C a b c d e</p> <p>*</p> <p>) C a b c d e</p> <p>) C a b c d e</p> <p>) 3 3 3 4 5 4</p> <p>*</p> <p>) C a b c d e</p> <p>) C a b c d e</p> <p>) C a b c d e</p> <p>*</p> <p>, ) ) B c w z</p> <p>) B c r z</p> <p>) B c w z</p> <p>) B c w z</p> <p>) B c w z</p> <p>d s :</p> <p>)</p> <p>e . o :</p> <p>) 0 e e b e t</p> <p>t e 0 .</p> <p>) 0 0 0 b b t</p> <p>0 .</p> <p>l :</p> <p>) 0 e e b e t</p> <p>0 .</p> <p>, .</p> <p>, , )</p> <p>) C e e h i j</p> <p>y .</p> <p>) C f g e e e</p> method &lt;/&gt; <p>Fill NaN values using an interpolation method.</p><p>Please note that only <code>method='linear'</code> is supported for DataFrame/Series with a MultiIndex.</p> Parameters <ul> <li><code>method</code> (str, default 'linear') \u2014 Interpolation technique to use. One of:<ul> <li>'linear': Ignore the index and treat the values as equally   spaced. This is the only method supported on MultiIndexes.</li> <li>'time': Works on daily and higher resolution data to interpolate   given length of interval.</li> <li>'index', 'values': use the actual numerical values of the index.</li> <li>'pad': Fill in NaNs using existing values.</li> <li>'nearest', 'zero', 'slinear', 'quadratic', 'cubic',   'barycentric', 'polynomial': Passed to   <code>scipy.interpolate.interp1d</code>, whereas 'spline' is passed to   <code>scipy.interpolate.UnivariateSpline</code>. These methods use the numerical   values of the index.  Both 'polynomial' and 'spline' require that   you also specify an <code>order</code> (int), e.g.   <code>df.interpolate(method='polynomial', order=5)</code>. Note that,   <code>slinear</code> method in Pandas refers to the Scipy first order <code>spline</code>   instead of Pandas first order <code>spline</code>.</li> <li>'krogh', 'piecewise_polynomial', 'spline', 'pchip', 'akima',   'cubicspline': Wrappers around the SciPy interpolation methods of   similar names. See <code>Notes</code>.</li> <li>'from_derivatives': Refers to   <code>scipy.interpolate.BPoly.from_derivatives</code>.</li> </ul> </li> <li><code>axis</code> ({{0 or 'index', 1 or 'columns', None}}, default None) \u2014 Axis to interpolate along. For <code>Series</code> this parameter is unusedand defaults to 0. </li> <li><code>limit</code> (int, optional) \u2014 Maximum number of consecutive NaNs to fill. Must be greater than0. </li> <li><code>inplace</code> (bool, default False) \u2014 Update the data in place if possible.</li> <li><code>limit_direction</code> ({{'forward', 'backward', 'both'}}, Optional) \u2014 Consecutive NaNs will be filled in this direction.If limit is specified:     * If 'method' is 'pad' or 'ffill', 'limit_direction' must be 'forward'.     * If 'method' is 'backfill' or 'bfill', 'limit_direction' must be       'backwards'. If 'limit' is not specified:     * If 'method' is 'backfill' or 'bfill', the default is 'backward'     * else the default is 'forward' raises ValueError if <code>limit_direction</code> is 'forward' or 'both' and     method is 'backfill' or 'bfill'. raises ValueError if <code>limit_direction</code> is 'backward' or 'both' and     method is 'pad' or 'ffill'. </li> <li><code>limit_area</code> ({{`None`, 'inside', 'outside'}}, default None) \u2014 If limit is specified, consecutive NaNs will be filled with thisrestriction. <ul> <li><code>None</code>: No fill restriction.</li> <li>'inside': Only fill NaNs surrounded by valid values   (interpolate).</li> <li>'outside': Only fill NaNs outside valid values (extrapolate).</li> </ul> </li> <li><code>downcast</code> (optional, 'infer' or None, defaults to None) \u2014 Downcast dtypes if possible... deprecated:: 2.1.0 </li> </ul> Returns (Series or DataFrame or None) <p>Returns the same object type as the caller, interpolated atsome or all <code>NaN</code> values or None if <code>inplace=True</code>.</p> See Also <p>fillna : Fill missing values using different methods.scipy.interpolate.Akima1DInterpolator : Piecewise cubic polynomials     (Akima interpolator). scipy.interpolate.BPoly.from_derivatives : Piecewise polynomial in the     Bernstein basis. scipy.interpolate.interp1d : Interpolate a 1-D function. scipy.interpolate.KroghInterpolator : Interpolate polynomial (Krogh     interpolator). scipy.interpolate.PchipInterpolator : PCHIP 1-d monotonic cubic     interpolation. scipy.interpolate.CubicSpline : Cubic spline data interpolator.</p> <p>Notes</p> <p>The 'krogh', 'piecewise_polynomial', 'spline', 'pchip' and 'akima' methods are wrappers around the respective SciPy implementations of similar names. These use the actual numerical values of the index. For more information on their behavior, see the <code>SciPy documentation &lt;https://docs.scipy.org/doc/scipy/reference/interpolate.html#univariate-interpolation&gt;</code>__.</p> Examples <p>Filling in <code>NaN</code> in a :class:<code>~pandas.Series</code> via linearinterpolation.</p> <pre><code>&gt;&gt;&gt; s = pd.Series([0, 1, np.nan, 3])\n&gt;&gt;&gt; s\n0    0.0\n1    1.0\n2    NaN\n3    3.0\ndtype: float64\n&gt;&gt;&gt; s.interpolate()\n0    0.0\n1    1.0\n2    2.0\n3    3.0\ndtype: float64\n</code></pre> <p>Filling in <code>NaN</code> in a Series via polynomial interpolation or splines: Both 'polynomial' and 'spline' methods require that you also specify an <code>order</code> (int).</p> <pre><code>&gt;&gt;&gt; s = pd.Series([0, 2, np.nan, 8])\n&gt;&gt;&gt; s.interpolate(method='polynomial', order=2)\n0    0.000000\n1    2.000000\n2    4.666667\n3    8.000000\ndtype: float64\n</code></pre> <p>Fill the DataFrame forward (that is, going down) along each column using linear interpolation.</p> <p>Note how the last entry in column 'a' is interpolated differently, because there is no entry after it to use for interpolation. Note how the first entry in column 'b' remains <code>NaN</code>, because there is no entry before it to use for interpolation.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame([(0.0, np.nan, -1.0, 1.0),\n...                    (np.nan, 2.0, np.nan, np.nan),\n...                    (2.0, 3.0, np.nan, 9.0),\n...                    (np.nan, 4.0, -4.0, 16.0)],\n...                   columns=list('abcd'))\n&gt;&gt;&gt; df\n     a    b    c     d\n0  0.0  NaN -1.0   1.0\n1  NaN  2.0  NaN   NaN\n2  2.0  3.0  NaN   9.0\n3  NaN  4.0 -4.0  16.0\n&gt;&gt;&gt; df.interpolate(method='linear', limit_direction='forward', axis=0)\n     a    b    c     d\n0  0.0  NaN -1.0   1.0\n1  1.0  2.0 -2.0   5.0\n2  2.0  3.0 -3.0   9.0\n3  2.0  4.0 -4.0  16.0\n</code></pre> <p>Using polynomial interpolation.</p> <pre><code>&gt;&gt;&gt; df['d'].interpolate(method='polynomial', order=2)\n0     1.0\n1     4.0\n2     9.0\n3    16.0\nName: d, dtype: float64\n</code></pre> method &lt;/&gt; <p>Return the last row(s) without any NaNs before <code>where</code>.</p><p>The last row (for each element in <code>where</code>, if list) without any NaN is taken. In case of a :class:<code>~pandas.DataFrame</code>, the last row without NaN considering only the subset of columns (if not <code>None</code>)</p> <p>If there is no good value, NaN is returned for a Series or a Series of NaN values for a DataFrame</p> Parameters <ul> <li><code>where</code> (date or array-like of dates) \u2014 Date(s) before which the last row(s) are returned.</li> <li><code>subset</code> (str or array-like of str, default `None`) \u2014 For DataFrame, if not <code>None</code>, only use these columns tocheck for NaNs. </li> </ul> Returns (scalar, Series, or DataFrame) <p>:</p><p>r , r n e</p> See Also <p>merge_asof : Perform an asof merge. Similar to left join.</p> <p>Notes</p> <p>Dates are assumed to be sorted. Raises if this is not the case.</p> Examples <p>A Series and a scalar <code>where</code>.</p><pre><code>&gt;&gt;&gt; s = pd.Series([1, 2, np.nan, 4], index=[10, 20, 30, 40])\n&gt;&gt;&gt; s\n10    1.0\n20    2.0\n30    NaN\n40    4.0\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; s.asof(20)\n2.0\n</code></pre> <p>For a sequence <code>where</code>, a Series is returned. The first value is NaN, because the first element of <code>where</code> is before the first index value.</p> <pre><code>&gt;&gt;&gt; s.asof([5, 20])\n5     NaN\n20    2.0\ndtype: float64\n</code></pre> <p>Missing values are not considered. The following is <code>2.0</code>, not NaN, even though NaN is at the index location for <code>30</code>.</p> <pre><code>&gt;&gt;&gt; s.asof(30)\n2.0\n</code></pre> <p>Take all columns into consideration</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'a': [10., 20., 30., 40., 50.],\n...                    'b': [None, None, None, None, 500]},\n...                   index=pd.DatetimeIndex(['2018-02-27 09:01:00',\n...                                           '2018-02-27 09:02:00',\n...                                           '2018-02-27 09:03:00',\n...                                           '2018-02-27 09:04:00',\n...                                           '2018-02-27 09:05:00']))\n&gt;&gt;&gt; df.asof(pd.DatetimeIndex(['2018-02-27 09:03:30',\n...                           '2018-02-27 09:04:30']))\n                      a   b\n2018-02-27 09:03:30 NaN NaN\n2018-02-27 09:04:30 NaN NaN\n</code></pre> <p>Take a single column into consideration</p> <pre><code>&gt;&gt;&gt; df.asof(pd.DatetimeIndex(['2018-02-27 09:03:30',\n...                           '2018-02-27 09:04:30']),\n...         subset=['a'])\n                        a   b\n2018-02-27 09:03:30  30.0 NaN\n2018-02-27 09:04:30  40.0 NaN\n</code></pre> method &lt;/&gt; <p>Trim values at input threshold(s).</p><p>Assigns values outside boundary to boundary values. Thresholds can be singular values or array like, and in the latter case the clipping is performed element-wise in the specified axis.</p> Parameters <ul> <li><code>lower</code> (float or array-like, default None) \u2014 Minimum threshold value. All values below thisthreshold will be set to it. A missing threshold (e.g <code>NA</code>) will not clip the value. </li> <li><code>upper</code> (float or array-like, default None) \u2014 Maximum threshold value. All values above thisthreshold will be set to it. A missing threshold (e.g <code>NA</code>) will not clip the value. </li> <li><code>axis</code> ({{0 or 'index', 1 or 'columns', None}}, default None) \u2014 Align object with lower and upper along the given axis.For <code>Series</code> this parameter is unused and defaults to <code>None</code>. </li> <li><code>inplace</code> (bool, default False) \u2014 Whether to perform the operation in place on the data.</li> </ul> Returns (Series or DataFrame or None) <p>Same type as calling object with the values outside theclip boundaries replaced or None if <code>inplace=True</code>.</p> See Also <p>Series.clip : Trim values at input threshold in series.DataFrame.clip : Trim values at input threshold in dataframe. numpy.clip : Clip (limit) the values in an array.</p> Examples <pre><code>&gt;&gt;&gt; data = {'col_0': [9, -3, 0, -1, 5], 'col_1': [-2, -7, 6, 8, -5]}&gt;&gt;&gt; df = pd.DataFrame(data)\n&gt;&gt;&gt; df\n   col_0  col_1\n0      9     -2\n1     -3     -7\n2      0      6\n3     -1      8\n4      5     -5\n</code></pre> <p>Clips per column using lower and upper thresholds:</p> <pre><code>&gt;&gt;&gt; df.clip(-4, 6)\n   col_0  col_1\n0      6     -2\n1     -3     -4\n2      0      6\n3     -1      6\n4      5     -4\n</code></pre> <p>Clips using specific lower and upper thresholds per column:</p> <pre><code>&gt;&gt;&gt; df.clip([-2, -1], [4, 5])\n    col_0  col_1\n0      4     -1\n1     -2     -1\n2      0      5\n3     -1      5\n4      4     -1\n</code></pre> <p>Clips using specific lower and upper thresholds per column element:</p> <pre><code>&gt;&gt;&gt; t = pd.Series([2, -4, -1, 6, 3])\n&gt;&gt;&gt; t\n0    2\n1   -4\n2   -1\n3    6\n4    3\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.clip(t, t + 4, axis=0)\n   col_0  col_1\n0      6      2\n1     -3     -4\n2      0      3\n3      6      8\n4      5      3\n</code></pre> <p>Clips using specific lower threshold per column element, with missing values:</p> <pre><code>&gt;&gt;&gt; t = pd.Series([2, -4, np.nan, 6, 3])\n&gt;&gt;&gt; t\n0    2.0\n1   -4.0\n2    NaN\n3    6.0\n4    3.0\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; df.clip(t, axis=0)\ncol_0  col_1\n0      9      2\n1     -3     -4\n2      0      6\n3      6      8\n4      5      3\n</code></pre> method &lt;/&gt; <p>Convert time series to specified frequency.</p><p>Returns the original data conformed to a new index with the specified frequency.</p> <p>If the index of this Series/DataFrame is a :class:<code>~pandas.PeriodIndex</code>, the new index is the result of transforming the original index with :meth:<code>PeriodIndex.asfreq &lt;pandas.PeriodIndex.asfreq&gt;</code> (so the original index will map one-to-one to the new index).</p> <p>Otherwise, the new index will be equivalent to <code>pd.date_range(start, end, freq=freq)</code> where <code>start</code> and <code>end</code> are, respectively, the first and last entries in the original index (see :func:<code>pandas.date_range</code>). The values corresponding to any timesteps in the new index which were not present in the original index will be null (<code>NaN</code>), unless a method for filling such unknowns is provided (see the <code>method</code> parameter below).</p> <p>The :meth:<code>resample</code> method is more appropriate if an operation on each group of timesteps (such as an aggregate) is necessary to represent the data at the new frequency.</p> Parameters <ul> <li><code>freq</code> (DateOffset or str) \u2014 Frequency DateOffset or string.</li> <li><code>method</code> ({'backfill'/'bfill', 'pad'/'ffill'}, default None) \u2014 Method to use for filling holes in reindexed Series (note thisdoes not fill NaNs that already were present): <ul> <li>'pad' / 'ffill': propagate last valid observation forward to next   valid</li> <li>'backfill' / 'bfill': use NEXT valid observation to fill.</li> </ul> </li> <li><code>how</code> ({'start', 'end'}, default end) \u2014 For PeriodIndex only (see PeriodIndex.asfreq).</li> <li><code>normalize</code> (bool, default False) \u2014 Whether to reset output index to midnight.</li> <li><code>fill_value</code> (scalar, optional) \u2014 Value to use for missing values, applied during upsampling (notethis does not fill NaNs that already were present). </li> </ul> Returns (Series/DataFrame) <p>Series/DataFrame object reindexed to the specified frequency.</p> See Also <p>reindex : Conform DataFrame to new index with optional filling logic.</p> <p>Notes</p> <p>To learn more about the frequency strings, please see <code>this link &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;</code>__.</p> Examples <p>Start by creating a series with 4 one minute timestamps.</p><pre><code>&gt;&gt;&gt; index = pd.date_range('1/1/2000', periods=4, freq='min')\n&gt;&gt;&gt; series = pd.Series([0.0, None, 2.0, 3.0], index=index)\n&gt;&gt;&gt; df = pd.DataFrame({'s': series})\n&gt;&gt;&gt; df\n                       s\n2000-01-01 00:00:00    0.0\n2000-01-01 00:01:00    NaN\n2000-01-01 00:02:00    2.0\n2000-01-01 00:03:00    3.0\n</code></pre> <p>Upsample the series into 30 second bins.</p> <pre><code>&gt;&gt;&gt; df.asfreq(freq='30s')\n                       s\n2000-01-01 00:00:00    0.0\n2000-01-01 00:00:30    NaN\n2000-01-01 00:01:00    NaN\n2000-01-01 00:01:30    NaN\n2000-01-01 00:02:00    2.0\n2000-01-01 00:02:30    NaN\n2000-01-01 00:03:00    3.0\n</code></pre> <p>Upsample again, providing a <code>fill value</code>.</p> <pre><code>&gt;&gt;&gt; df.asfreq(freq='30s', fill_value=9.0)\n                       s\n2000-01-01 00:00:00    0.0\n2000-01-01 00:00:30    9.0\n2000-01-01 00:01:00    NaN\n2000-01-01 00:01:30    9.0\n2000-01-01 00:02:00    2.0\n2000-01-01 00:02:30    9.0\n2000-01-01 00:03:00    3.0\n</code></pre> <p>Upsample again, providing a <code>method</code>.</p> <pre><code>&gt;&gt;&gt; df.asfreq(freq='30s', method='bfill')\n                       s\n2000-01-01 00:00:00    0.0\n2000-01-01 00:00:30    NaN\n2000-01-01 00:01:00    NaN\n2000-01-01 00:01:30    2.0\n2000-01-01 00:02:00    2.0\n2000-01-01 00:02:30    3.0\n2000-01-01 00:03:00    3.0\n</code></pre> method &lt;/&gt; <p>Select values at particular time of day (e.g., 9:30AM).</p> Parameters <ul> <li><code>time</code> (datetime.time or str) \u2014 The values to select.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 For <code>Series</code> this parameter is unused and defaults to 0.</li> </ul> Raises <ul> <li><code>TypeError</code> \u2014 If the index is not  a :class:<code>DatetimeIndex</code></li> </ul> See Also <p>between_time : Select values between particular times of the day.first : Select initial periods of time series based on a date offset. last : Select final periods of time series based on a date offset. DatetimeIndex.indexer_at_time : Get just the index locations for     values at particular time of the day.</p> Examples <pre><code>&gt;&gt;&gt; i = pd.date_range('2018-04-09', periods=4, freq='12h')&gt;&gt;&gt; ts = pd.DataFrame({'A': [1, 2, 3, 4]}, index=i)\n&gt;&gt;&gt; ts\n                     A\n2018-04-09 00:00:00  1\n2018-04-09 12:00:00  2\n2018-04-10 00:00:00  3\n2018-04-10 12:00:00  4\n</code></pre> <pre><code>&gt;&gt;&gt; ts.at_time('12:00')\n                     A\n2018-04-09 12:00:00  2\n2018-04-10 12:00:00  4\n</code></pre> method &lt;/&gt; <p>Select values between particular times of the day (e.g., 9:00-9:30 AM).</p><p>By setting <code>start_time</code> to be later than <code>end_time</code>, you can get the times that are not between the two times.</p> Parameters <ul> <li><code>start_time</code> (datetime.time or str) \u2014 Initial time as a time filter limit.</li> <li><code>end_time</code> (datetime.time or str) \u2014 End time as a time filter limit.</li> <li><code>inclusive</code> ({\"both\", \"neither\", \"left\", \"right\"}, default \"both\") \u2014 Include boundaries; whether to set each bound as closed or open.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Determine range time on index or columns value.For <code>Series</code> this parameter is unused and defaults to 0. </li> </ul> Returns (Series or DataFrame) <p>Data from the original object filtered to the specified dates range.</p> Raises <ul> <li><code>TypeError</code> \u2014 If the index is not  a :class:<code>DatetimeIndex</code></li> </ul> See Also <p>at_time : Select values at a particular time of the day.first : Select initial periods of time series based on a date offset. last : Select final periods of time series based on a date offset. DatetimeIndex.indexer_between_time : Get just the index locations for     values between particular times of the day.</p> Examples <pre><code>&gt;&gt;&gt; i = pd.date_range('2018-04-09', periods=4, freq='1D20min')&gt;&gt;&gt; ts = pd.DataFrame({'A': [1, 2, 3, 4]}, index=i)\n&gt;&gt;&gt; ts\n                     A\n2018-04-09 00:00:00  1\n2018-04-10 00:20:00  2\n2018-04-11 00:40:00  3\n2018-04-12 01:00:00  4\n</code></pre> <pre><code>&gt;&gt;&gt; ts.between_time('0:15', '0:45')\n                     A\n2018-04-10 00:20:00  2\n2018-04-11 00:40:00  3\n</code></pre> <p>You get the times that are not between two times by setting <code>start_time</code> later than <code>end_time</code>:</p> <pre><code>&gt;&gt;&gt; ts.between_time('0:45', '0:15')\n                     A\n2018-04-09 00:00:00  1\n2018-04-12 01:00:00  4\n</code></pre> method &lt;/&gt; <p>Resample time-series data.</p><p>Convenience method for frequency conversion and resampling of time series. The object must have a datetime-like index (<code>DatetimeIndex</code>, <code>PeriodIndex</code>, or <code>TimedeltaIndex</code>), or the caller must pass the label of a datetime-like series/index to the <code>on</code>/<code>level</code> keyword parameter.</p> Parameters <ul> <li><code>rule</code> (DateOffset, Timedelta or str) \u2014 The offset string or object representing target conversion.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Which axis to use for up- or down-sampling. For <code>Series</code> this parameteris unused and defaults to 0. Must be <code>DatetimeIndex</code>, <code>TimedeltaIndex</code> or <code>PeriodIndex</code>. .. deprecated:: 2.0.0     Use frame.T.resample(...) instead. </li> <li><code>closed</code> ({'right', 'left'}, default None) \u2014 Which side of bin interval is closed. The default is 'left'for all frequency offsets except for 'ME', 'YE', 'QE', 'BME', 'BA', 'BQE', and 'W' which all have a default of 'right'. </li> <li><code>label</code> ({'right', 'left'}, default None) \u2014 Which bin edge label to label bucket with. The default is 'left'for all frequency offsets except for 'ME', 'YE', 'QE', 'BME', 'BA', 'BQE', and 'W' which all have a default of 'right'. </li> <li><code>convention</code> ({'start', 'end', 's', 'e'}, default 'start') \u2014 For <code>PeriodIndex</code> only, controls whether to use the start orend of <code>rule</code>. </li> <li><code>kind</code> ({'timestamp', 'period'}, optional, default None) \u2014 Pass 'timestamp' to convert the resulting index to a<code>DateTimeIndex</code> or 'period' to convert it to a <code>PeriodIndex</code>. By default the input representation is retained. .. deprecated:: 2.2.0     Convert index to desired type explicitly instead. </li> <li><code>on</code> (str, optional) \u2014 For a DataFrame, column to use instead of index for resampling.Column must be datetime-like. </li> <li><code>level</code> (str or int, optional) \u2014 For a MultiIndex, level (name or number) to use forresampling. <code>level</code> must be datetime-like. </li> <li><code>origin</code> (Timestamp or str, default 'start_day') \u2014 The timestamp on which to adjust the grouping. The timezone of originmust match the timezone of the index. If string, must be one of the following: <ul> <li>'epoch': <code>origin</code> is 1970-01-01</li> <li>'start': <code>origin</code> is the first value of the timeseries</li> <li> 'start_day': <code>origin</code> is the first day at midnight of the timeseries </li> <li> 'end': <code>origin</code> is the last value of the timeseries </li> <li>'end_day': <code>origin</code> is the ceiling midnight of the last day</li> </ul> .. versionadded:: 1.3.0 .. note:: <pre><code>Only takes effect for Tick-frequencies (i.e. fixed frequencies like\ndays, hours, and minutes, rather than months or quarters).\n</code></pre> </li> <li><code>offset</code> (Timedelta or str, default is None) \u2014 An offset timedelta added to the origin.</li> <li><code>group_keys</code> (bool, default False) \u2014 Whether to include the group keys in the result index when using<code>.apply()</code> on the resampled object. .. versionadded:: 1.5.0 <pre><code>Not specifying ``group_keys`` will retain values-dependent behavior\nfrom pandas 1.4 and earlier (see :ref:`pandas 1.5.0 Release notes\n&lt;whatsnew_150.enhancements.resample_group_keys&gt;` for examples).\n</code></pre> .. versionchanged:: 2.0.0 <pre><code>``group_keys`` now defaults to ``False``.\n</code></pre> </li> </ul> Returns (pandas.api.typing.Resampler) <p>:class:<code>~pandas.core.Resampler</code> object.</p> See Also <p>Series.resample : Resample a Series.DataFrame.resample : Resample a DataFrame. groupby : Group Series/DataFrame by mapping, function, label, or list of labels. asfreq : Reindex a Series/DataFrame with the given frequency without grouping.</p> <p>Notes</p> <p>See the <code>user guide &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#resampling&gt;</code>__ for more.</p> <p>To learn more about the offset strings, please see <code>this link &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#dateoffset-objects&gt;</code>__.</p> Examples <p>Start by creating a series with 9 one minute timestamps.</p><pre><code>&gt;&gt;&gt; index = pd.date_range('1/1/2000', periods=9, freq='min')\n&gt;&gt;&gt; series = pd.Series(range(9), index=index)\n&gt;&gt;&gt; series\n2000-01-01 00:00:00    0\n2000-01-01 00:01:00    1\n2000-01-01 00:02:00    2\n2000-01-01 00:03:00    3\n2000-01-01 00:04:00    4\n2000-01-01 00:05:00    5\n2000-01-01 00:06:00    6\n2000-01-01 00:07:00    7\n2000-01-01 00:08:00    8\nFreq: min, dtype: int64\n</code></pre> <p>Downsample the series into 3 minute bins and sum the values of the timestamps falling into a bin.</p> <pre><code>&gt;&gt;&gt; series.resample('3min').sum()\n2000-01-01 00:00:00     3\n2000-01-01 00:03:00    12\n2000-01-01 00:06:00    21\nFreq: 3min, dtype: int64\n</code></pre> <p>Downsample the series into 3 minute bins as above, but label each bin using the right edge instead of the left. Please note that the value in the bucket used as the label is not included in the bucket, which it labels. For example, in the original series the bucket <code>2000-01-01 00:03:00</code> contains the value 3, but the summed value in the resampled bucket with the label <code>2000-01-01 00:03:00</code> does not include 3 (if it did, the summed value would be 6, not 3).</p> <pre><code>&gt;&gt;&gt; series.resample('3min', label='right').sum()\n2000-01-01 00:03:00     3\n2000-01-01 00:06:00    12\n2000-01-01 00:09:00    21\nFreq: 3min, dtype: int64\n</code></pre> <p>To include this value close the right side of the bin interval, as shown below.</p> <pre><code>&gt;&gt;&gt; series.resample('3min', label='right', closed='right').sum()\n2000-01-01 00:00:00     0\n2000-01-01 00:03:00     6\n2000-01-01 00:06:00    15\n2000-01-01 00:09:00    15\nFreq: 3min, dtype: int64\n</code></pre> <p>Upsample the series into 30 second bins.</p> <pre><code>&gt;&gt;&gt; series.resample('30s').asfreq()[0:5]   # Select first 5 rows\n2000-01-01 00:00:00   0.0\n2000-01-01 00:00:30   NaN\n2000-01-01 00:01:00   1.0\n2000-01-01 00:01:30   NaN\n2000-01-01 00:02:00   2.0\nFreq: 30s, dtype: float64\n</code></pre> <p>Upsample the series into 30 second bins and fill the <code>NaN</code> values using the <code>ffill</code> method.</p> <pre><code>&gt;&gt;&gt; series.resample('30s').ffill()[0:5]\n2000-01-01 00:00:00    0\n2000-01-01 00:00:30    0\n2000-01-01 00:01:00    1\n2000-01-01 00:01:30    1\n2000-01-01 00:02:00    2\nFreq: 30s, dtype: int64\n</code></pre> <p>Upsample the series into 30 second bins and fill the <code>NaN</code> values using the <code>bfill</code> method.</p> <pre><code>&gt;&gt;&gt; series.resample('30s').bfill()[0:5]\n2000-01-01 00:00:00    0\n2000-01-01 00:00:30    1\n2000-01-01 00:01:00    1\n2000-01-01 00:01:30    2\n2000-01-01 00:02:00    2\nFreq: 30s, dtype: int64\n</code></pre> <p>Pass a custom function via <code>apply</code></p> <pre><code>&gt;&gt;&gt; def custom_resampler(arraylike):\n...     return np.sum(arraylike) + 5\n...\n&gt;&gt;&gt; series.resample('3min').apply(custom_resampler)\n2000-01-01 00:00:00     8\n2000-01-01 00:03:00    17\n2000-01-01 00:06:00    26\nFreq: 3min, dtype: int64\n</code></pre> <p>For a Series with a PeriodIndex, the keyword <code>convention</code> can be used to control whether to use the start or end of <code>rule</code>.</p> <p>Resample a year by quarter using 'start' <code>convention</code>. Values are assigned to the first quarter of the period.</p> <pre><code>&gt;&gt;&gt; s = pd.Series(\n...     [1, 2], index=pd.period_range(\"2012-01-01\", freq=\"Y\", periods=2)\n... )\n&gt;&gt;&gt; s\n2012    1\n2013    2\nFreq: Y-DEC, dtype: int64\n&gt;&gt;&gt; s.resample(\"Q\", convention=\"start\").asfreq()\n2012Q1    1.0\n2012Q2    NaN\n2012Q3    NaN\n2012Q4    NaN\n2013Q1    2.0\n2013Q2    NaN\n2013Q3    NaN\n2013Q4    NaN\nFreq: Q-DEC, dtype: float64\n</code></pre> <p>Resample quarters by month using 'end' <code>convention</code>. Values are assigned to the last month of the period.</p> <pre><code>&gt;&gt;&gt; q = pd.Series(\n...     [1, 2, 3, 4], index=pd.period_range(\"2018-01-01\", freq=\"Q\", periods=4)\n... )\n&gt;&gt;&gt; q\n2018Q1    1\n2018Q2    2\n2018Q3    3\n2018Q4    4\nFreq: Q-DEC, dtype: int64\n&gt;&gt;&gt; q.resample(\"M\", convention=\"end\").asfreq()\n2018-03    1.0\n2018-04    NaN\n2018-05    NaN\n2018-06    2.0\n2018-07    NaN\n2018-08    NaN\n2018-09    3.0\n2018-10    NaN\n2018-11    NaN\n2018-12    4.0\nFreq: M, dtype: float64\n</code></pre> <p>For DataFrame objects, the keyword <code>on</code> can be used to specify the column instead of the index for resampling.</p> <pre><code>&gt;&gt;&gt; d = {'price': [10, 11, 9, 13, 14, 18, 17, 19],\n...      'volume': [50, 60, 40, 100, 50, 100, 40, 50]}\n&gt;&gt;&gt; df = pd.DataFrame(d)\n&gt;&gt;&gt; df['week_starting'] = pd.date_range('01/01/2018',\n...                                     periods=8,\n...                                     freq='W')\n&gt;&gt;&gt; df\n   price  volume week_starting\n0     10      50    2018-01-07\n1     11      60    2018-01-14\n2      9      40    2018-01-21\n3     13     100    2018-01-28\n4     14      50    2018-02-04\n5     18     100    2018-02-11\n6     17      40    2018-02-18\n7     19      50    2018-02-25\n&gt;&gt;&gt; df.resample('ME', on='week_starting').mean()\n               price  volume\nweek_starting\n2018-01-31     10.75    62.5\n2018-02-28     17.00    60.0\n</code></pre> <p>For a DataFrame with MultiIndex, the keyword <code>level</code> can be used to specify on which level the resampling needs to take place.</p> <pre><code>&gt;&gt;&gt; days = pd.date_range('1/1/2000', periods=4, freq='D')\n&gt;&gt;&gt; d2 = {'price': [10, 11, 9, 13, 14, 18, 17, 19],\n...       'volume': [50, 60, 40, 100, 50, 100, 40, 50]}\n&gt;&gt;&gt; df2 = pd.DataFrame(\n...     d2,\n...     index=pd.MultiIndex.from_product(\n...         [days, ['morning', 'afternoon']]\n...     )\n... )\n&gt;&gt;&gt; df2\n                      price  volume\n2000-01-01 morning       10      50\n           afternoon     11      60\n2000-01-02 morning        9      40\n           afternoon     13     100\n2000-01-03 morning       14      50\n           afternoon     18     100\n2000-01-04 morning       17      40\n           afternoon     19      50\n&gt;&gt;&gt; df2.resample('D', level=0).sum()\n            price  volume\n2000-01-01     21     110\n2000-01-02     22     140\n2000-01-03     32     150\n2000-01-04     36      90\n</code></pre> <p>If you want to adjust the start of the bins based on a fixed timestamp:</p> <pre><code>&gt;&gt;&gt; start, end = '2000-10-01 23:30:00', '2000-10-02 00:30:00'\n&gt;&gt;&gt; rng = pd.date_range(start, end, freq='7min')\n&gt;&gt;&gt; ts = pd.Series(np.arange(len(rng)) * 3, index=rng)\n&gt;&gt;&gt; ts\n2000-10-01 23:30:00     0\n2000-10-01 23:37:00     3\n2000-10-01 23:44:00     6\n2000-10-01 23:51:00     9\n2000-10-01 23:58:00    12\n2000-10-02 00:05:00    15\n2000-10-02 00:12:00    18\n2000-10-02 00:19:00    21\n2000-10-02 00:26:00    24\nFreq: 7min, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; ts.resample('17min').sum()\n2000-10-01 23:14:00     0\n2000-10-01 23:31:00     9\n2000-10-01 23:48:00    21\n2000-10-02 00:05:00    54\n2000-10-02 00:22:00    24\nFreq: 17min, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; ts.resample('17min', origin='epoch').sum()\n2000-10-01 23:18:00     0\n2000-10-01 23:35:00    18\n2000-10-01 23:52:00    27\n2000-10-02 00:09:00    39\n2000-10-02 00:26:00    24\nFreq: 17min, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; ts.resample('17min', origin='2000-01-01').sum()\n2000-10-01 23:24:00     3\n2000-10-01 23:41:00    15\n2000-10-01 23:58:00    45\n2000-10-02 00:15:00    45\nFreq: 17min, dtype: int64\n</code></pre> <p>If you want to adjust the start of the bins with an <code>offset</code> Timedelta, the two following lines are equivalent:</p> <pre><code>&gt;&gt;&gt; ts.resample('17min', origin='start').sum()\n2000-10-01 23:30:00     9\n2000-10-01 23:47:00    21\n2000-10-02 00:04:00    54\n2000-10-02 00:21:00    24\nFreq: 17min, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; ts.resample('17min', offset='23h30min').sum()\n2000-10-01 23:30:00     9\n2000-10-01 23:47:00    21\n2000-10-02 00:04:00    54\n2000-10-02 00:21:00    24\nFreq: 17min, dtype: int64\n</code></pre> <p>If you want to take the largest Timestamp as the end of the bins:</p> <pre><code>&gt;&gt;&gt; ts.resample('17min', origin='end').sum()\n2000-10-01 23:35:00     0\n2000-10-01 23:52:00    18\n2000-10-02 00:09:00    27\n2000-10-02 00:26:00    63\nFreq: 17min, dtype: int64\n</code></pre> <p>In contrast with the <code>start_day</code>, you can use <code>end_day</code> to take the ceiling midnight of the largest Timestamp as the end of the bins and drop the bins not containing data:</p> <pre><code>&gt;&gt;&gt; ts.resample('17min', origin='end_day').sum()\n2000-10-01 23:38:00     3\n2000-10-01 23:55:00    15\n2000-10-02 00:12:00    45\n2000-10-02 00:29:00    45\nFreq: 17min, dtype: int64\n</code></pre> method &lt;/&gt; <p>Select initial periods of time series data based on a date offset.</p><p>.. deprecated:: 2.1     :meth:<code>.first</code> is deprecated and will be removed in a future version.     Please create a mask and filter using <code>.loc</code> instead.</p> <p>For a DataFrame with a sorted DatetimeIndex, this function can select the first few rows based on a date offset.</p> Parameters <ul> <li><code>offset</code> (str, DateOffset or dateutil.relativedelta) \u2014 The offset length of the data that will be selected. For instance,'1ME' will display all the rows having their index within the first month. </li> </ul> Returns (Series or DataFrame) <p>A subset of the caller.</p> Raises <ul> <li><code>TypeError</code> \u2014 If the index is not  a :class:<code>DatetimeIndex</code></li> </ul> See Also <p>last : Select final periods of time series based on a date offset.at_time : Select values at a particular time of the day. between_time : Select values between particular times of the day.</p> Examples <pre><code>&gt;&gt;&gt; i = pd.date_range('2018-04-09', periods=4, freq='2D')&gt;&gt;&gt; ts = pd.DataFrame({'A': [1, 2, 3, 4]}, index=i)\n&gt;&gt;&gt; ts\n            A\n2018-04-09  1\n2018-04-11  2\n2018-04-13  3\n2018-04-15  4\n</code></pre> <p>Get the rows for the first 3 days:</p> <pre><code>&gt;&gt;&gt; ts.first('3D')\n            A\n2018-04-09  1\n2018-04-11  2\n</code></pre> <p>Notice the data for 3 first calendar days were returned, not the first 3 days observed in the dataset, and therefore data for 2018-04-13 was not returned.</p> method &lt;/&gt; <p>Select final periods of time series data based on a date offset.</p><p>.. deprecated:: 2.1     :meth:<code>.last</code> is deprecated and will be removed in a future version.     Please create a mask and filter using <code>.loc</code> instead.</p> <p>For a DataFrame with a sorted DatetimeIndex, this function selects the last few rows based on a date offset.</p> Parameters <ul> <li><code>offset</code> (str, DateOffset, dateutil.relativedelta) \u2014 The offset length of the data that will be selected. For instance,'3D' will display all the rows having their index within the last 3 days. </li> </ul> Returns (Series or DataFrame) <p>A subset of the caller.</p> Raises <ul> <li><code>TypeError</code> \u2014 If the index is not  a :class:<code>DatetimeIndex</code></li> </ul> See Also <p>first : Select initial periods of time series based on a date offset.at_time : Select values at a particular time of the day. between_time : Select values between particular times of the day.</p> <p>Notes</p> <p>.. deprecated:: 2.1.0     Please create a mask and filter using <code>.loc</code> instead</p> Examples <pre><code>&gt;&gt;&gt; i = pd.date_range('2018-04-09', periods=4, freq='2D')&gt;&gt;&gt; ts = pd.DataFrame({'A': [1, 2, 3, 4]}, index=i)\n&gt;&gt;&gt; ts\n            A\n2018-04-09  1\n2018-04-11  2\n2018-04-13  3\n2018-04-15  4\n</code></pre> <p>Get the rows for the last 3 days:</p> <pre><code>&gt;&gt;&gt; ts.last('3D')  # doctest: +SKIP\n            A\n2018-04-13  3\n2018-04-15  4\n</code></pre> <p>Notice the data for 3 last calendar days were returned, not the last 3 observed days in the dataset, and therefore data for 2018-04-11 was not returned.</p> method &lt;/&gt; <p>Compute numerical data ranks (1 through n) along axis.</p><p>By default, equal values are assigned a rank that is the average of the ranks of those values.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Index to direct ranking.For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>method</code> ({'average', 'min', 'max', 'first', 'dense'}, default 'average') \u2014 How to rank the group of records that have the same value (i.e. ties):<ul> <li>average: average rank of the group</li> <li>min: lowest rank in the group</li> <li>max: highest rank in the group</li> <li>first: ranks assigned in order they appear in the array</li> <li>dense: like 'min', but rank always increases by 1 between groups.</li> </ul> </li> <li><code>numeric_only</code> (bool, default False) \u2014 For DataFrame objects, rank only numeric columns if set to True... versionchanged:: 2.0.0     The default value of <code>numeric_only</code> is now <code>False</code>. </li> <li><code>na_option</code> ({'keep', 'top', 'bottom'}, default 'keep') \u2014 How to rank NaN values:<ul> <li>keep: assign NaN rank to NaN values</li> <li>top: assign lowest rank to NaN values</li> <li>bottom: assign highest rank to NaN values</li> </ul> </li> <li><code>ascending</code> (bool, default True) \u2014 Whether or not the elements should be ranked in ascending order.</li> <li><code>pct</code> (bool, default False) \u2014 Whether or not to display the returned rankings in percentileform. </li> </ul> Returns (same type as caller) <p>Return a Series or DataFrame with data ranks as values.</p> See Also <p>core.groupby.DataFrameGroupBy.rank : Rank of values within each group.core.groupby.SeriesGroupBy.rank : Rank of values within each group.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(data={'Animal': ['cat', 'penguin', 'dog',...                                    'spider', 'snake'],\n...                         'Number_legs': [4, 2, 4, 8, np.nan]})\n&gt;&gt;&gt; df\n    Animal  Number_legs\n0      cat          4.0\n1  penguin          2.0\n2      dog          4.0\n3   spider          8.0\n4    snake          NaN\n</code></pre> <p>Ties are assigned the mean of the ranks (by default) for the group.</p> <pre><code>&gt;&gt;&gt; s = pd.Series(range(5), index=list(\"abcde\"))\n&gt;&gt;&gt; s[\"d\"] = s[\"b\"]\n&gt;&gt;&gt; s.rank()\na    1.0\nb    2.5\nc    4.0\nd    2.5\ne    5.0\ndtype: float64\n</code></pre> <p>The following example shows how the method behaves with the above parameters:</p> <ul> <li>default_rank: this is the default behaviour obtained without using   any parameter.</li> <li>max_rank: setting <code>method = 'max'</code> the records that have the   same values are ranked using the highest rank (e.g.: since 'cat'   and 'dog' are both in the 2nd and 3rd position, rank 3 is assigned.)</li> <li>NA_bottom: choosing <code>na_option = 'bottom'</code>, if there are records   with NaN values they are placed at the bottom of the ranking.</li> <li>pct_rank: when setting <code>pct = True</code>, the ranking is expressed as   percentile rank.</li> </ul> <pre><code>&gt;&gt;&gt; df['default_rank'] = df['Number_legs'].rank()\n&gt;&gt;&gt; df['max_rank'] = df['Number_legs'].rank(method='max')\n&gt;&gt;&gt; df['NA_bottom'] = df['Number_legs'].rank(na_option='bottom')\n&gt;&gt;&gt; df['pct_rank'] = df['Number_legs'].rank(pct=True)\n&gt;&gt;&gt; df\n    Animal  Number_legs  default_rank  max_rank  NA_bottom  pct_rank\n0      cat          4.0           2.5       3.0        2.5     0.625\n1  penguin          2.0           1.0       1.0        1.0     0.250\n2      dog          4.0           2.5       3.0        2.5     0.625\n3   spider          8.0           4.0       4.0        4.0     1.000\n4    snake          NaN           NaN       NaN        5.0       NaN\n</code></pre> method &lt;/&gt; <p>Align two objects on their axes with the specified join method.</p><p>Join method is specified for each axis Index.</p> Parameters <ul> <li><code>join</code> ({'outer', 'inner', 'left', 'right'}, default 'outer') \u2014 Type of alignment to be performed.<ul> <li>left: use only keys from left frame, preserve key order.</li> <li>right: use only keys from right frame, preserve key order.</li> <li>outer: use union of keys from both frames, sort keys lexicographically.</li> <li>inner: use intersection of keys from both frames,   preserve the order of the left keys.</li> </ul> </li> <li><code>axis</code> (allowed axis of the other object, default None) \u2014 Align on index (0), columns (1), or both (None).</li> <li><code>level</code> (int or level name, default None) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>copy</code> (bool, default True) \u2014 Always returns new objects. If copy=False and no reindexing isrequired then original objects are returned. .. note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> <li><code>fill_value</code> (scalar, default np.nan) \u2014 Value to use for missing values. Defaults to NaN, but can be any\"compatible\" value. </li> <li><code>method</code> ({'backfill', 'bfill', 'pad', 'ffill', None}, default None) \u2014 Method to use for filling holes in reindexed Series:<ul> <li>pad / ffill: propagate last valid observation forward to next valid.</li> <li>backfill / bfill: use NEXT valid observation to fill gap.</li> </ul> .. deprecated:: 2.1 </li> <li><code>limit</code> (int, default None) \u2014 If method is specified, this is the maximum number of consecutiveNaN values to forward/backward fill. In other words, if there is a gap with more than this number of consecutive NaNs, it will only be partially filled. If method is not specified, this is the maximum number of entries along the entire axis where NaNs will be filled. Must be greater than 0 if not None. .. deprecated:: 2.1 </li> <li><code>fill_axis</code> ({0 or 'index'} for Series, {0 or 'index', 1 or 'columns'} for DataFrame, default 0) \u2014 Filling axis, method and limit... deprecated:: 2.1 </li> <li><code>broadcast_axis</code> ({0 or 'index'} for Series, {0 or 'index', 1 or 'columns'} for DataFrame, default None) \u2014 Broadcast values along this axis, if aligning two objects ofdifferent dimensions. .. deprecated:: 2.1 </li> </ul> Returns (tuple of (Series/DataFrame, type of other)) <p>Aligned objects.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(...     [[1, 2, 3, 4], [6, 7, 8, 9]], columns=[\"D\", \"B\", \"E\", \"A\"], index=[1, 2]\n... )\n&gt;&gt;&gt; other = pd.DataFrame(\n...     [[10, 20, 30, 40], [60, 70, 80, 90], [600, 700, 800, 900]],\n...     columns=[\"A\", \"B\", \"C\", \"D\"],\n...     index=[2, 3, 4],\n... )\n&gt;&gt;&gt; df\n   D  B  E  A\n1  1  2  3  4\n2  6  7  8  9\n&gt;&gt;&gt; other\n    A    B    C    D\n2   10   20   30   40\n3   60   70   80   90\n4  600  700  800  900\n</code></pre> <p>Align on columns:</p> <pre><code>&gt;&gt;&gt; left, right = df.align(other, join=\"outer\", axis=1)\n&gt;&gt;&gt; left\n   A  B   C  D  E\n1  4  2 NaN  1  3\n2  9  7 NaN  6  8\n&gt;&gt;&gt; right\n    A    B    C    D   E\n2   10   20   30   40 NaN\n3   60   70   80   90 NaN\n4  600  700  800  900 NaN\n</code></pre> <p>We can also align on the index:</p> <pre><code>&gt;&gt;&gt; left, right = df.align(other, join=\"outer\", axis=0)\n&gt;&gt;&gt; left\n    D    B    E    A\n1  1.0  2.0  3.0  4.0\n2  6.0  7.0  8.0  9.0\n3  NaN  NaN  NaN  NaN\n4  NaN  NaN  NaN  NaN\n&gt;&gt;&gt; right\n    A      B      C      D\n1    NaN    NaN    NaN    NaN\n2   10.0   20.0   30.0   40.0\n3   60.0   70.0   80.0   90.0\n4  600.0  700.0  800.0  900.0\n</code></pre> <p>Finally, the default <code>axis=None</code> will align on both index and columns:</p> <pre><code>&gt;&gt;&gt; left, right = df.align(other, join=\"outer\", axis=None)\n&gt;&gt;&gt; left\n     A    B   C    D    E\n1  4.0  2.0 NaN  1.0  3.0\n2  9.0  7.0 NaN  6.0  8.0\n3  NaN  NaN NaN  NaN  NaN\n4  NaN  NaN NaN  NaN  NaN\n&gt;&gt;&gt; right\n       A      B      C      D   E\n1    NaN    NaN    NaN    NaN NaN\n2   10.0   20.0   30.0   40.0 NaN\n3   60.0   70.0   80.0   90.0 NaN\n4  600.0  700.0  800.0  900.0 NaN\n</code></pre> method &lt;/&gt; <p>Replace values where the condition is False.</p> Parameters <ul> <li><code>cond</code> (bool Series/DataFrame, array-like, or callable) \u2014 Where <code>cond</code> is True, keep the original value. WhereFalse, replace with corresponding value from <code>other</code>. If <code>cond</code> is callable, it is computed on the Series/DataFrame and should return boolean Series/DataFrame or array. The callable must not change input Series/DataFrame (though pandas doesn't check it). </li> <li><code>other</code> (scalar, Series/DataFrame, or callable) \u2014 Entries where <code>cond</code> is False are replaced withcorresponding value from <code>other</code>. If other is callable, it is computed on the Series/DataFrame and should return scalar or Series/DataFrame. The callable must not change input Series/DataFrame (though pandas doesn't check it). If not specified, entries will be filled with the corresponding NULL value (<code>np.nan</code> for numpy dtypes, <code>pd.NA</code> for extension dtypes). </li> <li><code>inplace</code> (bool, default False) \u2014 Whether to perform the operation in place on the data.</li> <li><code>axis</code> (int, default None) \u2014 Alignment axis if needed. For <code>Series</code> this parameter isunused and defaults to 0. </li> <li><code>level</code> (int, default None) \u2014 Alignment level if needed.</li> </ul> See Also <p>:func:<code>DataFrame.mask</code> : Return an object of same shape as    self.</p> <p>Notes</p> <p>The where method is an application of the if-then idiom. For each element in the calling DataFrame, if <code>cond</code> is <code>True</code> the element is used; otherwise the corresponding element from the DataFrame <code>other</code> is used. If the axis of <code>other</code> does not align with axis of <code>cond</code> Series/DataFrame, the misaligned index positions will be filled with False.</p> <p>The signature for :func:<code>DataFrame.where</code> differs from :func:<code>numpy.where</code>. Roughly <code>df1.where(m, df2)</code> is equivalent to <code>np.where(m, df1, df2)</code>.</p> <p>For further details and examples see the <code>where</code> documentation in :ref:<code>indexing &lt;indexing.where_mask&gt;</code>.</p> <p>The dtype of the object takes precedence. The fill value is casted to the object's dtype, if this can be done losslessly.</p> Examples <pre><code>&gt;&gt;&gt; s = pd.Series(range(5))&gt;&gt;&gt; s.where(s &gt; 0)\n0    NaN\n1    1.0\n2    2.0\n3    3.0\n4    4.0\ndtype: float64\n&gt;&gt;&gt; s.mask(s &gt; 0)\n0    0.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; s = pd.Series(range(5))\n&gt;&gt;&gt; t = pd.Series([True, False])\n&gt;&gt;&gt; s.where(t, 99)\n0     0\n1    99\n2    99\n3    99\n4    99\ndtype: int64\n&gt;&gt;&gt; s.mask(t, 99)\n0    99\n1     1\n2    99\n3    99\n4    99\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s.where(s &gt; 1, 10)\n0    10\n1    10\n2    2\n3    3\n4    4\ndtype: int64\n&gt;&gt;&gt; s.mask(s &gt; 1, 10)\n0     0\n1     1\n2    10\n3    10\n4    10\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=['A', 'B'])\n&gt;&gt;&gt; df\n   A  B\n0  0  1\n1  2  3\n2  4  5\n3  6  7\n4  8  9\n&gt;&gt;&gt; m = df % 3 == 0\n&gt;&gt;&gt; df.where(m, -df)\n   A  B\n0  0 -1\n1 -2  3\n2 -4 -5\n3  6 -7\n4 -8  9\n&gt;&gt;&gt; df.where(m, -df) == np.where(m, df, -df)\n      A     B\n0  True  True\n1  True  True\n2  True  True\n3  True  True\n4  True  True\n&gt;&gt;&gt; df.where(m, -df) == df.mask(~m, -df)\n      A     B\n0  True  True\n1  True  True\n2  True  True\n3  True  True\n4  True  True\n</code></pre> method &lt;/&gt; <p>Replace values where the condition is True.</p> Parameters <ul> <li><code>cond</code> (bool Series/DataFrame, array-like, or callable) \u2014 Where <code>cond</code> is False, keep the original value. WhereTrue, replace with corresponding value from <code>other</code>. If <code>cond</code> is callable, it is computed on the Series/DataFrame and should return boolean Series/DataFrame or array. The callable must not change input Series/DataFrame (though pandas doesn't check it). </li> <li><code>other</code> (scalar, Series/DataFrame, or callable) \u2014 Entries where <code>cond</code> is True are replaced withcorresponding value from <code>other</code>. If other is callable, it is computed on the Series/DataFrame and should return scalar or Series/DataFrame. The callable must not change input Series/DataFrame (though pandas doesn't check it). If not specified, entries will be filled with the corresponding NULL value (<code>np.nan</code> for numpy dtypes, <code>pd.NA</code> for extension dtypes). </li> <li><code>inplace</code> (bool, default False) \u2014 Whether to perform the operation in place on the data.</li> <li><code>axis</code> (int, default None) \u2014 Alignment axis if needed. For <code>Series</code> this parameter isunused and defaults to 0. </li> <li><code>level</code> (int, default None) \u2014 Alignment level if needed.</li> </ul> See Also <p>:func:<code>DataFrame.where</code> : Return an object of same shape as    self.</p> <p>Notes</p> <p>The mask method is an application of the if-then idiom. For each element in the calling DataFrame, if <code>cond</code> is <code>False</code> the element is used; otherwise the corresponding element from the DataFrame <code>other</code> is used. If the axis of <code>other</code> does not align with axis of <code>cond</code> Series/DataFrame, the misaligned index positions will be filled with True.</p> <p>The signature for :func:<code>DataFrame.where</code> differs from :func:<code>numpy.where</code>. Roughly <code>df1.where(m, df2)</code> is equivalent to <code>np.where(m, df1, df2)</code>.</p> <p>For further details and examples see the <code>mask</code> documentation in :ref:<code>indexing &lt;indexing.where_mask&gt;</code>.</p> <p>The dtype of the object takes precedence. The fill value is casted to the object's dtype, if this can be done losslessly.</p> Examples <pre><code>&gt;&gt;&gt; s = pd.Series(range(5))&gt;&gt;&gt; s.where(s &gt; 0)\n0    NaN\n1    1.0\n2    2.0\n3    3.0\n4    4.0\ndtype: float64\n&gt;&gt;&gt; s.mask(s &gt; 0)\n0    0.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; s = pd.Series(range(5))\n&gt;&gt;&gt; t = pd.Series([True, False])\n&gt;&gt;&gt; s.where(t, 99)\n0     0\n1    99\n2    99\n3    99\n4    99\ndtype: int64\n&gt;&gt;&gt; s.mask(t, 99)\n0    99\n1     1\n2    99\n3    99\n4    99\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s.where(s &gt; 1, 10)\n0    10\n1    10\n2    2\n3    3\n4    4\ndtype: int64\n&gt;&gt;&gt; s.mask(s &gt; 1, 10)\n0     0\n1     1\n2    10\n3    10\n4    10\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.arange(10).reshape(-1, 2), columns=['A', 'B'])\n&gt;&gt;&gt; df\n   A  B\n0  0  1\n1  2  3\n2  4  5\n3  6  7\n4  8  9\n&gt;&gt;&gt; m = df % 3 == 0\n&gt;&gt;&gt; df.where(m, -df)\n   A  B\n0  0 -1\n1 -2  3\n2 -4 -5\n3  6 -7\n4 -8  9\n&gt;&gt;&gt; df.where(m, -df) == np.where(m, df, -df)\n      A     B\n0  True  True\n1  True  True\n2  True  True\n3  True  True\n4  True  True\n&gt;&gt;&gt; df.where(m, -df) == df.mask(~m, -df)\n      A     B\n0  True  True\n1  True  True\n2  True  True\n3  True  True\n4  True  True\n</code></pre> method &lt;/&gt; <p>Truncate a Series or DataFrame before and after some index value.</p><p>This is a useful shorthand for boolean indexing based on index values above or below certain thresholds.</p> Parameters <ul> <li><code>before</code> (date, str, int) \u2014 Truncate all rows before this index value.</li> <li><code>after</code> (date, str, int) \u2014 Truncate all rows after this index value.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, optional) \u2014 Axis to truncate. Truncates the index (rows) by default.For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>copy</code> (bool, default is True,) \u2014 Return a copy of the truncated section... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> </ul> Returns (type of caller) <p>The truncated Series or DataFrame.</p> See Also <p>DataFrame.loc : Select a subset of a DataFrame by label.DataFrame.iloc : Select a subset of a DataFrame by position.</p> <p>Notes</p> <p>If the index being truncated contains only datetime values, <code>before</code> and <code>after</code> may be specified as strings instead of Timestamps.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': ['a', 'b', 'c', 'd', 'e'],...                    'B': ['f', 'g', 'h', 'i', 'j'],\n...                    'C': ['k', 'l', 'm', 'n', 'o']},\n...                   index=[1, 2, 3, 4, 5])\n&gt;&gt;&gt; df\n   A  B  C\n1  a  f  k\n2  b  g  l\n3  c  h  m\n4  d  i  n\n5  e  j  o\n</code></pre> <pre><code>&gt;&gt;&gt; df.truncate(before=2, after=4)\n   A  B  C\n2  b  g  l\n3  c  h  m\n4  d  i  n\n</code></pre> <p>The columns of a DataFrame can be truncated.</p> <pre><code>&gt;&gt;&gt; df.truncate(before=\"A\", after=\"B\", axis=\"columns\")\n   A  B\n1  a  f\n2  b  g\n3  c  h\n4  d  i\n5  e  j\n</code></pre> <p>For Series, only rows can be truncated.</p> <pre><code>&gt;&gt;&gt; df['A'].truncate(before=2, after=4)\n2    b\n3    c\n4    d\nName: A, dtype: object\n</code></pre> <p>The index values in <code>truncate</code> can be datetimes or string dates.</p> <pre><code>&gt;&gt;&gt; dates = pd.date_range('2016-01-01', '2016-02-01', freq='s')\n&gt;&gt;&gt; df = pd.DataFrame(index=dates, data={'A': 1})\n&gt;&gt;&gt; df.tail()\n                     A\n2016-01-31 23:59:56  1\n2016-01-31 23:59:57  1\n2016-01-31 23:59:58  1\n2016-01-31 23:59:59  1\n2016-02-01 00:00:00  1\n</code></pre> <pre><code>&gt;&gt;&gt; df.truncate(before=pd.Timestamp('2016-01-05'),\n...             after=pd.Timestamp('2016-01-10')).tail()\n                     A\n2016-01-09 23:59:56  1\n2016-01-09 23:59:57  1\n2016-01-09 23:59:58  1\n2016-01-09 23:59:59  1\n2016-01-10 00:00:00  1\n</code></pre> <p>Because the index is a DatetimeIndex containing only dates, we can specify <code>before</code> and <code>after</code> as strings. They will be coerced to Timestamps before truncation.</p> <pre><code>&gt;&gt;&gt; df.truncate('2016-01-05', '2016-01-10').tail()\n                     A\n2016-01-09 23:59:56  1\n2016-01-09 23:59:57  1\n2016-01-09 23:59:58  1\n2016-01-09 23:59:59  1\n2016-01-10 00:00:00  1\n</code></pre> <p>Note that <code>truncate</code> assumes a 0 value for any unspecified time component (midnight). This differs from partial string slicing, which returns any partially matching dates.</p> <pre><code>&gt;&gt;&gt; df.loc['2016-01-05':'2016-01-10', :].tail()\n                     A\n2016-01-10 23:59:55  1\n2016-01-10 23:59:56  1\n2016-01-10 23:59:57  1\n2016-01-10 23:59:58  1\n2016-01-10 23:59:59  1\n</code></pre> method &lt;/&gt; <p>Convert tz-aware axis to target time zone.</p> Parameters <ul> <li><code>tz</code> (str or tzinfo object or None) \u2014 Target time zone. Passing <code>None</code> will convert toUTC and remove the timezone information. </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to convert</li> <li><code>level</code> (int, str, default None) \u2014 If axis is a MultiIndex, convert a specific level. Otherwisemust be None. </li> <li><code>copy</code> (bool, default True) \u2014 Also make a copy of the underlying data... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> </ul> Returns (Series/DataFrame) <p>Object with time zone converted axis.</p> Raises <ul> <li><code>TypeError</code> \u2014 If the axis is tz-naive.</li> </ul> Examples <p>Change to another time zone:</p><pre><code>&gt;&gt;&gt; s = pd.Series(\n...     [1],\n...     index=pd.DatetimeIndex(['2018-09-15 01:30:00+02:00']),\n... )\n&gt;&gt;&gt; s.tz_convert('Asia/Shanghai')\n2018-09-15 07:30:00+08:00    1\ndtype: int64\n</code></pre> <p>Pass None to convert to UTC and get a tz-naive index:</p> <pre><code>&gt;&gt;&gt; s = pd.Series([1],\n...               index=pd.DatetimeIndex(['2018-09-15 01:30:00+02:00']))\n&gt;&gt;&gt; s.tz_convert(None)\n2018-09-14 23:30:00    1\ndtype: int64\n</code></pre> method &lt;/&gt; <p>Localize tz-naive index of a Series or DataFrame to target time zone.</p><p>This operation localizes the Index. To localize the values in a timezone-naive Series, use :meth:<code>Series.dt.tz_localize</code>.</p> Parameters <ul> <li><code>tz</code> (str or tzinfo or None) \u2014 Time zone to localize. Passing <code>None</code> will remove thetime zone information and preserve local time. </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to localize</li> <li><code>level</code> (int, str, default None) \u2014 If axis ia a MultiIndex, localize a specific level. Otherwisemust be None. </li> <li><code>copy</code> (bool, default True) \u2014 Also make a copy of the underlying data... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> <li><code>ambiguous</code> ('infer', bool-ndarray, 'NaT', default 'raise') \u2014 When clocks moved backward due to DST, ambiguous times may arise.For example in Central European Time (UTC+01), when going from 03:00 DST to 02:00 non-DST, 02:30:00 local time occurs both at 00:30:00 UTC and at 01:30:00 UTC. In such a situation, the <code>ambiguous</code> parameter dictates how ambiguous times should be handled. <ul> <li>'infer' will attempt to infer fall dst-transition hours based on   order</li> <li>bool-ndarray where True signifies a DST time, False designates   a non-DST time (note that this flag is only applicable for   ambiguous times)</li> <li>'NaT' will return NaT where there are ambiguous times</li> <li>'raise' will raise an AmbiguousTimeError if there are ambiguous   times.</li> </ul> </li> <li><code>nonexistent</code> (str, default 'raise') \u2014 A nonexistent time does not exist in a particular timezonewhere clocks moved forward due to DST. Valid values are: <ul> <li>'shift_forward' will shift the nonexistent time forward to the   closest existing time</li> <li>'shift_backward' will shift the nonexistent time backward to the   closest existing time</li> <li>'NaT' will return NaT where there are nonexistent times</li> <li>timedelta objects will shift nonexistent times by the timedelta</li> <li>'raise' will raise an NonExistentTimeError if there are   nonexistent times.</li> </ul> </li> </ul> Returns (Series/DataFrame) <p>Same type as the input.</p> Raises <ul> <li><code>TypeError</code> \u2014 If the TimeSeries is tz-aware and tz is not None.</li> </ul> Examples <p>Localize local times:</p><pre><code>&gt;&gt;&gt; s = pd.Series(\n...     [1],\n...     index=pd.DatetimeIndex(['2018-09-15 01:30:00']),\n... )\n&gt;&gt;&gt; s.tz_localize('CET')\n2018-09-15 01:30:00+02:00    1\ndtype: int64\n</code></pre> <p>Pass None to convert to tz-naive index and preserve local time:</p> <pre><code>&gt;&gt;&gt; s = pd.Series([1],\n...               index=pd.DatetimeIndex(['2018-09-15 01:30:00+02:00']))\n&gt;&gt;&gt; s.tz_localize(None)\n2018-09-15 01:30:00    1\ndtype: int64\n</code></pre> <p>Be careful with DST changes. When there is sequential data, pandas can infer the DST time:</p> <pre><code>&gt;&gt;&gt; s = pd.Series(range(7),\n...               index=pd.DatetimeIndex(['2018-10-28 01:30:00',\n...                                       '2018-10-28 02:00:00',\n...                                       '2018-10-28 02:30:00',\n...                                       '2018-10-28 02:00:00',\n...                                       '2018-10-28 02:30:00',\n...                                       '2018-10-28 03:00:00',\n...                                       '2018-10-28 03:30:00']))\n&gt;&gt;&gt; s.tz_localize('CET', ambiguous='infer')\n2018-10-28 01:30:00+02:00    0\n2018-10-28 02:00:00+02:00    1\n2018-10-28 02:30:00+02:00    2\n2018-10-28 02:00:00+01:00    3\n2018-10-28 02:30:00+01:00    4\n2018-10-28 03:00:00+01:00    5\n2018-10-28 03:30:00+01:00    6\ndtype: int64\n</code></pre> <p>In some cases, inferring the DST is impossible. In such cases, you can pass an ndarray to the ambiguous parameter to set the DST explicitly</p> <pre><code>&gt;&gt;&gt; s = pd.Series(range(3),\n...               index=pd.DatetimeIndex(['2018-10-28 01:20:00',\n...                                       '2018-10-28 02:36:00',\n...                                       '2018-10-28 03:46:00']))\n&gt;&gt;&gt; s.tz_localize('CET', ambiguous=np.array([True, True, False]))\n2018-10-28 01:20:00+02:00    0\n2018-10-28 02:36:00+02:00    1\n2018-10-28 03:46:00+01:00    2\ndtype: int64\n</code></pre> <p>If the DST transition causes nonexistent times, you can shift these dates forward or backward with a timedelta object or <code>'shift_forward'</code> or <code>'shift_backward'</code>.</p> <pre><code>&gt;&gt;&gt; s = pd.Series(range(2),\n...               index=pd.DatetimeIndex(['2015-03-29 02:30:00',\n...                                       '2015-03-29 03:30:00']))\n&gt;&gt;&gt; s.tz_localize('Europe/Warsaw', nonexistent='shift_forward')\n2015-03-29 03:00:00+02:00    0\n2015-03-29 03:30:00+02:00    1\ndtype: int64\n&gt;&gt;&gt; s.tz_localize('Europe/Warsaw', nonexistent='shift_backward')\n2015-03-29 01:59:59.999999999+01:00    0\n2015-03-29 03:30:00+02:00              1\ndtype: int64\n&gt;&gt;&gt; s.tz_localize('Europe/Warsaw', nonexistent=pd.Timedelta('1h'))\n2015-03-29 03:30:00+02:00    0\n2015-03-29 03:30:00+02:00    1\ndtype: int64\n</code></pre> method &lt;/&gt; <p>Generate descriptive statistics.</p><p>Descriptive statistics include those that summarize the central tendency, dispersion and shape of a dataset's distribution, excluding <code>NaN</code> values.</p> <p>Analyzes both numeric and object series, as well as <code>DataFrame</code> column sets of mixed data types. The output will vary depending on what is provided. Refer to the notes below for more detail.</p> Parameters <ul> <li><code>percentiles</code> (list-like of numbers, optional) \u2014 The percentiles to include in the output. All shouldfall between 0 and 1. The default is <code>[.25, .5, .75]</code>, which returns the 25th, 50th, and 75th percentiles. </li> <li><code>include</code> ('all', list-like of dtypes or None (default), optional) \u2014 A white list of data types to include in the result. Ignoredfor <code>Series</code>. Here are the options: <ul> <li>'all' : All columns of the input will be included in the output.</li> <li>A list-like of dtypes : Limits the results to the   provided data types.   To limit the result to numeric types submit   <code>numpy.number</code>. To limit it instead to object columns submit   the <code>numpy.object</code> data type. Strings   can also be used in the style of   <code>select_dtypes</code> (e.g. <code>df.describe(include=['O'])</code>). To   select pandas categorical columns, use <code>'category'</code></li> <li>None (default) : The result will include all numeric columns.</li> </ul> </li> <li><code>exclude</code> (list-like of dtypes or None (default), optional,) \u2014 A black list of data types to omit from the result. Ignoredfor <code>Series</code>. Here are the options: <ul> <li>A list-like of dtypes : Excludes the provided data types   from the result. To exclude numeric types submit   <code>numpy.number</code>. To exclude object columns submit the data   type <code>numpy.object</code>. Strings can also be used in the style of   <code>select_dtypes</code> (e.g. <code>df.describe(exclude=['O'])</code>). To   exclude pandas categorical columns, use <code>'category'</code></li> <li>None (default) : The result will exclude nothing.</li> </ul> </li> </ul> Returns (Series or DataFrame) <p>Summary statistics of the Series or Dataframe provided.</p> See Also <p>DataFrame.count: Count number of non-NA/null observations.DataFrame.max: Maximum of the values in the object. DataFrame.min: Minimum of the values in the object. DataFrame.mean: Mean of the values. DataFrame.std: Standard deviation of the observations. DataFrame.select_dtypes: Subset of a DataFrame including/excluding     columns based on their dtype.</p> <p>Notes</p> <p>For numeric data, the result's index will include <code>count</code>, <code>mean</code>, <code>std</code>, <code>min</code>, <code>max</code> as well as lower, <code>50</code> and upper percentiles. By default the lower percentile is <code>25</code> and the upper percentile is <code>75</code>. The <code>50</code> percentile is the same as the median.</p> <p>For object data (e.g. strings or timestamps), the result's index will include <code>count</code>, <code>unique</code>, <code>top</code>, and <code>freq</code>. The <code>top</code> is the most common value. The <code>freq</code> is the most common value's frequency. Timestamps also include the <code>first</code> and <code>last</code> items.</p> <p>If multiple object values have the highest count, then the <code>count</code> and <code>top</code> results will be arbitrarily chosen from among those with the highest count.</p> <p>For mixed data types provided via a <code>DataFrame</code>, the default is to return only an analysis of numeric columns. If the dataframe consists only of object and categorical data without any numeric columns, the default is to return an analysis of both the object and categorical columns. If <code>include='all'</code> is provided as an option, the result will include a union of attributes of each type.</p> <p>The <code>include</code> and <code>exclude</code> parameters can be used to limit which columns in a <code>DataFrame</code> are analyzed for the output. The parameters are ignored when analyzing a <code>Series</code>.</p> Examples <p>Describing a numeric <code>Series</code>.</p><pre><code>&gt;&gt;&gt; s = pd.Series([1, 2, 3])\n&gt;&gt;&gt; s.describe()\ncount    3.0\nmean     2.0\nstd      1.0\nmin      1.0\n25%      1.5\n50%      2.0\n75%      2.5\nmax      3.0\ndtype: float64\n</code></pre> <p>Describing a categorical <code>Series</code>.</p> <pre><code>&gt;&gt;&gt; s = pd.Series(['a', 'a', 'b', 'c'])\n&gt;&gt;&gt; s.describe()\ncount     4\nunique    3\ntop       a\nfreq      2\ndtype: object\n</code></pre> <p>Describing a timestamp <code>Series</code>.</p> <pre><code>&gt;&gt;&gt; s = pd.Series([\n...     np.datetime64(\"2000-01-01\"),\n...     np.datetime64(\"2010-01-01\"),\n...     np.datetime64(\"2010-01-01\")\n... ])\n&gt;&gt;&gt; s.describe()\ncount                      3\nmean     2006-09-01 08:00:00\nmin      2000-01-01 00:00:00\n25%      2004-12-31 12:00:00\n50%      2010-01-01 00:00:00\n75%      2010-01-01 00:00:00\nmax      2010-01-01 00:00:00\ndtype: object\n</code></pre> <p>Describing a <code>DataFrame</code>. By default only numeric fields are returned.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'categorical': pd.Categorical(['d', 'e', 'f']),\n...                    'numeric': [1, 2, 3],\n...                    'object': ['a', 'b', 'c']\n...                    })\n&gt;&gt;&gt; df.describe()\n       numeric\ncount      3.0\nmean       2.0\nstd        1.0\nmin        1.0\n25%        1.5\n50%        2.0\n75%        2.5\nmax        3.0\n</code></pre> <p>Describing all columns of a <code>DataFrame</code> regardless of data type.</p> <pre><code>&gt;&gt;&gt; df.describe(include='all')  # doctest: +SKIP\n       categorical  numeric object\ncount            3      3.0      3\nunique           3      NaN      3\ntop              f      NaN      a\nfreq             1      NaN      1\nmean           NaN      2.0    NaN\nstd            NaN      1.0    NaN\nmin            NaN      1.0    NaN\n25%            NaN      1.5    NaN\n50%            NaN      2.0    NaN\n75%            NaN      2.5    NaN\nmax            NaN      3.0    NaN\n</code></pre> <p>Describing a column from a <code>DataFrame</code> by accessing it as an attribute.</p> <pre><code>&gt;&gt;&gt; df.numeric.describe()\ncount    3.0\nmean     2.0\nstd      1.0\nmin      1.0\n25%      1.5\n50%      2.0\n75%      2.5\nmax      3.0\nName: numeric, dtype: float64\n</code></pre> <p>Including only numeric columns in a <code>DataFrame</code> description.</p> <pre><code>&gt;&gt;&gt; df.describe(include=[np.number])\n       numeric\ncount      3.0\nmean       2.0\nstd        1.0\nmin        1.0\n25%        1.5\n50%        2.0\n75%        2.5\nmax        3.0\n</code></pre> <p>Including only string columns in a <code>DataFrame</code> description.</p> <pre><code>&gt;&gt;&gt; df.describe(include=[object])  # doctest: +SKIP\n       object\ncount       3\nunique      3\ntop         a\nfreq        1\n</code></pre> <p>Including only categorical columns from a <code>DataFrame</code> description.</p> <pre><code>&gt;&gt;&gt; df.describe(include=['category'])\n       categorical\ncount            3\nunique           3\ntop              d\nfreq             1\n</code></pre> <p>Excluding numeric columns from a <code>DataFrame</code> description.</p> <pre><code>&gt;&gt;&gt; df.describe(exclude=[np.number])  # doctest: +SKIP\n       categorical object\ncount            3      3\nunique           3      3\ntop              f      a\nfreq             1      1\n</code></pre> <p>Excluding object columns from a <code>DataFrame</code> description.</p> <pre><code>&gt;&gt;&gt; df.describe(exclude=[object])  # doctest: +SKIP\n       categorical  numeric\ncount            3      3.0\nunique           3      NaN\ntop              f      NaN\nfreq             1      NaN\nmean           NaN      2.0\nstd            NaN      1.0\nmin            NaN      1.0\n25%            NaN      1.5\n50%            NaN      2.0\n75%            NaN      2.5\nmax            NaN      3.0\n</code></pre> method &lt;/&gt; <p>Fractional change between the current and a prior element.</p><p>Computes the fractional change from the immediately previous row by default. This is useful in comparing the fraction of change in a time series of elements.</p> <p>.. note::</p> <pre><code>Despite the name of this method, it calculates fractional change\n(also known as per unit change or relative change) and not\npercentage change. If you need the percentage change, multiply\nthese values by 100.\n</code></pre> Parameters <ul> <li><code>periods</code> (int, default 1) \u2014 Periods to shift for forming percent change.</li> <li><code>fill_method</code> ({'backfill', 'bfill', 'pad', 'ffill', None}, default 'pad') \u2014 How to handle NAs before computing percent changes... deprecated:: 2.1     All options of <code>fill_method</code> are deprecated except <code>fill_method=None</code>. </li> <li><code>limit</code> (int, default None) \u2014 The number of consecutive NAs to fill before stopping... deprecated:: 2.1 </li> <li><code>freq</code> (DateOffset, timedelta, or str, optional) \u2014 Increment to use from time series API (e.g. 'ME' or BDay()).</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments are passed into<code>DataFrame.shift</code> or <code>Series.shift</code>. </li> </ul> Returns (Series or DataFrame) <p>The same type as the calling object.</p> See Also <p>Series.diff : Compute the difference of two elements in a Series.DataFrame.diff : Compute the difference of two elements in a DataFrame. Series.shift : Shift the index by some number of periods. DataFrame.shift : Shift the index by some number of periods.</p> Examples <p>Series</p><pre><code>&gt;&gt;&gt; s = pd.Series([90, 91, 85])\n&gt;&gt;&gt; s\n0    90\n1    91\n2    85\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s.pct_change()\n0         NaN\n1    0.011111\n2   -0.065934\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; s.pct_change(periods=2)\n0         NaN\n1         NaN\n2   -0.055556\ndtype: float64\n</code></pre> <p>See the percentage change in a Series where filling NAs with last valid observation forward to next valid.</p> <pre><code>&gt;&gt;&gt; s = pd.Series([90, 91, None, 85])\n&gt;&gt;&gt; s\n0    90.0\n1    91.0\n2     NaN\n3    85.0\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; s.ffill().pct_change()\n0         NaN\n1    0.011111\n2    0.000000\n3   -0.065934\ndtype: float64\n</code></pre> <p>DataFrame</p> <p>Percentage change in French franc, Deutsche Mark, and Italian lira from 1980-01-01 to 1980-03-01.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'FR': [4.0405, 4.0963, 4.3149],\n...     'GR': [1.7246, 1.7482, 1.8519],\n...     'IT': [804.74, 810.01, 860.13]},\n...     index=['1980-01-01', '1980-02-01', '1980-03-01'])\n&gt;&gt;&gt; df\n                FR      GR      IT\n1980-01-01  4.0405  1.7246  804.74\n1980-02-01  4.0963  1.7482  810.01\n1980-03-01  4.3149  1.8519  860.13\n</code></pre> <pre><code>&gt;&gt;&gt; df.pct_change()\n                  FR        GR        IT\n1980-01-01       NaN       NaN       NaN\n1980-02-01  0.013810  0.013684  0.006549\n1980-03-01  0.053365  0.059318  0.061876\n</code></pre> <p>Percentage of change in GOOG and APPL stock volume. Shows computing the percentage change between columns.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     '2016': [1769950, 30586265],\n...     '2015': [1500923, 40912316],\n...     '2014': [1371819, 41403351]},\n...     index=['GOOG', 'APPL'])\n&gt;&gt;&gt; df\n          2016      2015      2014\nGOOG   1769950   1500923   1371819\nAPPL  30586265  40912316  41403351\n</code></pre> <pre><code>&gt;&gt;&gt; df.pct_change(axis='columns', periods=-1)\n          2016      2015  2014\nGOOG  0.179241  0.094112   NaN\nAPPL -0.252395 -0.011860   NaN\n</code></pre> method &lt;/&gt; <p>Provide rolling window calculations.</p> Parameters <ul> <li><code>window</code> (int, timedelta, str, offset, or BaseIndexer subclass) \u2014 Size of the moving window.If an integer, the fixed number of observations used for each window. If a timedelta, str, or offset, the time period of each window. Each window will be a variable sized based on the observations included in the time-period. This is only valid for datetimelike indexes. To learn more about the offsets &amp; frequency strings, please see <code>this link &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/timeseries.html#offset-aliases&gt;</code>__. If a BaseIndexer subclass, the window boundaries based on the defined <code>get_window_bounds</code> method. Additional rolling keyword arguments, namely <code>min_periods</code>, <code>center</code>, <code>closed</code> and <code>step</code> will be passed to <code>get_window_bounds</code>. </li> <li><code>min_periods</code> (int, default None) \u2014 Minimum number of observations in window required to have a value;otherwise, result is <code>np.nan</code>. For a window that is specified by an offset, <code>min_periods</code> will default to 1. For a window that is specified by an integer, <code>min_periods</code> will default to the size of the window. </li> <li><code>center</code> (bool, default False) \u2014 If False, set the window labels as the right edge of the window index.If True, set the window labels as the center of the window index. </li> <li><code>win_type</code> (str, default None) \u2014 If <code>None</code>, all points are evenly weighted.If a string, it must be a valid <code>scipy.signal window function &lt;https://docs.scipy.org/doc/scipy/reference/signal.windows.html#module-scipy.signal.windows&gt;</code>__. Certain Scipy window types require additional parameters to be passed in the aggregation function. The additional parameters must match the keywords specified in the Scipy window type method signature. </li> <li><code>on</code> (str, optional) \u2014 For a DataFrame, a column label or Index level on whichto calculate the rolling window, rather than the DataFrame's index. Provided integer column is ignored and excluded from result since an integer index is not used to calculate the rolling window. </li> <li><code>axis</code> (int or str, default 0) \u2014 If <code>0</code> or <code>'index'</code>, roll across the rows.If <code>1</code> or <code>'columns'</code>, roll across the columns. For <code>Series</code> this parameter is unused and defaults to 0. .. deprecated:: 2.1.0 <pre><code>The axis keyword is deprecated. For ``axis=1``,\ntranspose the DataFrame first instead.\n</code></pre> </li> <li><code>closed</code> (str, default None) \u2014 If <code>'right'</code>, the first point in the window is excluded from calculations.If <code>'left'</code>, the last point in the window is excluded from calculations. If <code>'both'</code>, the no points in the window are excluded from calculations. If <code>'neither'</code>, the first and last points in the window are excluded from calculations. Default <code>None</code> (<code>'right'</code>). </li> <li><code>step</code> (int, default None) \u2014 0s r . </li> <li><code>method</code> (str {'single', 'table'}, default 'single') \u2014 0) . ` . </li> </ul> Returns (pandas.api.typing.Window or pandas.api.typing.Rolling) <p>An instance of Window is returned if <code>win_type</code> is passed. Otherwise,an instance of Rolling is returned.</p> See Also <p>expanding : Provides expanding transformations.ewm : Provides exponential weighted functions.</p> <p>Notes</p> <p>See :ref:<code>Windowing Operations &lt;window.generic&gt;</code> for further usage details and examples.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'B': [0, 1, 2, np.nan, 4]})&gt;&gt;&gt; df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0\n</code></pre> <p>window</p> <p>Rolling sum with a window length of 2 observations.</p> <pre><code>&gt;&gt;&gt; df.rolling(2).sum()\n     B\n0  NaN\n1  1.0\n2  3.0\n3  NaN\n4  NaN\n</code></pre> <p>Rolling sum with a window span of 2 seconds.</p> <pre><code>&gt;&gt;&gt; df_time = pd.DataFrame({'B': [0, 1, 2, np.nan, 4]},\n...                        index=[pd.Timestamp('20130101 09:00:00'),\n...                               pd.Timestamp('20130101 09:00:02'),\n...                               pd.Timestamp('20130101 09:00:03'),\n...                               pd.Timestamp('20130101 09:00:05'),\n...                               pd.Timestamp('20130101 09:00:06')])\n</code></pre> <pre><code>&gt;&gt;&gt; df_time\n                       B\n2013-01-01 09:00:00  0.0\n2013-01-01 09:00:02  1.0\n2013-01-01 09:00:03  2.0\n2013-01-01 09:00:05  NaN\n2013-01-01 09:00:06  4.0\n</code></pre> <pre><code>&gt;&gt;&gt; df_time.rolling('2s').sum()\n                       B\n2013-01-01 09:00:00  0.0\n2013-01-01 09:00:02  1.0\n2013-01-01 09:00:03  3.0\n2013-01-01 09:00:05  NaN\n2013-01-01 09:00:06  4.0\n</code></pre> <p>Rolling sum with forward looking windows with 2 observations.</p> <pre><code>&gt;&gt;&gt; indexer = pd.api.indexers.FixedForwardWindowIndexer(window_size=2)\n&gt;&gt;&gt; df.rolling(window=indexer, min_periods=1).sum()\n     B\n0  1.0\n1  3.0\n2  2.0\n3  4.0\n4  4.0\n</code></pre> <p>min_periods</p> <p>Rolling sum with a window length of 2 observations, but only needs a minimum of 1 observation to calculate a value.</p> <pre><code>&gt;&gt;&gt; df.rolling(2, min_periods=1).sum()\n     B\n0  0.0\n1  1.0\n2  3.0\n3  2.0\n4  4.0\n</code></pre> <p>center</p> <p>Rolling sum with the result assigned to the center of the window index.</p> <pre><code>&gt;&gt;&gt; df.rolling(3, min_periods=1, center=True).sum()\n     B\n0  1.0\n1  3.0\n2  3.0\n3  6.0\n4  4.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rolling(3, min_periods=1, center=False).sum()\n     B\n0  0.0\n1  1.0\n2  3.0\n3  3.0\n4  6.0\n</code></pre> <p>step</p> <p>Rolling sum with a window length of 2 observations, minimum of 1 observation to calculate a value, and a step of 2.</p> <pre><code>&gt;&gt;&gt; df.rolling(2, min_periods=1, step=2).sum()\n     B\n0  0.0\n2  3.0\n4  4.0\n</code></pre> <p>win_type</p> <p>Rolling sum with a window length of 2, using the Scipy <code>'gaussian'</code> window type. <code>std</code> is required in the aggregation function.</p> <pre><code>&gt;&gt;&gt; df.rolling(2, win_type='gaussian').sum(std=3)\n          B\n0       NaN\n1  0.986207\n2  2.958621\n3       NaN\n4       NaN\n</code></pre> <p>on</p> <p>Rolling sum with a window length of 2 days.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'A': [pd.to_datetime('2020-01-01'),\n...           pd.to_datetime('2020-01-01'),\n...           pd.to_datetime('2020-01-02'),],\n...     'B': [1, 2, 3], },\n...     index=pd.date_range('2020', periods=3))\n</code></pre> <pre><code>&gt;&gt;&gt; df\n                    A  B\n2020-01-01 2020-01-01  1\n2020-01-02 2020-01-01  2\n2020-01-03 2020-01-02  3\n</code></pre> <pre><code>&gt;&gt;&gt; df.rolling('2D', on='A').sum()\n                    A    B\n2020-01-01 2020-01-01  1.0\n2020-01-02 2020-01-01  3.0\n2020-01-03 2020-01-02  6.0\n</code></pre> method &lt;/&gt; <p>Provide expanding window calculations.</p> Parameters <ul> <li><code>min_periods</code> (int, default 1) \u2014 Minimum number of observations in window required to have a value;otherwise, result is <code>np.nan</code>. </li> <li><code>axis</code> (int or str, default 0) \u2014 If <code>0</code> or <code>'index'</code>, roll across the rows.If <code>1</code> or <code>'columns'</code>, roll across the columns. For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>method</code> (str {'single', 'table'}, default 'single') \u2014 Execute the rolling operation per single column or row (<code>'single'</code>)or over the entire object (<code>'table'</code>). This argument is only implemented when specifying <code>engine='numba'</code> in the method call. .. versionadded:: 1.3.0 </li> </ul> See Also <p>rolling : Provides rolling window calculations.ewm : Provides exponential weighted functions.</p> <p>Notes</p> <p>See :ref:<code>Windowing Operations &lt;window.expanding&gt;</code> for further usage details and examples.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"B\": [0, 1, 2, np.nan, 4]})&gt;&gt;&gt; df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0\n</code></pre> <p>min_periods</p> <p>Expanding sum with 1 vs 3 observations needed to calculate a value.</p> <pre><code>&gt;&gt;&gt; df.expanding(1).sum()\n     B\n0  0.0\n1  1.0\n2  3.0\n3  3.0\n4  7.0\n&gt;&gt;&gt; df.expanding(3).sum()\n     B\n0  NaN\n1  NaN\n2  3.0\n3  3.0\n4  7.0\n</code></pre> method &lt;/&gt; <p>Provide exponentially weighted (EW) calculations.</p><p>Exactly one of <code>com</code>, <code>span</code>, <code>halflife</code>, or <code>alpha</code> must be provided if <code>times</code> is not provided. If <code>times</code> is provided, <code>halflife</code> and one of <code>com</code>, <code>span</code> or <code>alpha</code> may be provided.</p> Parameters <ul> <li><code>com</code> (float, optional) \u2014 Specify decay in terms of center of mass:math:<code>\\alpha = 1 / (1 + com)</code>, for :math:<code>com \\geq 0</code>. </li> <li><code>span</code> (float, optional) \u2014 Specify decay in terms of span:math:<code>\\alpha = 2 / (span + 1)</code>, for :math:<code>span \\geq 1</code>. </li> <li><code>halflife</code> (float, str, timedelta, optional) \u2014 Specify decay in terms of half-life:math:<code>\\alpha = 1 - \\exp\\left(-\\ln(2) / halflife\\right)</code>, for :math:<code>halflife &gt; 0</code>. If <code>times</code> is specified, a timedelta convertible unit over which an observation decays to half its value. Only applicable to <code>mean()</code>, and halflife value will not apply to the other functions. </li> <li><code>alpha</code> (float, optional) \u2014 Specify smoothing factor :math:<code>\\alpha</code> directly:math:<code>0 &lt; \\alpha \\leq 1</code>. </li> <li><code>min_periods</code> (int, default 0) \u2014 Minimum number of observations in window required to have a value;otherwise, result is <code>np.nan</code>. </li> <li><code>adjust</code> (bool, default True) \u2014 Divide by decaying adjustment factor in beginning periods to accountfor imbalance in relative weightings (viewing EWMA as a moving average). <ul> <li>When <code>adjust=True</code> (default), the EW function is calculated using weights   :math:<code>w_i = (1 - \\alpha)^i</code>. For example, the EW moving average of the series   [:math:<code>x_0, x_1, ..., x_t</code>] would be:</li> </ul> .. math::     y_t = \\frac{x_t + (1 - \\alpha)x_{t-1} + (1 - \\alpha)^2 x_{t-2} + ... + (1 -     \\alpha)^t x_0}{1 + (1 - \\alpha) + (1 - \\alpha)^2 + ... + (1 - \\alpha)^t} <ul> <li>When <code>adjust=False</code>, the exponentially weighted function is calculated   recursively:</li> </ul> .. math::     \\begin{split}         y_0 &amp;= x_0\\         y_t &amp;= (1 - \\alpha) y_{t-1} + \\alpha x_t,     \\end{split} </li> <li><code>ignore_na</code> (bool, default False) \u2014 Ignore missing values when calculating weights.<ul> <li> When <code>ignore_na=False</code> (default), weights are based on absolute positions.   For example, the weights of :math:<code>x_0</code> and :math:<code>x_2</code> used in calculating   the final weighted average of [:math:<code>x_0</code>, None, :math:<code>x_2</code>] are   :math:<code>(1-\\alpha)^2</code> and :math:<code>1</code> if <code>adjust=True</code>, and   :math:<code>(1-\\alpha)^2</code> and :math:<code>\\alpha</code> if <code>adjust=False</code>. </li> <li> When <code>ignore_na=True</code>, weights are based   on relative positions. For example, the weights of :math:<code>x_0</code> and :math:<code>x_2</code>   used in calculating the final weighted average of   [:math:<code>x_0</code>, None, :math:<code>x_2</code>] are :math:<code>1-\\alpha</code> and :math:<code>1</code> if   <code>adjust=True</code>, and :math:<code>1-\\alpha</code> and :math:<code>\\alpha</code> if <code>adjust=False</code>. </li> </ul> </li> <li><code>axis</code> ({0, 1}, default 0) \u2014 If <code>0</code> or <code>'index'</code>, calculate across the rows.If <code>1</code> or <code>'columns'</code>, calculate across the columns. For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>times</code> (np.ndarray, Series, default None) \u2014 .d . . </li> <li><code>method</code> (str {'single', 'table'}, default 'single') \u2014 .. versionadded:: 1.4.0Execute the rolling operation per single column or row (<code>'single'</code>) or over the entire object (<code>'table'</code>). This argument is only implemented when specifying <code>engine='numba'</code> in the method call. Only applicable to <code>mean()</code> </li> </ul> See Also <p>rolling : Provides rolling window calculations.expanding : Provides expanding transformations.</p> <p>Notes</p> <p>See :ref:<code>Windowing Operations &lt;window.exponentially_weighted&gt;</code> for further usage details and examples.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'B': [0, 1, 2, np.nan, 4]})&gt;&gt;&gt; df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.ewm(com=0.5).mean()\n          B\n0  0.000000\n1  0.750000\n2  1.615385\n3  1.615385\n4  3.670213\n&gt;&gt;&gt; df.ewm(alpha=2 / 3).mean()\n          B\n0  0.000000\n1  0.750000\n2  1.615385\n3  1.615385\n4  3.670213\n</code></pre> <p>adjust</p> <pre><code>&gt;&gt;&gt; df.ewm(com=0.5, adjust=True).mean()\n          B\n0  0.000000\n1  0.750000\n2  1.615385\n3  1.615385\n4  3.670213\n&gt;&gt;&gt; df.ewm(com=0.5, adjust=False).mean()\n          B\n0  0.000000\n1  0.666667\n2  1.555556\n3  1.555556\n4  3.650794\n</code></pre> <p>ignore_na</p> <pre><code>&gt;&gt;&gt; df.ewm(com=0.5, ignore_na=True).mean()\n          B\n0  0.000000\n1  0.750000\n2  1.615385\n3  1.615385\n4  3.225000\n&gt;&gt;&gt; df.ewm(com=0.5, ignore_na=False).mean()\n          B\n0  0.000000\n1  0.750000\n2  1.615385\n3  1.615385\n4  3.670213\n</code></pre> <p>times</p> <p>Exponentially weighted mean with weights calculated with a timedelta <code>halflife</code> relative to <code>times</code>.</p> <pre><code>&gt;&gt;&gt; times = ['2020-01-01', '2020-01-03', '2020-01-10', '2020-01-15', '2020-01-17']\n&gt;&gt;&gt; df.ewm(halflife='4 days', times=pd.DatetimeIndex(times)).mean()\n          B\n0  0.000000\n1  0.585786\n2  1.523889\n3  1.523889\n4  3.233686\n</code></pre> method &lt;/&gt; <p>Return index for first non-NA value or None, if no non-NA value is found.</p> Examples <p>For Series:</p><pre><code>&gt;&gt;&gt; s = pd.Series([None, 3, 4])\n&gt;&gt;&gt; s.first_valid_index()\n1\n&gt;&gt;&gt; s.last_valid_index()\n2\n</code></pre> <pre><code>&gt;&gt;&gt; s = pd.Series([None, None])\n&gt;&gt;&gt; print(s.first_valid_index())\nNone\n&gt;&gt;&gt; print(s.last_valid_index())\nNone\n</code></pre> <p>If all elements in Series are NA/null, returns None.</p> <pre><code>&gt;&gt;&gt; s = pd.Series()\n&gt;&gt;&gt; print(s.first_valid_index())\nNone\n&gt;&gt;&gt; print(s.last_valid_index())\nNone\n</code></pre> <p>If Series is empty, returns None.</p> <p>For DataFrame:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [None, None, 2], 'B': [None, 3, 4]})\n&gt;&gt;&gt; df\n     A      B\n0  NaN    NaN\n1  NaN    3.0\n2  2.0    4.0\n&gt;&gt;&gt; df.first_valid_index()\n1\n&gt;&gt;&gt; df.last_valid_index()\n2\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [None, None, None], 'B': [None, None, None]})\n&gt;&gt;&gt; df\n     A      B\n0  None   None\n1  None   None\n2  None   None\n&gt;&gt;&gt; print(df.first_valid_index())\nNone\n&gt;&gt;&gt; print(df.last_valid_index())\nNone\n</code></pre> <p>If all elements in DataFrame are NA/null, returns None.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame()\n&gt;&gt;&gt; df\nEmpty DataFrame\nColumns: []\nIndex: []\n&gt;&gt;&gt; print(df.first_valid_index())\nNone\n&gt;&gt;&gt; print(df.last_valid_index())\nNone\n</code></pre> <p>If DataFrame is empty, returns None.</p> method &lt;/&gt; <p>Return index for last non-NA value or None, if no non-NA value is found.</p> Examples <p>For Series:</p><pre><code>&gt;&gt;&gt; s = pd.Series([None, 3, 4])\n&gt;&gt;&gt; s.first_valid_index()\n1\n&gt;&gt;&gt; s.last_valid_index()\n2\n</code></pre> <pre><code>&gt;&gt;&gt; s = pd.Series([None, None])\n&gt;&gt;&gt; print(s.first_valid_index())\nNone\n&gt;&gt;&gt; print(s.last_valid_index())\nNone\n</code></pre> <p>If all elements in Series are NA/null, returns None.</p> <pre><code>&gt;&gt;&gt; s = pd.Series()\n&gt;&gt;&gt; print(s.first_valid_index())\nNone\n&gt;&gt;&gt; print(s.last_valid_index())\nNone\n</code></pre> <p>If Series is empty, returns None.</p> <p>For DataFrame:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [None, None, 2], 'B': [None, 3, 4]})\n&gt;&gt;&gt; df\n     A      B\n0  NaN    NaN\n1  NaN    3.0\n2  2.0    4.0\n&gt;&gt;&gt; df.first_valid_index()\n1\n&gt;&gt;&gt; df.last_valid_index()\n2\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [None, None, None], 'B': [None, None, None]})\n&gt;&gt;&gt; df\n     A      B\n0  None   None\n1  None   None\n2  None   None\n&gt;&gt;&gt; print(df.first_valid_index())\nNone\n&gt;&gt;&gt; print(df.last_valid_index())\nNone\n</code></pre> <p>If all elements in DataFrame are NA/null, returns None.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame()\n&gt;&gt;&gt; df\nEmpty DataFrame\nColumns: []\nIndex: []\n&gt;&gt;&gt; print(df.first_valid_index())\nNone\n&gt;&gt;&gt; print(df.last_valid_index())\nNone\n</code></pre> <p>If DataFrame is empty, returns None.</p> method &lt;/&gt; <p>Return the dataframe interchange object implementing the interchange protocol.</p> Parameters <ul> <li><code>nan_as_null</code> (bool, default False) \u2014 <code>nan_as_null</code> is DEPRECATED and has no effect. Please avoid usingit; it will be removed in a future release. </li> <li><code>allow_copy</code> (bool, default True) \u2014 Whether to allow memory copying when exporting. If set to Falseit would cause non-zero-copy exports to fail. </li> </ul> Returns (DataFrame interchange object) <p>The object which consuming library can use to ingress the dataframe.</p> <p>Notes</p> <p>Details on the interchange protocol: https://data-apis.org/dataframe-protocol/latest/index.html</p> Examples <pre><code>&gt;&gt;&gt; df_not_necessarily_pandas = pd.DataFrame({'A': [1, 2], 'B': [3, 4]})&gt;&gt;&gt; interchange_object = df_not_necessarily_pandas.__dataframe__()\n&gt;&gt;&gt; interchange_object.column_names()\nIndex(['A', 'B'], dtype='object')\n&gt;&gt;&gt; df_pandas = (pd.api.interchange.from_dataframe\n...              (interchange_object.select_columns_by_name(['A'])))\n&gt;&gt;&gt; df_pandas\n     A\n0    1\n1    2\n</code></pre> <p>These methods (<code>column_names</code>, <code>select_columns_by_name</code>) should work for any dataframe library which implements the interchange protocol.</p> method &lt;/&gt; <p>Provide entry point to the Consortium DataFrame Standard API.</p><p>This is developed and maintained outside of pandas. Please report any issues to https://github.com/data-apis/dataframe-api-compat.</p> method &lt;/&gt; <p>Export the pandas DataFrame as an Arrow C stream PyCapsule.</p><p>This relies on pyarrow to convert the pandas DataFrame to the Arrow format (and follows the default behaviour of <code>pyarrow.Table.from_pandas</code> in its handling of the index, i.e. store the index as a column except for RangeIndex). This conversion is not necessarily zero-copy.</p> Parameters <ul> <li><code>requested_schema</code> (PyCapsule, default None) \u2014 The schema to which the dataframe should be casted, passed as aPyCapsule containing a C ArrowSchema representation of the requested schema. </li> </ul> method &lt;/&gt; <p>Return a string representation for a particular DataFrame.</p> method &lt;/&gt; <p>Render a DataFrame to a console-friendly tabular output.</p> Parameters <ul> <li><code>buf</code> (str, Path or StringIO-like, optional, default None) \u2014 Buffer to write to. If None, the output is returned as a string.</li> <li><code>columns</code> (array-like, optional, default None) \u2014 The subset of columns to write. Writes all columns by default.</li> <li><code>col_space</code> (int, list or dict of int, optional) \u2014 The minimum width of each column. If a list of ints is given every integers corresponds with one column. If a dict is given, the key references the column, while the value defines the space to use..</li> <li><code>header</code> (bool or list of str, optional) \u2014 Write out the column names. If a list of columns is given, it is assumed to be aliases for the column names.</li> <li><code>index</code> (bool, optional, default True) \u2014 Whether to print index (row) labels.</li> <li><code>na_rep</code> (str, optional, default 'NaN') \u2014 String representation of <code>NaN</code> to use.</li> <li><code>formatters</code> (list, tuple or dict of one-param. functions, optional) \u2014 Formatter functions to apply to columns' elements by position orname. The result of each function must be a unicode string. List/tuple must be of length equal to the number of columns. </li> <li><code>float_format</code> (one-parameter function, optional, default None) \u2014 Formatter function to apply to columns' elements if they arefloats. This function must return a unicode string and will be applied only to the non-<code>NaN</code> elements, with <code>NaN</code> being handled by <code>na_rep</code>. </li> <li><code>sparsify</code> (bool, optional, default True) \u2014 Set to False for a DataFrame with a hierarchical index to printevery multiindex key at each row. </li> <li><code>index_names</code> (bool, optional, default True) \u2014 Prints the names of the indexes.</li> <li><code>justify</code> (str, default None) \u2014 How to justify the column labels. If None uses the option fromthe print configuration (controlled by set_option), 'right' out of the box. Valid values are <ul> <li>left</li> <li>right</li> <li>center</li> <li>justify</li> <li>justify-all</li> <li>start</li> <li>end</li> <li>inherit</li> <li>match-parent</li> <li>initial</li> <li>unset.</li> </ul> </li> <li><code>max_rows</code> (int, optional) \u2014 Maximum number of rows to display in the console.</li> <li><code>max_cols</code> (int, optional) \u2014 Maximum number of columns to display in the console.</li> <li><code>show_dimensions</code> (bool, default False) \u2014 Display DataFrame dimensions (number of rows by number of columns).</li> <li><code>decimal</code> (str, default '.') \u2014 Character recognized as decimal separator, e.g. ',' in Europe.</li> <li><code>line_width</code> (int, optional) \u2014 Width to wrap a line in characters.</li> <li><code>min_rows</code> (int, optional) \u2014 The number of rows to display in the console in a truncated repr(when number of rows is above <code>max_rows</code>). </li> <li><code>max_colwidth</code> (int, optional) \u2014 Max width to truncate each column in characters. By default, no limit.</li> <li><code>encoding</code> (str, default \"utf-8\") \u2014 Set character encoding.</li> </ul> Returns (str or None) <p>If buf is None, returns the result as a string. Otherwise returnsNone.</p> See Also <p>to_html : Convert DataFrame to HTML.</p> Examples <pre><code>&gt;&gt;&gt; d = {'col1': [1, 2, 3], 'col2': [4, 5, 6]}&gt;&gt;&gt; df = pd.DataFrame(d)\n&gt;&gt;&gt; print(df.to_string())\n   col1  col2\n0     1     4\n1     2     5\n2     3     6\n</code></pre> generator &lt;/&gt; <p>Iterate over (column name, Series) pairs.</p><p>Iterates over the DataFrame columns, returning a tuple with the column name and the content as a Series.</p> Yields (label : object) <p>The column names for the DataFrame being iterated over.ent : Series The column entries belonging to each label, as a Series.</p> See Also <p>DataFrame.iterrows : Iterate over DataFrame rows as    (index, Series) pairs. DataFrame.itertuples : Iterate over DataFrame rows as namedtuples     of the values.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'species': ['bear', 'bear', 'marsupial'],...                   'population': [1864, 22000, 80000]},\n...                   index=['panda', 'polar', 'koala'])\n&gt;&gt;&gt; df\n        species   population\npanda   bear      1864\npolar   bear      22000\nkoala   marsupial 80000\n&gt;&gt;&gt; for label, content in df.items():\n...     print(f'label: {label}')\n...     print(f'content: {content}', sep='\\n')\n...\nlabel: species\ncontent:\npanda         bear\npolar         bear\nkoala    marsupial\nName: species, dtype: object\nlabel: population\ncontent:\npanda     1864\npolar    22000\nkoala    80000\nName: population, dtype: int64\n</code></pre> generator &lt;/&gt; <p>Iterate over DataFrame rows as (index, Series) pairs.</p> Yields (index : label or tuple of label) <p>The index of the row. A tuple for a <code>MultiIndex</code>. : Series The data of the row as a Series.</p> See Also <p>DataFrame.itertuples : Iterate over DataFrame rows as namedtuples of the values.DataFrame.items : Iterate over (column name, Series) pairs.</p> <p>Notes</p> <ol> <li>Because <code>iterrows</code> returns a Series for each row,    it does not preserve dtypes across the rows (dtypes are    preserved across columns for DataFrames).</li> </ol> <p>To preserve dtypes while iterating over the rows, it is better    to use :meth:<code>itertuples</code> which returns namedtuples of the values    and which is generally faster than <code>iterrows</code>.</p> <ol> <li>You should never modify something you are iterating over.    This is not guaranteed to work in all cases. Depending on the    data types, the iterator returns a copy and not a view, and writing    to it will have no effect.</li> </ol> Examples <p>)] w 0 5 4 ) 4 ) 4</p> method &lt;/&gt; <p>Iterate over DataFrame rows as namedtuples.</p> Parameters <ul> <li><code>index</code> (bool, default True) \u2014 If True, return the index as the first element of the tuple.</li> <li><code>name</code> (str or None, default \"Pandas\") \u2014 The name of the returned namedtuples or None to return regulartuples. </li> </ul> Returns (iterator) <p>An object to iterate over namedtuples for each row in theDataFrame with the first field possibly being the index and following fields being the column values.</p> See Also <p>DataFrame.iterrows : Iterate over DataFrame rows as (index, Series)    pairs. DataFrame.items : Iterate over (column name, Series) pairs.</p> <p>Notes</p> <p>The column names will be renamed to positional names if they are invalid Python identifiers, repeated, or start with an underscore.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'num_legs': [4, 2], 'num_wings': [0, 2]},...                   index=['dog', 'hawk'])\n&gt;&gt;&gt; df\n      num_legs  num_wings\ndog          4          0\nhawk         2          2\n&gt;&gt;&gt; for row in df.itertuples():\n...     print(row)\n...\nPandas(Index='dog', num_legs=4, num_wings=0)\nPandas(Index='hawk', num_legs=2, num_wings=2)\n</code></pre> <p>By setting the <code>index</code> parameter to False we can remove the index as the first element of the tuple:</p> <pre><code>&gt;&gt;&gt; for row in df.itertuples(index=False):\n...     print(row)\n...\nPandas(num_legs=4, num_wings=0)\nPandas(num_legs=2, num_wings=2)\n</code></pre> <p>With the <code>name</code> parameter set we set a custom name for the yielded namedtuples:</p> <pre><code>&gt;&gt;&gt; for row in df.itertuples(name='Animal'):\n...     print(row)\n...\nAnimal(Index='dog', num_legs=4, num_wings=0)\nAnimal(Index='hawk', num_legs=2, num_wings=2)\n</code></pre> method &lt;/&gt; <p>Returns length of info axis, but here we use the index.</p> method &lt;/&gt; <p>Compute the matrix multiplication between the DataFrame and other.</p><p>This method computes the matrix product between the DataFrame and the values of an other Series, DataFrame or a numpy array.</p> <p>It can also be called using <code>self @ other</code>.</p> Parameters <ul> <li><code>other</code> (Series, DataFrame or array-like) \u2014 The other object to compute the matrix product with.</li> </ul> Returns (Series or DataFrame) <p>If other is a Series, return the matrix product between self andother as a Series. If other is a DataFrame or a numpy.array, return the matrix product of self and other in a DataFrame of a np.array.</p> See Also <p>Series.dot: Similar method for Series.</p> <p>Notes</p> <p>The dimensions of DataFrame and other must be compatible in order to compute the matrix multiplication. In addition, the column names of DataFrame and the index of other must contain the same values, as they will be aligned prior to the multiplication.</p> <p>The dot method for Series computes the inner product, instead of the matrix product here.</p> Examples <p>Here we multiply a DataFrame with a Series.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame([[0, 1, -2, -1], [1, 1, 1, 1]])\n&gt;&gt;&gt; s = pd.Series([1, 1, 2, 1])\n&gt;&gt;&gt; df.dot(s)\n0    -4\n1     5\ndtype: int64\n</code></pre> <p>Here we multiply a DataFrame with another DataFrame.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame([[0, 1], [1, 2], [-1, -1], [2, 0]])\n&gt;&gt;&gt; df.dot(other)\n    0   1\n0   1   4\n1   2   2\n</code></pre> <p>Note that the dot method give the same result as @</p> <pre><code>&gt;&gt;&gt; df @ other\n    0   1\n0   1   4\n1   2   2\n</code></pre> <p>The dot method works also if other is an np.array.</p> <pre><code>&gt;&gt;&gt; arr = np.array([[0, 1], [1, 2], [-1, -1], [2, 0]])\n&gt;&gt;&gt; df.dot(arr)\n    0   1\n0   1   4\n1   2   2\n</code></pre> <p>Note how shuffling of the objects does not change the result.</p> <pre><code>&gt;&gt;&gt; s2 = s.reindex([1, 0, 2, 3])\n&gt;&gt;&gt; df.dot(s2)\n0    -4\n1     5\ndtype: int64\n</code></pre> method &lt;/&gt; <p>Matrix multiplication using binary <code>@</code> operator.</p> method &lt;/&gt; <p>Matrix multiplication using binary <code>@</code> operator.</p> classmethod &lt;/&gt; <p>Construct DataFrame from dict of array-like or dicts.</p><p>Creates DataFrame object from dictionary by columns or by index allowing dtype specification.</p> Parameters <ul> <li><code>data</code> (dict) \u2014 Of the form {field : array-like} or {field : dict}.</li> <li><code>orient</code> ({'columns', 'index', 'tight'}, default 'columns') \u2014 The \"orientation\" of the data. If the keys of the passed dictshould be the columns of the resulting DataFrame, pass 'columns' (default). Otherwise if the keys should be rows, pass 'index'. If 'tight', assume a dict with keys ['index', 'columns', 'data', 'index_names', 'column_names']. .. versionadded:: 1.4.0    'tight' as an allowed value for the <code>orient</code> argument </li> <li><code>dtype</code> (dtype, default None) \u2014 Data type to force after DataFrame construction, otherwise infer.</li> <li><code>columns</code> (list, default None) \u2014 Column labels to use when <code>orient='index'</code>. Raises a ValueErrorif used with <code>orient='columns'</code> or <code>orient='tight'</code>. </li> </ul> See Also <p>DataFrame.from_records : DataFrame from structured ndarray, sequence    of tuples or dicts, or DataFrame. DataFrame : DataFrame object creation using constructor. DataFrame.to_dict : Convert the DataFrame to a dictionary.</p> Examples <p>By default the keys of the dict become the DataFrame columns:</p><pre><code>&gt;&gt;&gt; data = {'col_1': [3, 2, 1, 0], 'col_2': ['a', 'b', 'c', 'd']}\n&gt;&gt;&gt; pd.DataFrame.from_dict(data)\n   col_1 col_2\n0      3     a\n1      2     b\n2      1     c\n3      0     d\n</code></pre> <p>Specify <code>orient='index'</code> to create the DataFrame using dictionary keys as rows:</p> <pre><code>&gt;&gt;&gt; data = {'row_1': [3, 2, 1, 0], 'row_2': ['a', 'b', 'c', 'd']}\n&gt;&gt;&gt; pd.DataFrame.from_dict(data, orient='index')\n       0  1  2  3\nrow_1  3  2  1  0\nrow_2  a  b  c  d\n</code></pre> <p>When using the 'index' orientation, the column names can be specified manually:</p> <pre><code>&gt;&gt;&gt; pd.DataFrame.from_dict(data, orient='index',\n...                        columns=['A', 'B', 'C', 'D'])\n       A  B  C  D\nrow_1  3  2  1  0\nrow_2  a  b  c  d\n</code></pre> <p>Specify <code>orient='tight'</code> to create the DataFrame using a 'tight' format:</p> <pre><code>&gt;&gt;&gt; data = {'index': [('a', 'b'), ('a', 'c')],\n...         'columns': [('x', 1), ('y', 2)],\n...         'data': [[1, 3], [2, 4]],\n...         'index_names': ['n1', 'n2'],\n...         'column_names': ['z1', 'z2']}\n&gt;&gt;&gt; pd.DataFrame.from_dict(data, orient='tight')\nz1     x  y\nz2     1  2\nn1 n2\na  b   1  3\n   c   2  4\n</code></pre> method &lt;/&gt; <p>Convert the DataFrame to a NumPy array.</p><p>By default, the dtype of the returned array will be the common NumPy dtype of all types in the DataFrame. For example, if the dtypes are <code>float16</code> and <code>float32</code>, the results dtype will be <code>float32</code>. This may require copying data and coercing values, which may be expensive.</p> Parameters <ul> <li><code>dtype</code> (str or numpy.dtype, optional) \u2014 The dtype to pass to :meth:<code>numpy.asarray</code>.</li> <li><code>copy</code> (bool, default False) \u2014 Whether to ensure that the returned value is not a view onanother array. Note that <code>copy=False</code> does not ensure that <code>to_numpy()</code> is no-copy. Rather, <code>copy=True</code> ensure that a copy is made, even if not strictly necessary. </li> <li><code>na_value</code> (Any, optional) \u2014 The value to use for missing values. The default value dependson <code>dtype</code> and the dtypes of the DataFrame columns. </li> </ul> See Also <p>Series.to_numpy : Similar method for Series.</p> Examples <pre><code>&gt;&gt;&gt; pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}).to_numpy()array([[1, 3],\n       [2, 4]])\n</code></pre> <p>With heterogeneous data, the lowest common type will have to be used.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [3.0, 4.5]})\n&gt;&gt;&gt; df.to_numpy()\narray([[1. , 3. ],\n       [2. , 4.5]])\n</code></pre> <p>For a mix of numeric and non-numeric types, the output array will have object dtype.</p> <pre><code>&gt;&gt;&gt; df['C'] = pd.date_range('2000', periods=2)\n&gt;&gt;&gt; df.to_numpy()\narray([[1, 3.0, Timestamp('2000-01-01 00:00:00')],\n       [2, 4.5, Timestamp('2000-01-02 00:00:00')]], dtype=object)\n</code></pre> method &lt;/&gt; <p>Convert the DataFrame to a dictionary.</p><p>The type of the key-value pairs can be customized with the parameters (see below).</p> Parameters <ul> <li><code>orient</code> (str {'dict', 'list', 'series', 'split', 'tight', 'records', 'index'}) \u2014 Determines the type of the values of the dictionary.<ul> <li>'dict' (default) : dict like {column -&gt; {index -&gt; value}}</li> <li>'list' : dict like {column -&gt; [values]}</li> <li>'series' : dict like {column -&gt; Series(values)}</li> <li>'split' : dict like   {'index' -&gt; [index], 'columns' -&gt; [columns], 'data' -&gt; [values]}</li> <li>'tight' : dict like   {'index' -&gt; [index], 'columns' -&gt; [columns], 'data' -&gt; [values],   'index_names' -&gt; [index.names], 'column_names' -&gt; [column.names]}</li> <li>'records' : list like   [{column -&gt; value}, ... , {column -&gt; value}]</li> <li>'index' : dict like {index -&gt; {column -&gt; value}}</li> </ul> .. versionadded:: 1.4.0     'tight' as an allowed value for the <code>orient</code> argument </li> <li><code>into</code> (class, default dict) \u2014 The collections.abc.MutableMapping subclass used for all Mappingsin the return value.  Can be the actual class or an empty instance of the mapping type you want.  If you want a collections.defaultdict, you must pass it initialized. </li> <li><code>index</code> (bool, default True) \u2014 Whether to include the index item (and index_names item if <code>orient</code>is 'tight') in the returned dictionary. Can only be <code>False</code> when <code>orient</code> is 'split' or 'tight'. .. versionadded:: 2.0.0 </li> </ul> Returns (dict, list or collections.abc.MutableMapping) <p>Return a collections.abc.MutableMapping object representing theDataFrame. The resulting transformation depends on the <code>orient</code> parameter.</p> See Also <p>DataFrame.from_dict: Create a DataFrame from a dictionary.DataFrame.to_json: Convert a DataFrame to JSON format.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'col1': [1, 2],...                    'col2': [0.5, 0.75]},\n...                   index=['row1', 'row2'])\n&gt;&gt;&gt; df\n      col1  col2\nrow1     1  0.50\nrow2     2  0.75\n&gt;&gt;&gt; df.to_dict()\n{'col1': {'row1': 1, 'row2': 2}, 'col2': {'row1': 0.5, 'row2': 0.75}}\n</code></pre> <p>You can specify the return orientation.</p> <pre><code>&gt;&gt;&gt; df.to_dict('series')\n{'col1': row1    1\n         row2    2\nName: col1, dtype: int64,\n'col2': row1    0.50\n        row2    0.75\nName: col2, dtype: float64}\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_dict('split')\n{'index': ['row1', 'row2'], 'columns': ['col1', 'col2'],\n 'data': [[1, 0.5], [2, 0.75]]}\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_dict('records')\n[{'col1': 1, 'col2': 0.5}, {'col1': 2, 'col2': 0.75}]\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_dict('index')\n{'row1': {'col1': 1, 'col2': 0.5}, 'row2': {'col1': 2, 'col2': 0.75}}\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_dict('tight')\n{'index': ['row1', 'row2'], 'columns': ['col1', 'col2'],\n 'data': [[1, 0.5], [2, 0.75]], 'index_names': [None], 'column_names': [None]}\n</code></pre> <p>You can also specify the mapping type.</p> <pre><code>&gt;&gt;&gt; from collections import OrderedDict, defaultdict\n&gt;&gt;&gt; df.to_dict(into=OrderedDict)\nOrderedDict([('col1', OrderedDict([('row1', 1), ('row2', 2)])),\n             ('col2', OrderedDict([('row1', 0.5), ('row2', 0.75)]))])\n</code></pre> <p>If you want a <code>defaultdict</code>, you need to initialize it:</p> <pre><code>&gt;&gt;&gt; dd = defaultdict(list)\n&gt;&gt;&gt; df.to_dict('records', into=dd)\n[defaultdict(&lt;class 'list'&gt;, {'col1': 1, 'col2': 0.5}),\n defaultdict(&lt;class 'list'&gt;, {'col1': 2, 'col2': 0.75})]\n</code></pre> method &lt;/&gt; <p>Write a DataFrame to a Google BigQuery table.</p><p>.. deprecated:: 2.2.0</p> <p>Please use <code>pandas_gbq.to_gbq</code> instead.</p> <p>This function requires the <code>pandas-gbq package &lt;https://pandas-gbq.readthedocs.io&gt;</code>__.</p> <p>See the <code>How to authenticate with Google BigQuery &lt;https://pandas-gbq.readthedocs.io/en/latest/howto/authentication.html&gt;</code>__ guide for authentication instructions.</p> Parameters <ul> <li><code>destination_table</code> (str) \u2014 Name of table to be written, in the form <code>dataset.tablename</code>.</li> <li><code>project_id</code> (str, optional) \u2014 Google BigQuery Account project ID. Optional when available fromthe environment. </li> <li><code>chunksize</code> (int, optional) \u2014 Number of rows to be inserted in each chunk from the dataframe.Set to <code>None</code> to load the whole dataframe at once. </li> <li><code>reauth</code> (bool, default False) \u2014 Force Google BigQuery to re-authenticate the user. This is usefulif multiple accounts are used. </li> <li><code>if_exists</code> (str, default 'fail') \u2014 Behavior when the destination table exists. Value can be one of:<code>'fail'</code>     If table exists raise pandasgbq.gbq.TableCreationError. <code>'replace'</code>     If table exists, drop it, recreate it, and insert data. <code>'append'</code>     If table exists, insert data. Create if does not exist. </li> <li><code>auth_local_webserver</code> (bool, default True) \u2014 Use the <code>local webserver flow</code> instead of the <code>console flow</code>when getting user credentials. .. _local webserver flow:     https://google-auth-oauthlib.readthedocs.io/en/latest/reference/google_auth_oauthlib.flow.html#google_auth_oauthlib.flow.InstalledAppFlow.run_local_server .. _console flow:     https://google-auth-oauthlib.readthedocs.io/en/latest/reference/google_auth_oauthlib.flow.html#google_auth_oauthlib.flow.InstalledAppFlow.run_console New in version 0.2.0 of pandas-gbq. .. versionchanged:: 1.5.0    Default value is changed to <code>True</code>. Google has deprecated the    <code>auth_local_webserver = False</code> <code>\"out of band\" (copy-paste)    flow    &lt;https://developers.googleblog.com/2022/02/making-oauth-flows-safer.html?m=1#disallowed-oob&gt;</code>_. </li> <li><code>table_schema</code> (list of dicts, optional) \u2014 List of BigQuery table fields to which according DataFramecolumns conform to, e.g. <code>[{'name': 'col1', 'type': 'STRING'},...]</code>. If schema is not provided, it will be generated according to dtypes of DataFrame columns. See BigQuery API documentation on available names of a field. New in version 0.3.1 of pandas-gbq. </li> <li><code>location</code> (str, optional) \u2014 Location where the load job should run. See the <code>BigQuery locationsdocumentation &lt;https://cloud.google.com/bigquery/docs/dataset-locations&gt;</code>__ for a list of available locations. The location must match that of the target dataset. New in version 0.5.0 of pandas-gbq. </li> <li><code>progress_bar</code> (bool, default True) \u2014 Use the library <code>tqdm</code> to show the progress bar for the upload,chunk by chunk. New in version 0.5.0 of pandas-gbq. </li> <li><code>credentials</code> (google.auth.credentials.Credentials, optional) \u2014 Credentials for accessing Google APIs. Use this parameter tooverride default credentials, such as to use Compute Engine :class:<code>google.auth.compute_engine.Credentials</code> or Service Account :class:<code>google.oauth2.service_account.Credentials</code> directly. New in version 0.8.0 of pandas-gbq. </li> </ul> See Also <p>pandas_gbq.to_gbq : This function in the pandas-gbq library.read_gbq : Read a DataFrame from Google BigQuery.</p> Examples <p>Example taken from <code>Google BigQuery documentation&lt;https://cloud.google.com/bigquery/docs/samples/bigquery-pandas-gbq-to-gbq-simple&gt;</code>_</p> <pre><code>&gt;&gt;&gt; project_id = \"my-project\"\n&gt;&gt;&gt; table_id = 'my_dataset.my_table'\n&gt;&gt;&gt; df = pd.DataFrame({\n...                   \"my_string\": [\"a\", \"b\", \"c\"],\n...                   \"my_int64\": [1, 2, 3],\n...                   \"my_float64\": [4.0, 5.0, 6.0],\n...                   \"my_bool1\": [True, False, True],\n...                   \"my_bool2\": [False, True, False],\n...                   \"my_dates\": pd.date_range(\"now\", periods=3),\n...                   }\n...                   )\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_gbq(table_id, project_id=project_id)  # doctest: +SKIP\n</code></pre> classmethod &lt;/&gt; <p>Convert structured or record ndarray to DataFrame.</p><p>Creates a DataFrame object from a structured ndarray, sequence of tuples or dicts, or DataFrame.</p> Parameters <ul> <li><code>data</code> (structured ndarray, sequence of tuples or dicts, or DataFrame) \u2014 Structured input data... deprecated:: 2.1.0     Passing a DataFrame is deprecated. </li> <li><code>index</code> (str, list of fields, array-like) \u2014 Field of array to use as the index, alternately a specific set ofinput labels to use. </li> <li><code>exclude</code> (sequence, default None) \u2014 Columns or fields to exclude.</li> <li><code>columns</code> (sequence, default None) \u2014 Column names to use. If the passed data do not have namesassociated with them, this argument provides names for the columns. Otherwise this argument indicates the order of the columns in the result (any names not found in the data will become all-NA columns). </li> <li><code>coerce_float</code> (bool, default False) \u2014 Attempt to convert values of non-string, non-numeric objects (likedecimal.Decimal) to floating point, useful for SQL result sets. </li> <li><code>nrows</code> (int, default None) \u2014 Number of rows to read if data is an iterator.</li> </ul> See Also <p>DataFrame.from_dict : DataFrame from dict of array-like or dicts.DataFrame : DataFrame object creation using constructor.</p> Examples <p>Data can be provided as a structured ndarray:</p><pre><code>&gt;&gt;&gt; data = np.array([(3, 'a'), (2, 'b'), (1, 'c'), (0, 'd')],\n...                 dtype=[('col_1', 'i4'), ('col_2', 'U1')])\n&gt;&gt;&gt; pd.DataFrame.from_records(data)\n   col_1 col_2\n0      3     a\n1      2     b\n2      1     c\n3      0     d\n</code></pre> <p>Data can be provided as a list of dicts:</p> <pre><code>&gt;&gt;&gt; data = [{'col_1': 3, 'col_2': 'a'},\n...         {'col_1': 2, 'col_2': 'b'},\n...         {'col_1': 1, 'col_2': 'c'},\n...         {'col_1': 0, 'col_2': 'd'}]\n&gt;&gt;&gt; pd.DataFrame.from_records(data)\n   col_1 col_2\n0      3     a\n1      2     b\n2      1     c\n3      0     d\n</code></pre> <p>Data can be provided as a list of tuples with corresponding columns:</p> <pre><code>&gt;&gt;&gt; data = [(3, 'a'), (2, 'b'), (1, 'c'), (0, 'd')]\n&gt;&gt;&gt; pd.DataFrame.from_records(data, columns=['col_1', 'col_2'])\n   col_1 col_2\n0      3     a\n1      2     b\n2      1     c\n3      0     d\n</code></pre> method &lt;/&gt; <p>Convert DataFrame to a NumPy record array.</p><p>Index will be included as the first field of the record array if requested.</p> Parameters <ul> <li><code>index</code> (bool, default True) \u2014 Include index in resulting record array, stored in 'index'field or using the index label, if set. </li> <li><code>column_dtypes</code> (str, type, dict, default None) \u2014 If a string or type, the data type to store all columns. Ifa dictionary, a mapping of column names and indices (zero-indexed) to specific data types. </li> <li><code>index_dtypes</code> (str, type, dict, default None) \u2014 If a string or type, the data type to store all index levels. Ifa dictionary, a mapping of index level names and indices (zero-indexed) to specific data types. This mapping is applied only if <code>index=True</code>. </li> </ul> Returns (numpy.rec.recarray) <p>NumPy ndarray with the DataFrame labels as fields and each rowof the DataFrame as entries.</p> See Also <p>DataFrame.from_records: Convert structured or record ndarray    to DataFrame. numpy.rec.recarray: An ndarray that allows field access using     attributes, analogous to typed columns in a     spreadsheet.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2], 'B': [0.5, 0.75]},...                   index=['a', 'b'])\n&gt;&gt;&gt; df\n   A     B\na  1  0.50\nb  2  0.75\n&gt;&gt;&gt; df.to_records()\nrec.array([('a', 1, 0.5 ), ('b', 2, 0.75)],\n          dtype=[('index', 'O'), ('A', '&lt;i8'), ('B', '&lt;f8')])\n</code></pre> <p>If the DataFrame index has no label then the recarray field name is set to 'index'. If the index has a label then this is used as the field name:</p> <pre><code>&gt;&gt;&gt; df.index = df.index.rename(\"I\")\n&gt;&gt;&gt; df.to_records()\nrec.array([('a', 1, 0.5 ), ('b', 2, 0.75)],\n          dtype=[('I', 'O'), ('A', '&lt;i8'), ('B', '&lt;f8')])\n</code></pre> <p>The index can be excluded from the record array:</p> <pre><code>&gt;&gt;&gt; df.to_records(index=False)\nrec.array([(1, 0.5 ), (2, 0.75)],\n          dtype=[('A', '&lt;i8'), ('B', '&lt;f8')])\n</code></pre> <p>Data types can be specified for the columns:</p> <pre><code>&gt;&gt;&gt; df.to_records(column_dtypes={\"A\": \"int32\"})\nrec.array([('a', 1, 0.5 ), ('b', 2, 0.75)],\n          dtype=[('I', 'O'), ('A', '&lt;i4'), ('B', '&lt;f8')])\n</code></pre> <p>As well as for the index:</p> <pre><code>&gt;&gt;&gt; df.to_records(index_dtypes=\"&lt;S2\")\nrec.array([(b'a', 1, 0.5 ), (b'b', 2, 0.75)],\n          dtype=[('I', 'S2'), ('A', '&lt;i8'), ('B', '&lt;f8')])\n</code></pre> <pre><code>&gt;&gt;&gt; index_dtypes = f\"&lt;S{df.index.str.len().max()}\"\n&gt;&gt;&gt; df.to_records(index_dtypes=index_dtypes)\nrec.array([(b'a', 1, 0.5 ), (b'b', 2, 0.75)],\n          dtype=[('I', 'S1'), ('A', '&lt;i8'), ('B', '&lt;f8')])\n</code></pre> method &lt;/&gt; <p>Export DataFrame object to Stata dta format.</p><p>Writes the DataFrame to a Stata dataset file. \"dta\" files contain a Stata dataset.</p> Parameters <ul> <li><code>path</code> (str, path object, or buffer) \u2014 String, path object (implementing <code>os.PathLike[str]</code>), or file-likeobject implementing a binary <code>write()</code> function. </li> <li><code>convert_dates</code> (dict) \u2014 Dictionary mapping columns containing datetime types to statainternal format to use when writing the dates. Options are 'tc', 'td', 'tm', 'tw', 'th', 'tq', 'ty'. Column can be either an integer or a name. Datetime columns that do not have a conversion type specified will be converted to 'tc'. Raises NotImplementedError if a datetime column has timezone information. </li> <li><code>write_index</code> (bool) \u2014 Write the index to Stata dataset.</li> <li><code>byteorder</code> (str) \u2014 Can be \"&gt;\", \"&lt;\", \"little\", or \"big\". default is <code>sys.byteorder</code>.</li> <li><code>time_stamp</code> (datetime) \u2014 A datetime to use as file creation date.  Default is the currenttime. </li> <li><code>data_label</code> (str, optional) \u2014 A label for the data set.  Must be 80 characters or smaller.</li> <li><code>variable_labels</code> (dict) \u2014 Dictionary containing columns as keys and variable labels asvalues. Each label must be 80 characters or smaller. </li> <li><code>version</code> ({114, 117, 118, 119, None}, default 114) \u2014 Version to use in the output dta file. Set to None to let pandasdecide between 118 or 119 formats depending on the number of columns in the frame. Version 114 can be read by Stata 10 and later. Version 117 can be read by Stata 13 or later. Version 118 is supported in Stata 14 and later. Version 119 is supported in Stata 15 and later. Version 114 limits string variables to 244 characters or fewer while versions 117 and later allow strings with lengths up to 2,000,000 characters. Versions 118 and 119 support Unicode characters, and version 119 supports more than 32,767 variables. Version 119 should usually only be used when the number of variables exceeds the capacity of dta format 118. Exporting smaller datasets in format 119 may have unintended consequences, and, as of November 2020, Stata SE cannot read version 119 files. </li> <li><code>convert_strl</code> (list, optional) \u2014 List of column names to convert to string columns to Stata StrLformat. Only available if version is 117.  Storing strings in the StrL format can produce smaller dta files if strings have more than 8 characters and values are repeated. </li> <li><code>compression</code> (str or dict, default 'infer') \u2014 For on-the-fly compression of the output data. If 'infer' and 'path' ispath-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', '.xz', '.zst', '.tar', '.tar.gz', '.tar.xz' or '.tar.bz2' (otherwise no compression). Set to <code>None</code> for no compression. Can also be a dict with key <code>'method'</code> set to one of {<code>'zip'</code>, <code>'gzip'</code>, <code>'bz2'</code>, <code>'zstd'</code>, <code>'xz'</code>, <code>'tar'</code>} and other key-value pairs are forwarded to <code>zipfile.ZipFile</code>, <code>gzip.GzipFile</code>, <code>bz2.BZ2File</code>, <code>zstandard.ZstdCompressor</code>, <code>lzma.LZMAFile</code> or <code>tarfile.TarFile</code>, respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: <code>compression={'method': 'gzip', 'compresslevel': 1, 'mtime': 1}</code>. .. versionadded:: 1.5.0     Added support for <code>.tar</code> files. .. versionchanged:: 1.4.0 Zstandard support. </li> <li><code>storage_options</code> (dict, optional) \u2014 Extra options that make sense for a particular storage connection, e.g.host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to <code>urllib.request.Request</code> as header options. For other URLs (e.g. starting with \"s3://\", and \"gcs://\") the key-value pairs are forwarded to <code>fsspec.open</code>. Please see <code>fsspec</code> and <code>urllib</code> for more details, and for more examples on storage options refer <code>here &lt;https://pandas.pydata.org/docs/user_guide/io.html? highlight=storage_options#reading-writing-remote-files&gt;</code>_. </li> <li><code>value_labels</code> (dict of dicts) \u2014 Dictionary containing columns as keys and dictionaries of column valueto labels as values. Labels for a single variable must be 32,000 characters or smaller. .. versionadded:: 1.4.0 </li> </ul> Raises <ul> <li><code>NotImplementedError</code> \u2014 <ul><li>If datetimes contain timezone information</li> <li>Column dtype is not representable in Stata</li> </ul> </li> <li><code>ValueError</code> \u2014 <ul><li>Columns listed in convert_dates are neither datetime64[ns]   or datetime.datetime</li> <li>Column listed in convert_dates is not in DataFrame</li> <li>Categorical label contains more than 32,000 characters</li> </ul> </li> </ul> See Also <p>read_stata : Import Stata data files.io.stata.StataWriter : Low-level writer for Stata data files. io.stata.StataWriter117 : Low-level writer for version 117 files.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'animal': ['falcon', 'parrot', 'falcon',...                               'parrot'],\n...                    'speed': [350, 18, 361, 15]})\n&gt;&gt;&gt; df.to_stata('animals.dta')  # doctest: +SKIP\n</code></pre> method &lt;/&gt; <p>Write a DataFrame to the binary Feather format.</p> Parameters <ul> <li><code>path</code> (str, path object, file-like object) \u2014 String, path object (implementing <code>os.PathLike[str]</code>), or file-likeobject implementing a binary <code>write()</code> function. If a string or a path, it will be used as Root Directory path when writing a partitioned dataset. </li> <li><code>**kwargs</code> \u2014 Additional keywords passed to :func:<code>pyarrow.feather.write_feather</code>.This includes the <code>compression</code>, <code>compression_level</code>, <code>chunksize</code> and <code>version</code> keywords. </li> </ul> <p>Notes</p> <p>This function writes the dataframe as a <code>feather file &lt;https://arrow.apache.org/docs/python/feather.html&gt;</code>_. Requires a default index. For saving the DataFrame with your custom index use a method that supports custom indices e.g. <code>to_parquet</code>.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; df.to_feather(\"file.feather\")  # doctest: +SKIP\n</code></pre> method &lt;/&gt; <p>Print DataFrame in Markdown-friendly format.</p> Parameters <ul> <li><code>buf</code> (str, Path or StringIO-like, optional, default None) \u2014 Buffer to write to. If None, the output is returned as a string.</li> <li><code>mode</code> (str, optional) \u2014 Mode in which file is opened, \"wt\" by default.</li> <li><code>index</code> (bool, optional, default True) \u2014 Add index (row) labels.</li> <li><code>storage_options</code> (dict, optional) \u2014 Extra options that make sense for a particular storage connection, e.g.host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to <code>urllib.request.Request</code> as header options. For other URLs (e.g. starting with \"s3://\", and \"gcs://\") the key-value pairs are forwarded to <code>fsspec.open</code>. Please see <code>fsspec</code> and <code>urllib</code> for more details, and for more examples on storage options refer <code>here &lt;https://pandas.pydata.org/docs/user_guide/io.html? highlight=storage_options#reading-writing-remote-files&gt;</code>_. </li> <li><code>**kwargs</code> \u2014 These parameters will be passed to <code>tabulate                 &lt;https://pypi.org/project/tabulate&gt;</code>_.</li> </ul> Returns (str) <p>DataFrame in Markdown-friendly format.</p> <p>Notes</p> <p>Requires the <code>tabulate &lt;https://pypi.org/project/tabulate&gt;</code>_ package.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(...     data={\"animal_1\": [\"elk\", \"pig\"], \"animal_2\": [\"dog\", \"quetzal\"]}\n... )\n&gt;&gt;&gt; print(df.to_markdown())\n|    | animal_1   | animal_2   |\n|---:|:-----------|:-----------|\n|  0 | elk        | dog        |\n|  1 | pig        | quetzal    |\n</code></pre> <p>Output markdown with a tabulate option.</p> <pre><code>&gt;&gt;&gt; print(df.to_markdown(tablefmt=\"grid\"))\n+----+------------+------------+\n|    | animal_1   | animal_2   |\n+====+============+============+\n|  0 | elk        | dog        |\n+----+------------+------------+\n|  1 | pig        | quetzal    |\n+----+------------+------------+\n</code></pre> method &lt;/&gt; <p>Write a DataFrame to the binary parquet format.</p><p>This function writes the dataframe as a <code>parquet file &lt;https://parquet.apache.org/&gt;</code>_. You can choose different parquet backends, and have the option of compression. See :ref:<code>the user guide &lt;io.parquet&gt;</code> for more details.</p> Parameters <ul> <li><code>path</code> (str, path object, file-like object, or None, default None) \u2014 String, path object (implementing <code>os.PathLike[str]</code>), or file-likeobject implementing a binary <code>write()</code> function. If None, the result is returned as bytes. If a string or path, it will be used as Root Directory path when writing a partitioned dataset. </li> <li><code>engine</code> ({'auto', 'pyarrow', 'fastparquet'}, default 'auto') \u2014 Parquet library to use. If 'auto', then the option<code>io.parquet.engine</code> is used. The default <code>io.parquet.engine</code> behavior is to try 'pyarrow', falling back to 'fastparquet' if 'pyarrow' is unavailable. </li> <li><code>compression</code> (str or None, default 'snappy') \u2014 Name of the compression to use. Use <code>None</code> for no compression.Supported options: 'snappy', 'gzip', 'brotli', 'lz4', 'zstd'. </li> <li><code>index</code> (bool, default None) \u2014 If <code>True</code>, include the dataframe's index(es) in the file output.If <code>False</code>, they will not be written to the file. If <code>None</code>, similar to <code>True</code> the dataframe's index(es) will be saved. However, instead of being saved as values, the RangeIndex will be stored as a range in the metadata so it doesn't require much space and is faster. Other indexes will be included as columns in the file output. </li> <li><code>partition_cols</code> (list, optional, default None) \u2014 Column names by which to partition the dataset.Columns are partitioned in the order they are given. Must be None if path is not a string. </li> <li><code>storage_options</code> (dict, optional) \u2014 Extra options that make sense for a particular storage connection, e.g.host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to <code>urllib.request.Request</code> as header options. For other URLs (e.g. starting with \"s3://\", and \"gcs://\") the key-value pairs are forwarded to <code>fsspec.open</code>. Please see <code>fsspec</code> and <code>urllib</code> for more details, and for more examples on storage options refer <code>here &lt;https://pandas.pydata.org/docs/user_guide/io.html? highlight=storage_options#reading-writing-remote-files&gt;</code>_. </li> <li><code>**kwargs</code> \u2014 Additional arguments passed to the parquet library. See:ref:<code>pandas io &lt;io.parquet&gt;</code> for more details. </li> </ul> See Also <p>read_parquet : Read a parquet file.DataFrame.to_orc : Write an orc file. DataFrame.to_csv : Write a csv file. DataFrame.to_sql : Write to a sql table. DataFrame.to_hdf : Write to hdf.</p> <p>Notes</p> <p>This function requires either the <code>fastparquet &lt;https://pypi.org/project/fastparquet&gt;</code> or <code>pyarrow &lt;https://arrow.apache.org/docs/python/&gt;</code> library.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(data={'col1': [1, 2], 'col2': [3, 4]})&gt;&gt;&gt; df.to_parquet('df.parquet.gzip',\n...               compression='gzip')  # doctest: +SKIP\n&gt;&gt;&gt; pd.read_parquet('df.parquet.gzip')  # doctest: +SKIP\n   col1  col2\n0     1     3\n1     2     4\n</code></pre> <p>If you want to get a buffer to the parquet content you can use a io.BytesIO object, as long as you don't use partition_cols, which creates multiple files.</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; f = io.BytesIO()\n&gt;&gt;&gt; df.to_parquet(f)\n&gt;&gt;&gt; f.seek(0)\n0\n&gt;&gt;&gt; content = f.read()\n</code></pre> method &lt;/&gt; <p>Write a DataFrame to the ORC format.</p><p>.. versionadded:: 1.5.0</p> Parameters <ul> <li><code>path</code> (str, file-like object or None, default None) \u2014 If a string, it will be used as Root Directory pathwhen writing a partitioned dataset. By file-like object, we refer to objects with a write() method, such as a file handle (e.g. via builtin open function). If path is None, a bytes object is returned. </li> <li><code>engine</code> ({'pyarrow'}, default 'pyarrow') \u2014 ORC library to use.</li> <li><code>index</code> (bool, optional) \u2014 If <code>True</code>, include the dataframe's index(es) in the file output.If <code>False</code>, they will not be written to the file. If <code>None</code>, similar to <code>infer</code> the dataframe's index(es) will be saved. However, instead of being saved as values, the RangeIndex will be stored as a range in the metadata so it doesn't require much space and is faster. Other indexes will be included as columns in the file output. </li> <li><code>engine_kwargs</code> (dict[str, Any] or None, default None) \u2014 Additional keyword arguments passed to :func:<code>pyarrow.orc.write_table</code>.</li> </ul> Raises <ul> <li><code>NotImplementedError</code> \u2014 Dtype of one or more columns is category, unsigned integers, interval,period or sparse. </li> <li><code>ValueError</code> \u2014 engine is not pyarrow.</li> </ul> See Also <p>read_orc : Read a ORC file.DataFrame.to_parquet : Write a parquet file. DataFrame.to_csv : Write a csv file. DataFrame.to_sql : Write to a sql table. DataFrame.to_hdf : Write to hdf.</p> <p>Notes</p> <ul> <li>Before using this function you should read the :ref:<code>user guide about   ORC &lt;io.orc&gt;</code> and :ref:<code>install optional dependencies &lt;install.warn_orc&gt;</code>.</li> <li>This function requires <code>pyarrow &lt;https://arrow.apache.org/docs/python/&gt;</code>_   library.</li> <li>For supported dtypes please refer to <code>supported ORC features in Arrow   &lt;https://arrow.apache.org/docs/cpp/orc.html#data-types&gt;</code>__.</li> <li>Currently timezones in datetime columns are not preserved when a   dataframe is converted into ORC files.</li> </ul> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(data={'col1': [1, 2], 'col2': [4, 3]})&gt;&gt;&gt; df.to_orc('df.orc')  # doctest: +SKIP\n&gt;&gt;&gt; pd.read_orc('df.orc')  # doctest: +SKIP\n   col1  col2\n0     1     4\n1     2     3\n</code></pre> <p>If you want to get a buffer to the orc content you can write it to io.BytesIO</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; b = io.BytesIO(df.to_orc())  # doctest: +SKIP\n&gt;&gt;&gt; b.seek(0)  # doctest: +SKIP\n0\n&gt;&gt;&gt; content = b.read()  # doctest: +SKIP\n</code></pre> method &lt;/&gt; <p>Render a DataFrame as an HTML table.</p> Parameters <ul> <li><code>buf</code> (str, Path or StringIO-like, optional, default None) \u2014 Buffer to write to. If None, the output is returned as a string.</li> <li><code>columns</code> (array-like, optional, default None) \u2014 The subset of columns to write. Writes all columns by default.</li> <li><code>col_space</code> (str or int, list or dict of int or str, optional) \u2014 The minimum width of each column in CSS length units.  An int is assumed to be px units..</li> <li><code>header</code> (bool, optional) \u2014 Whether to print column labels, default True.</li> <li><code>index</code> (bool, optional, default True) \u2014 Whether to print index (row) labels.</li> <li><code>na_rep</code> (str, optional, default 'NaN') \u2014 String representation of <code>NaN</code> to use.</li> <li><code>formatters</code> (list, tuple or dict of one-param. functions, optional) \u2014 Formatter functions to apply to columns' elements by position orname. The result of each function must be a unicode string. List/tuple must be of length equal to the number of columns. </li> <li><code>float_format</code> (one-parameter function, optional, default None) \u2014 Formatter function to apply to columns' elements if they arefloats. This function must return a unicode string and will be applied only to the non-<code>NaN</code> elements, with <code>NaN</code> being handled by <code>na_rep</code>. </li> <li><code>sparsify</code> (bool, optional, default True) \u2014 Set to False for a DataFrame with a hierarchical index to printevery multiindex key at each row. </li> <li><code>index_names</code> (bool, optional, default True) \u2014 Prints the names of the indexes.</li> <li><code>justify</code> (str, default None) \u2014 How to justify the column labels. If None uses the option fromthe print configuration (controlled by set_option), 'right' out of the box. Valid values are <ul> <li>left</li> <li>right</li> <li>center</li> <li>justify</li> <li>justify-all</li> <li>start</li> <li>end</li> <li>inherit</li> <li>match-parent</li> <li>initial</li> <li>unset.</li> </ul> </li> <li><code>max_rows</code> (int, optional) \u2014 Maximum number of rows to display in the console.</li> <li><code>max_cols</code> (int, optional) \u2014 Maximum number of columns to display in the console.</li> <li><code>show_dimensions</code> (bool, default False) \u2014 Display DataFrame dimensions (number of rows by number of columns).</li> <li><code>decimal</code> (str, default '.') \u2014 Character recognized as decimal separator, e.g. ',' in Europe.</li> <li><code>bold_rows</code> (bool, default True) \u2014 Make the row labels bold in the output.</li> <li><code>classes</code> (str or list or tuple, default None) \u2014 CSS class(es) to apply to the resulting html table.</li> <li><code>escape</code> (bool, default True) \u2014 Convert the characters &lt;, &gt;, and &amp; to HTML-safe sequences.</li> <li><code>notebook</code> ({True, False}, default False) \u2014 Whether the generated HTML is for IPython Notebook.</li> <li><code>border</code> (int) \u2014 A <code>border=border</code> attribute is included in the opening<code>&lt;table&gt;</code> tag. Default <code>pd.options.display.html.border</code>. </li> <li><code>table_id</code> (str, optional) \u2014 A css id is included in the opening <code>&lt;table&gt;</code> tag if specified.</li> <li><code>render_links</code> (bool, default False) \u2014 Convert URLs to HTML links.</li> <li><code>encoding</code> (str, default \"utf-8\") \u2014 Set character encoding.</li> </ul> Returns (str or None) <p>If buf is None, returns the result as a string. Otherwise returnsNone.</p> See Also <p>to_string : Convert DataFrame to a string.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(data={'col1': [1, 2], 'col2': [4, 3]})&gt;&gt;&gt; html_string = '''&lt;table border=\"1\" class=\"dataframe\"&gt;\n...   &lt;thead&gt;\n...     &lt;tr style=\"text-align: right;\"&gt;\n...       &lt;th&gt;&lt;/th&gt;\n...       &lt;th&gt;col1&lt;/th&gt;\n...       &lt;th&gt;col2&lt;/th&gt;\n...     &lt;/tr&gt;\n...   &lt;/thead&gt;\n...   &lt;tbody&gt;\n...     &lt;tr&gt;\n...       &lt;th&gt;0&lt;/th&gt;\n...       &lt;td&gt;1&lt;/td&gt;\n...       &lt;td&gt;4&lt;/td&gt;\n...     &lt;/tr&gt;\n...     &lt;tr&gt;\n...       &lt;th&gt;1&lt;/th&gt;\n...       &lt;td&gt;2&lt;/td&gt;\n...       &lt;td&gt;3&lt;/td&gt;\n...     &lt;/tr&gt;\n...   &lt;/tbody&gt;\n... &lt;/table&gt;'''\n&gt;&gt;&gt; assert html_string == df.to_html()\n</code></pre> method &lt;/&gt; <p>Render a DataFrame to an XML document.</p><p>.. versionadded:: 1.3.0</p> Parameters <ul> <li><code>path_or_buffer</code> (str, path object, file-like object, or None, default None) \u2014 String, path object (implementing <code>os.PathLike[str]</code>), or file-likeobject implementing a <code>write()</code> function. If None, the result is returned as a string. </li> <li><code>index</code> (bool, default True) \u2014 Whether to include index in XML document.</li> <li><code>root_name</code> (str, default 'data') \u2014 The name of root element in XML document.</li> <li><code>row_name</code> (str, default 'row') \u2014 The name of row element in XML document.</li> <li><code>na_rep</code> (str, optional) \u2014 Missing data representation.</li> <li><code>attr_cols</code> (list-like, optional) \u2014 List of columns to write as attributes in row element.Hierarchical columns will be flattened with underscore delimiting the different levels. </li> <li><code>elem_cols</code> (list-like, optional) \u2014 List of columns to write as children in row element. By default,all columns output as children of row element. Hierarchical columns will be flattened with underscore delimiting the different levels. </li> <li><code>namespaces</code> (dict, optional) \u2014 All namespaces to be defined in root element. Keys of dictshould be prefix names and values of dict corresponding URIs. Default namespaces should be given empty string key. For example, :: <pre><code>namespaces = {\"\": \"https://example.com\"}\n</code></pre> </li> <li><code>prefix</code> (str, optional) \u2014 Namespace prefix to be used for every element and/or attributein document. This should be one of the keys in <code>namespaces</code> dict. </li> <li><code>encoding</code> (str, default 'utf-8') \u2014 Encoding of the resulting document.</li> <li><code>xml_declaration</code> (bool, default True) \u2014 Whether to include the XML declaration at start of document.</li> <li><code>pretty_print</code> (bool, default True) \u2014 Whether output should be pretty printed with indentation andline breaks. </li> <li><code>parser</code> ({'lxml','etree'}, default 'lxml') \u2014 Parser module to use for building of tree. Only 'lxml' and'etree' are supported. With 'lxml', the ability to use XSLT stylesheet is supported. </li> <li><code>stylesheet</code> (str, path object or file-like object, optional) \u2014 A URL, file-like object, or a raw string containing an XSLTscript used to transform the raw XML output. Script should use layout of elements and attributes from original output. This argument requires <code>lxml</code> to be installed. Only XSLT 1.0 scripts and not later versions is currently supported. </li> <li><code>compression</code> (str or dict, default 'infer') \u2014 For on-the-fly compression of the output data. If 'infer' and 'path_or_buffer' ispath-like, then detect compression from the following extensions: '.gz', '.bz2', '.zip', '.xz', '.zst', '.tar', '.tar.gz', '.tar.xz' or '.tar.bz2' (otherwise no compression). Set to <code>None</code> for no compression. Can also be a dict with key <code>'method'</code> set to one of {<code>'zip'</code>, <code>'gzip'</code>, <code>'bz2'</code>, <code>'zstd'</code>, <code>'xz'</code>, <code>'tar'</code>} and other key-value pairs are forwarded to <code>zipfile.ZipFile</code>, <code>gzip.GzipFile</code>, <code>bz2.BZ2File</code>, <code>zstandard.ZstdCompressor</code>, <code>lzma.LZMAFile</code> or <code>tarfile.TarFile</code>, respectively. As an example, the following could be passed for faster compression and to create a reproducible gzip archive: <code>compression={'method': 'gzip', 'compresslevel': 1, 'mtime': 1}</code>. .. versionadded:: 1.5.0     Added support for <code>.tar</code> files. .. versionchanged:: 1.4.0 Zstandard support. </li> <li><code>storage_options</code> (dict, optional) \u2014 Extra options that make sense for a particular storage connection, e.g.host, port, username, password, etc. For HTTP(S) URLs the key-value pairs are forwarded to <code>urllib.request.Request</code> as header options. For other URLs (e.g. starting with \"s3://\", and \"gcs://\") the key-value pairs are forwarded to <code>fsspec.open</code>. Please see <code>fsspec</code> and <code>urllib</code> for more details, and for more examples on storage options refer <code>here &lt;https://pandas.pydata.org/docs/user_guide/io.html? highlight=storage_options#reading-writing-remote-files&gt;</code>_. </li> </ul> Returns (None or str) <p>If <code>io</code> is None, returns the resulting XML format as astring. Otherwise returns None.</p> See Also <p>to_json : Convert the pandas object to a JSON string.to_html : Convert DataFrame to a html.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'shape': ['square', 'circle', 'triangle'],...                    'degrees': [360, 360, 180],\n...                    'sides': [4, np.nan, 3]})\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_xml()  # doctest: +SKIP\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;data&gt;\n  &lt;row&gt;\n    &lt;index&gt;0&lt;/index&gt;\n    &lt;shape&gt;square&lt;/shape&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides&gt;4.0&lt;/sides&gt;\n  &lt;/row&gt;\n  &lt;row&gt;\n    &lt;index&gt;1&lt;/index&gt;\n    &lt;shape&gt;circle&lt;/shape&gt;\n    &lt;degrees&gt;360&lt;/degrees&gt;\n    &lt;sides/&gt;\n  &lt;/row&gt;\n  &lt;row&gt;\n    &lt;index&gt;2&lt;/index&gt;\n    &lt;shape&gt;triangle&lt;/shape&gt;\n    &lt;degrees&gt;180&lt;/degrees&gt;\n    &lt;sides&gt;3.0&lt;/sides&gt;\n  &lt;/row&gt;\n&lt;/data&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_xml(attr_cols=[\n...           'index', 'shape', 'degrees', 'sides'\n...           ])  # doctest: +SKIP\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;data&gt;\n  &lt;row index=\"0\" shape=\"square\" degrees=\"360\" sides=\"4.0\"/&gt;\n  &lt;row index=\"1\" shape=\"circle\" degrees=\"360\"/&gt;\n  &lt;row index=\"2\" shape=\"triangle\" degrees=\"180\" sides=\"3.0\"/&gt;\n&lt;/data&gt;\n</code></pre> <pre><code>&gt;&gt;&gt; df.to_xml(namespaces={\"doc\": \"https://example.com\"},\n...           prefix=\"doc\")  # doctest: +SKIP\n&lt;?xml version='1.0' encoding='utf-8'?&gt;\n&lt;doc:data xmlns:doc=\"https://example.com\"&gt;\n  &lt;doc:row&gt;\n    &lt;doc:index&gt;0&lt;/doc:index&gt;\n    &lt;doc:shape&gt;square&lt;/doc:shape&gt;\n    &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;\n    &lt;doc:sides&gt;4.0&lt;/doc:sides&gt;\n  &lt;/doc:row&gt;\n  &lt;doc:row&gt;\n    &lt;doc:index&gt;1&lt;/doc:index&gt;\n    &lt;doc:shape&gt;circle&lt;/doc:shape&gt;\n    &lt;doc:degrees&gt;360&lt;/doc:degrees&gt;\n    &lt;doc:sides/&gt;\n  &lt;/doc:row&gt;\n  &lt;doc:row&gt;\n    &lt;doc:index&gt;2&lt;/doc:index&gt;\n    &lt;doc:shape&gt;triangle&lt;/doc:shape&gt;\n    &lt;doc:degrees&gt;180&lt;/doc:degrees&gt;\n    &lt;doc:sides&gt;3.0&lt;/doc:sides&gt;\n  &lt;/doc:row&gt;\n&lt;/doc:data&gt;\n</code></pre> method &lt;/&gt; <p>Print a concise summary of a DataFrame.</p><p>This method prints information about a DataFrame including the index dtype and columns, non-null values and memory usage.</p> Parameters <ul> <li><code>verbose</code> (bool, optional) \u2014 Whether to print the full summary. By default, the setting in<code>pandas.options.display.max_info_columns</code> is followed. </li> <li><code>buf</code> (writable buffer, defaults to sys.stdout) \u2014 Where to send the output. By default, the output is printed tosys.stdout. Pass a writable buffer if you need to further process the output. </li> <li><code>max_cols</code> (int, optional) \u2014 When to switch from the verbose to the truncated output. If theDataFrame has more than <code>max_cols</code> columns, the truncated output is used. By default, the setting in <code>pandas.options.display.max_info_columns</code> is used. </li> <li><code>memory_usage</code> (bool, str, optional) \u2014 Specifies whether total memory usage of the DataFrameelements (including the index) should be displayed. By default, this follows the <code>pandas.options.display.memory_usage</code> setting. True always show memory usage. False never shows memory usage. A value of 'deep' is equivalent to \"True with deep introspection\". Memory usage is shown in human-readable units (base-2 representation). Without deep introspection a memory estimation is made based in column dtype and number of rows assuming values consume the same memory amount for corresponding dtypes. With deep memory introspection, a real memory usage calculation is performed at the cost of computational resources. See the :ref:<code>Frequently Asked Questions &lt;df-memory-usage&gt;</code> for more details. </li> <li><code>show_counts</code> (bool, optional) \u2014 Whether to show the non-null counts. By default, this is shownonly if the DataFrame is smaller than <code>pandas.options.display.max_info_rows</code> and <code>pandas.options.display.max_info_columns</code>. A value of True always shows the counts, and False never shows the counts. </li> </ul> Returns (None) <p>This method prints a summary of a DataFrame and returns None.</p> See Also <p>DataFrame.describe: Generate descriptive statistics of DataFrame    columns. DataFrame.memory_usage: Memory usage of DataFrame columns.</p> Examples <pre><code>&gt;&gt;&gt; int_values = [1, 2, 3, 4, 5]&gt;&gt;&gt; text_values = ['alpha', 'beta', 'gamma', 'delta', 'epsilon']\n&gt;&gt;&gt; float_values = [0.0, 0.25, 0.5, 0.75, 1.0]\n&gt;&gt;&gt; df = pd.DataFrame({\"int_col\": int_values, \"text_col\": text_values,\n...                   \"float_col\": float_values})\n&gt;&gt;&gt; df\n    int_col text_col  float_col\n0        1    alpha       0.00\n1        2     beta       0.25\n2        3    gamma       0.50\n3        4    delta       0.75\n4        5  epsilon       1.00\n</code></pre> <p>Prints information of all columns:</p> <pre><code>&gt;&gt;&gt; df.info(verbose=True)\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 5 entries, 0 to 4\nData columns (total 3 columns):\n #   Column     Non-Null Count  Dtype\n---  ------     --------------  -----\n 0   int_col    5 non-null      int64\n 1   text_col   5 non-null      object\n 2   float_col  5 non-null      float64\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 248.0+ bytes\n</code></pre> <p>Prints a summary of columns count and its dtypes but not per column information:</p> <pre><code>&gt;&gt;&gt; df.info(verbose=False)\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 5 entries, 0 to 4\nColumns: 3 entries, int_col to float_col\ndtypes: float64(1), int64(1), object(1)\nmemory usage: 248.0+ bytes\n</code></pre> <p>Pipe output of DataFrame.info to buffer instead of sys.stdout, get buffer content and writes to a text file:</p> <pre><code>&gt;&gt;&gt; import io\n&gt;&gt;&gt; buffer = io.StringIO()\n&gt;&gt;&gt; df.info(buf=buffer)\n&gt;&gt;&gt; s = buffer.getvalue()\n&gt;&gt;&gt; with open(\"df_info.txt\", \"w\",\n...           encoding=\"utf-8\") as f:  # doctest: +SKIP\n...     f.write(s)\n260\n</code></pre> <p>The <code>memory_usage</code> parameter allows deep introspection mode, specially useful for big DataFrames and fine-tune memory optimization:</p> <pre><code>&gt;&gt;&gt; random_strings_array = np.random.choice(['a', 'b', 'c'], 10 ** 6)\n&gt;&gt;&gt; df = pd.DataFrame({\n...     'column_1': np.random.choice(['a', 'b', 'c'], 10 ** 6),\n...     'column_2': np.random.choice(['a', 'b', 'c'], 10 ** 6),\n...     'column_3': np.random.choice(['a', 'b', 'c'], 10 ** 6)\n... })\n&gt;&gt;&gt; df.info()\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1000000 entries, 0 to 999999\nData columns (total 3 columns):\n #   Column    Non-Null Count    Dtype\n---  ------    --------------    -----\n 0   column_1  1000000 non-null  object\n 1   column_2  1000000 non-null  object\n 2   column_3  1000000 non-null  object\ndtypes: object(3)\nmemory usage: 22.9+ MB\n</code></pre> <pre><code>&gt;&gt;&gt; df.info(memory_usage='deep')\n&lt;class 'pandas.core.frame.DataFrame'&gt;\nRangeIndex: 1000000 entries, 0 to 999999\nData columns (total 3 columns):\n #   Column    Non-Null Count    Dtype\n---  ------    --------------    -----\n 0   column_1  1000000 non-null  object\n 1   column_2  1000000 non-null  object\n 2   column_3  1000000 non-null  object\ndtypes: object(3)\nmemory usage: 165.9 MB\n</code></pre> method &lt;/&gt; <p>Return the memory usage of each column in bytes.</p><p>The memory usage can optionally include the contribution of the index and elements of <code>object</code> dtype.</p> <p>This value is displayed in <code>DataFrame.info</code> by default. This can be suppressed by setting <code>pandas.options.display.memory_usage</code> to False.</p> Parameters <ul> <li><code>index</code> (bool, default True) \u2014 Specifies whether to include the memory usage of the DataFrame'sindex in returned Series. If <code>index=True</code>, the memory usage of the index is the first item in the output. </li> <li><code>deep</code> (bool, default False) \u2014 If True, introspect the data deeply by interrogating<code>object</code> dtypes for system-level memory consumption, and include it in the returned values. </li> </ul> Returns (Series) <p>A Series whose index is the original column names and whose valuesis the memory usage of each column in bytes.</p> See Also <p>numpy.ndarray.nbytes : Total bytes consumed by the elements of an    ndarray. Series.memory_usage : Bytes consumed by a Series. Categorical : Memory-efficient array for string values with     many repeated values. DataFrame.info : Concise summary of a DataFrame.</p> <p>Notes</p> <p>See the :ref:<code>Frequently Asked Questions &lt;df-memory-usage&gt;</code> for more details.</p> Examples <pre><code>&gt;&gt;&gt; dtypes = ['int64', 'float64', 'complex128', 'object', 'bool']&gt;&gt;&gt; data = dict([(t, np.ones(shape=5000, dtype=int).astype(t))\n...              for t in dtypes])\n&gt;&gt;&gt; df = pd.DataFrame(data)\n&gt;&gt;&gt; df.head()\n   int64  float64            complex128  object  bool\n0      1      1.0              1.0+0.0j       1  True\n1      1      1.0              1.0+0.0j       1  True\n2      1      1.0              1.0+0.0j       1  True\n3      1      1.0              1.0+0.0j       1  True\n4      1      1.0              1.0+0.0j       1  True\n</code></pre> <pre><code>&gt;&gt;&gt; df.memory_usage()\nIndex           128\nint64         40000\nfloat64       40000\ncomplex128    80000\nobject        40000\nbool           5000\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.memory_usage(index=False)\nint64         40000\nfloat64       40000\ncomplex128    80000\nobject        40000\nbool           5000\ndtype: int64\n</code></pre> <p>The memory footprint of <code>object</code> dtype columns is ignored by default:</p> <pre><code>&gt;&gt;&gt; df.memory_usage(deep=True)\nIndex            128\nint64          40000\nfloat64        40000\ncomplex128     80000\nobject        180000\nbool            5000\ndtype: int64\n</code></pre> <p>Use a Categorical for efficient storage of an object-dtype column with many repeated values.</p> <pre><code>&gt;&gt;&gt; df['object'].astype('category').memory_usage(deep=True)\n5244\n</code></pre> method &lt;/&gt; <p>Transpose index and columns.</p><p>Reflect the DataFrame over its main diagonal by writing rows as columns and vice-versa. The property :attr:<code>.T</code> is an accessor to the method :meth:<code>transpose</code>.</p> Parameters <ul> <li><code>*args</code> (tuple, optional) \u2014 Accepted for compatibility with NumPy.</li> <li><code>copy</code> (bool, default False) \u2014 Whether to copy the data after transposing, even for DataFrameswith a single dtype. Note that a copy is always required for mixed dtype DataFrames, or for DataFrames with any extension types. .. note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> </ul> Returns (DataFrame) <p>The transposed DataFrame.</p> See Also <p>numpy.transpose : Permute the dimensions of a given array.</p> <p>Notes</p> <p>Transposing a DataFrame with mixed dtypes will result in a homogeneous DataFrame with the <code>object</code> dtype. In such a case, a copy of the data is always made.</p> Examples <p>Square DataFrame with homogeneous dtype</p><pre><code>&gt;&gt;&gt; d1 = {'col1': [1, 2], 'col2': [3, 4]}\n&gt;&gt;&gt; df1 = pd.DataFrame(data=d1)\n&gt;&gt;&gt; df1\n   col1  col2\n0     1     3\n1     2     4\n</code></pre> <pre><code>&gt;&gt;&gt; df1_transposed = df1.T  # or df1.transpose()\n&gt;&gt;&gt; df1_transposed\n      0  1\ncol1  1  2\ncol2  3  4\n</code></pre> <p>When the dtype is homogeneous in the original DataFrame, we get a transposed DataFrame with the same dtype:</p> <pre><code>&gt;&gt;&gt; df1.dtypes\ncol1    int64\ncol2    int64\ndtype: object\n&gt;&gt;&gt; df1_transposed.dtypes\n0    int64\n1    int64\ndtype: object\n</code></pre> <p>Non-square DataFrame with mixed dtypes</p> <pre><code>&gt;&gt;&gt; d2 = {'name': ['Alice', 'Bob'],\n...       'score': [9.5, 8],\n...       'employed': [False, True],\n...       'kids': [0, 0]}\n&gt;&gt;&gt; df2 = pd.DataFrame(data=d2)\n&gt;&gt;&gt; df2\n    name  score  employed  kids\n0  Alice    9.5     False     0\n1    Bob    8.0      True     0\n</code></pre> <pre><code>&gt;&gt;&gt; df2_transposed = df2.T  # or df2.transpose()\n&gt;&gt;&gt; df2_transposed\n              0     1\nname      Alice   Bob\nscore       9.5   8.0\nemployed  False  True\nkids          0     0\n</code></pre> <p>When the DataFrame has mixed dtypes, we get a transposed DataFrame with the <code>object</code> dtype:</p> <pre><code>&gt;&gt;&gt; df2.dtypes\nname         object\nscore       float64\nemployed       bool\nkids          int64\ndtype: object\n&gt;&gt;&gt; df2_transposed.dtypes\n0    object\n1    object\ndtype: object\n</code></pre> method &lt;/&gt; <p>Set the given value in the column with position <code>loc</code>.</p><p>This is a positional analogue to <code>__setitem__</code>.</p> Parameters <ul> <li><code>loc</code> (int or sequence of ints) \u2014 Index position for the column.</li> <li><code>value</code> (scalar or arraylike) \u2014 Value(s) for the column.</li> </ul> <p>Notes</p> <p><code>frame.isetitem(loc, value)</code> is an in-place method as it will modify the DataFrame in place (not returning a new object). In contrast to <code>frame.iloc[:, i] = value</code> which will try to update the existing values in place, <code>frame.isetitem(loc, value)</code> will not update the values of the column itself in place, it will instead insert a new array.</p> <p>In cases where <code>frame.columns</code> is unique, this is equivalent to <code>frame[frame.columns[i]] = value</code>.</p> method &lt;/&gt; <p>Query the columns of a DataFrame with a boolean expression.</p> Parameters <ul> <li><code>expr</code> (str) \u2014 The query string to evaluate.You can refer to variables in the environment by prefixing them with an '@' character like <code>@a + b</code>. You can refer to column names that are not valid Python variable names by surrounding them in backticks. Thus, column names containing spaces or punctuations (besides underscores) or starting with digits must be surrounded by backticks. (For example, a column named \"Area (cm^2)\" would be referenced as <code>Area (cm^2)</code>). Column names which are Python keywords (like \"list\", \"for\", \"import\", etc) cannot be used. For example, if one of your columns is called <code>a a</code> and you want to sum it with <code>b</code>, your query should be <code>`a a` + b</code>. </li> <li><code>inplace</code> (bool) \u2014 Whether to modify the DataFrame rather than creating a new one.</li> <li><code>**kwargs</code> \u2014 See the documentation for :func:<code>eval</code> for complete detailson the keyword arguments accepted by :meth:<code>DataFrame.query</code>. </li> </ul> Returns (DataFrame or None) <p>DataFrame resulting from the provided query expression orNone if <code>inplace=True</code>.</p> See Also <p>eval : Evaluate a string describing operations on    DataFrame columns. DataFrame.eval : Evaluate a string describing operations on     DataFrame columns.</p> <p>Notes</p> <p>The result of the evaluation of this expression is first passed to :attr:<code>DataFrame.loc</code> and if that fails because of a multidimensional key (e.g., a DataFrame) then the result will be passed to :meth:<code>DataFrame.__getitem__</code>.</p> <p>This method uses the top-level :func:<code>eval</code> function to evaluate the passed query.</p> <p>The :meth:<code>~pandas.DataFrame.query</code> method uses a slightly modified Python syntax by default. For example, the <code>&amp;</code> and <code>|</code> (bitwise) operators have the precedence of their boolean cousins, :keyword:<code>and</code> and :keyword:<code>or</code>. This is syntactically valid Python, however the semantics are different.</p> <p>You can change the semantics of the expression by passing the keyword argument <code>parser='python'</code>. This enforces the same semantics as evaluation in Python space. Likewise, you can pass <code>engine='python'</code> to evaluate an expression using Python itself as a backend. This is not recommended as it is inefficient compared to using <code>numexpr</code> as the engine.</p> <p>The :attr:<code>DataFrame.index</code> and :attr:<code>DataFrame.columns</code> attributes of the :class:<code>~pandas.DataFrame</code> instance are placed in the query namespace by default, which allows you to treat both the index and columns of the frame as a column in the frame. The identifier <code>index</code> is used for the frame index; you can also use the name of the index to identify it in a query. Please note that Python keywords may not be used as identifiers.</p> <p>For further details and examples see the <code>query</code> documentation in :ref:<code>indexing &lt;indexing.query&gt;</code>.</p> <p>Backtick quoted variables</p> <p>Backtick quoted variables are parsed as literal Python code and are converted internally to a Python valid identifier. This can lead to the following problems.</p> <p>During parsing a number of disallowed characters inside the backtick quoted string are replaced by strings that are allowed as a Python identifier. These characters include all operators in Python, the space character, the question mark, the exclamation mark, the dollar sign, and the euro sign. For other characters that fall outside the ASCII range (U+0001..U+007F) and those that are not further specified in PEP 3131, the query parser will raise an error. This excludes whitespace different than the space character, but also the hashtag (as it is used for comments) and the backtick itself (backtick can also not be escaped).</p> <p>In a special case, quotes that make a pair around a backtick can confuse the parser. For example, <code>it's` &gt; `that's</code> will raise an error, as it forms a quoted string (<code>'s &gt; `that'</code>) with a backtick inside.</p> <p>See also the Python documentation about lexical analysis (https://docs.python.org/3/reference/lexical_analysis.html) in combination with the source code in :mod:<code>pandas.core.computation.parsing</code>.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': range(1, 6),...                    'B': range(10, 0, -2),\n...                    'C C': range(10, 5, -1)})\n&gt;&gt;&gt; df\n   A   B  C C\n0  1  10   10\n1  2   8    9\n2  3   6    8\n3  4   4    7\n4  5   2    6\n&gt;&gt;&gt; df.query('A &gt; B')\n   A  B  C C\n4  5  2    6\n</code></pre> <p>The previous expression is equivalent to</p> <pre><code>&gt;&gt;&gt; df[df.A &gt; df.B]\n   A  B  C C\n4  5  2    6\n</code></pre> <p>For columns with spaces in their name, you can use backtick quoting.</p> <pre><code>&gt;&gt;&gt; df.query('B == `C C`')\n   A   B  C C\n0  1  10   10\n</code></pre> <p>The previous expression is equivalent to</p> <pre><code>&gt;&gt;&gt; df[df.B == df['C C']]\n   A   B  C C\n0  1  10   10\n</code></pre> method &lt;/&gt; <p>Evaluate a string describing operations on DataFrame columns.</p><p>Operates on columns only, not specific rows or elements.  This allows <code>eval</code> to run arbitrary code, which can make you vulnerable to code injection if you pass user input to this function.</p> Parameters <ul> <li><code>expr</code> (str) \u2014 The expression string to evaluate.</li> <li><code>inplace</code> (bool, default False) \u2014 If the expression contains an assignment, whether to perform theoperation inplace and mutate the existing DataFrame. Otherwise, a new DataFrame is returned. </li> <li><code>**kwargs</code> \u2014 See the documentation for :func:<code>eval</code> for complete detailson the keyword arguments accepted by :meth:<code>~pandas.DataFrame.query</code>. </li> </ul> Returns (ndarray, scalar, pandas object, or None) <p>The result of the evaluation or None if <code>inplace=True</code>.</p> See Also <p>DataFrame.query : Evaluates a boolean expression to query the columns    of a frame. DataFrame.assign : Can evaluate an expression or function to create new     values for a column. eval : Evaluate a Python expression as a string using various     backends.</p> <p>Notes</p> <p>For more details see the API documentation for :func:<code>~eval</code>. For detailed examples see :ref:<code>enhancing performance with eval &lt;enhancingperf.eval&gt;</code>.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': range(1, 6), 'B': range(10, 0, -2)})&gt;&gt;&gt; df\n   A   B\n0  1  10\n1  2   8\n2  3   6\n3  4   4\n4  5   2\n&gt;&gt;&gt; df.eval('A + B')\n0    11\n1    10\n2     9\n3     8\n4     7\ndtype: int64\n</code></pre> <p>Assignment is allowed though by default the original DataFrame is not modified.</p> <pre><code>&gt;&gt;&gt; df.eval('C = A + B')\n   A   B   C\n0  1  10  11\n1  2   8  10\n2  3   6   9\n3  4   4   8\n4  5   2   7\n&gt;&gt;&gt; df\n   A   B\n0  1  10\n1  2   8\n2  3   6\n3  4   4\n4  5   2\n</code></pre> <p>Multiple columns can be assigned to using multi-line expressions:</p> <pre><code>&gt;&gt;&gt; df.eval(\n...     '''\n... C = A + B\n... D = A - B\n... '''\n... )\n   A   B   C  D\n0  1  10  11 -9\n1  2   8  10 -6\n2  3   6   9 -3\n3  4   4   8  0\n4  5   2   7  3\n</code></pre> method &lt;/&gt; <p>Return a subset of the DataFrame's columns based on the column dtypes.</p> Returns (DataFrame) <p>The subset of the frame including the dtypes in <code>include</code> andexcluding the dtypes in <code>exclude</code>.</p> Raises <ul> <li><code>ValueError</code> \u2014 <ul><li>If both of <code>include</code> and <code>exclude</code> are empty</li> <li>If <code>include</code> and <code>exclude</code> have overlapping elements</li> <li>If any kind of string dtype is passed in.</li> </ul> </li> </ul> See Also <p>DataFrame.dtypes: Return Series with the data type of each column.</p> <p>Notes</p> <ul> <li>To select all numeric types, use <code>np.number</code> or <code>'number'</code></li> <li>To select strings you must use the <code>object</code> dtype, but note that   this will return all object dtype columns. With   <code>pd.options.future.infer_string</code> enabled, using <code>\"str\"</code> will   work to select all string columns.</li> <li>See the <code>numpy dtype hierarchy   &lt;https://numpy.org/doc/stable/reference/arrays.scalars.html&gt;</code>__</li> <li>To select datetimes, use <code>np.datetime64</code>, <code>'datetime'</code> or   <code>'datetime64'</code></li> <li>To select timedeltas, use <code>np.timedelta64</code>, <code>'timedelta'</code> or   <code>'timedelta64'</code></li> <li>To select Pandas categorical dtypes, use <code>'category'</code></li> <li>To select Pandas datetimetz dtypes, use <code>'datetimetz'</code>   or <code>'datetime64[ns, tz]'</code></li> </ul> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'a': [1, 2] * 3,...                    'b': [True, False] * 3,\n...                    'c': [1.0, 2.0] * 3})\n&gt;&gt;&gt; df\n        a      b  c\n0       1   True  1.0\n1       2  False  2.0\n2       1   True  1.0\n3       2  False  2.0\n4       1   True  1.0\n5       2  False  2.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.select_dtypes(include='bool')\n   b\n0  True\n1  False\n2  True\n3  False\n4  True\n5  False\n</code></pre> <pre><code>&gt;&gt;&gt; df.select_dtypes(include=['float64'])\n   c\n0  1.0\n1  2.0\n2  1.0\n3  2.0\n4  1.0\n5  2.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.select_dtypes(exclude=['int64'])\n       b    c\n0   True  1.0\n1  False  2.0\n2   True  1.0\n3  False  2.0\n4   True  1.0\n5  False  2.0\n</code></pre> method &lt;/&gt; <p>Insert column into DataFrame at specified location.</p><p>Raises a ValueError if <code>column</code> is already contained in the DataFrame, unless <code>allow_duplicates</code> is set to True.</p> Parameters <ul> <li><code>loc</code> (int) \u2014 Insertion index. Must verify 0 &lt;= loc &lt;= len(columns).</li> <li><code>column</code> (str, number, or hashable object) \u2014 Label of the inserted column.</li> <li><code>value</code> (Scalar, Series, or array-like) \u2014 Content of the inserted column.</li> <li><code>allow_duplicates</code> (bool, optional, default lib.no_default) \u2014 Allow duplicate column labels to be created.</li> </ul> See Also <p>Index.insert : Insert new item by index.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'col1': [1, 2], 'col2': [3, 4]})&gt;&gt;&gt; df\n   col1  col2\n0     1     3\n1     2     4\n&gt;&gt;&gt; df.insert(1, \"newcol\", [99, 99])\n&gt;&gt;&gt; df\n   col1  newcol  col2\n0     1      99     3\n1     2      99     4\n&gt;&gt;&gt; df.insert(0, \"col1\", [100, 100], allow_duplicates=True)\n&gt;&gt;&gt; df\n   col1  col1  newcol  col2\n0   100     1      99     3\n1   100     2      99     4\n</code></pre> <p>Notice that pandas uses index alignment in case of <code>value</code> from type <code>Series</code>:</p> <pre><code>&gt;&gt;&gt; df.insert(0, \"col0\", pd.Series([5, 6], index=[1, 2]))\n&gt;&gt;&gt; df\n   col0  col1  col1  newcol  col2\n0   NaN   100     1      99     3\n1   5.0   100     2      99     4\n</code></pre> method &lt;/&gt; <p>Assign new columns to a DataFrame.</p><p>Returns a new object with all original columns in addition to new ones. Existing columns that are re-assigned will be overwritten.</p> Parameters <ul> <li><code>**kwargs</code> (dict of {str: callable or Series}) \u2014 The column names are keywords. If the values arecallable, they are computed on the DataFrame and assigned to the new columns. The callable must not change input DataFrame (though pandas doesn't check it). If the values are not callable, (e.g. a Series, scalar, or array), they are simply assigned. </li> </ul> Returns (DataFrame) <p>A new DataFrame with the new columns in addition toall the existing columns.</p> <p>Notes</p> <p>Assigning multiple columns within the same <code>assign</code> is possible. Later items in '**kwargs' may refer to newly created or modified columns in 'df'; items are computed and assigned into 'df' in order.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'temp_c': [17.0, 25.0]},...                   index=['Portland', 'Berkeley'])\n&gt;&gt;&gt; df\n          temp_c\nPortland    17.0\nBerkeley    25.0\n</code></pre> <p>Where the value is a callable, evaluated on <code>df</code>:</p> <pre><code>&gt;&gt;&gt; df.assign(temp_f=lambda x: x.temp_c * 9 / 5 + 32)\n          temp_c  temp_f\nPortland    17.0    62.6\nBerkeley    25.0    77.0\n</code></pre> <p>Alternatively, the same behavior can be achieved by directly referencing an existing Series or sequence:</p> <pre><code>&gt;&gt;&gt; df.assign(temp_f=df['temp_c'] * 9 / 5 + 32)\n          temp_c  temp_f\nPortland    17.0    62.6\nBerkeley    25.0    77.0\n</code></pre> <p>You can create multiple columns within the same assign where one of the columns depends on another one defined within the same assign:</p> <pre><code>&gt;&gt;&gt; df.assign(temp_f=lambda x: x['temp_c'] * 9 / 5 + 32,\n...           temp_k=lambda x: (x['temp_f'] + 459.67) * 5 / 9)\n          temp_c  temp_f  temp_k\nPortland    17.0    62.6  290.15\nBerkeley    25.0    77.0  298.15\n</code></pre> method &lt;/&gt; <p>Assign desired index to given axis.</p><p>Indexes for column or row labels can be changed by assigning a list-like or Index.</p> Parameters <ul> <li><code>labels</code> (list-like, Index) \u2014 The values for the new index.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to update. The value 0 identifies the rows. For <code>Series</code>this parameter is unused and defaults to 0. </li> <li><code>copy</code> (bool, default True) \u2014 Whether to make a copy of the underlying data... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> </ul> Returns (DataFrame) <p>An object of type DataFrame.</p> See Also <p>DataFrame.renameaxis : Alter the name of the index or columns.</p><pre><code>    Examples\n    --------\n</code></pre> <p>~~~python</p> <p>df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]}) ~~~</p> <pre><code>    Change the row labels.\n</code></pre> <pre><code>&gt;&gt;&gt; df.set_axis(['a', 'b', 'c'], axis='index')\n   A  B\na  1  4\nb  2  5\nc  3  6\n</code></pre> <pre><code>    Change the column labels.\n</code></pre> <pre><code>&gt;&gt;&gt; df.set_axis(['I', 'II'], axis='columns')\n   I  II\n0  1   4\n1  2   5\n2  3   6\n</code></pre> method &lt;/&gt; <p>Conform DataFrame to new index with optional filling logic.</p><p>Places NA/NaN in locations having no value in the previous index. A new object is produced unless the new index is equivalent to the current one and <code>copy=False</code>.</p> See Also <p>DataFrame.set_index : Set row labels.DataFrame.reset_index : Remove row labels or move them to new columns. DataFrame.reindexlike : Change to same indices as other DataFrame.</p> Examples <p><code>DataFrame.reindex</code> supports two calling conventions</p><ul> <li><code>(index=index_labels, columns=column_labels, ...)</code></li> <li><code>(labels, axis={'index', 'columns'}, ...)</code></li> </ul> <p>We highly recommend using keyword arguments to clarify your intent.</p> <p>Create a dataframe with some fictional data.</p> <pre><code>&gt;&gt;&gt; index = ['Firefox', 'Chrome', 'Safari', 'IE10', 'Konqueror']\n&gt;&gt;&gt; df = pd.DataFrame({'http_status': [200, 200, 404, 404, 301],\n...                   'response_time': [0.04, 0.02, 0.07, 0.08, 1.0]},\n...                   index=index)\n&gt;&gt;&gt; df\n           http_status  response_time\nFirefox            200           0.04\nChrome             200           0.02\nSafari             404           0.07\nIE10               404           0.08\nKonqueror          301           1.00\n</code></pre> <p>Create a new index and reindex the dataframe. By default values in the new index that do not have corresponding records in the dataframe are assigned <code>NaN</code>.</p> <pre><code>&gt;&gt;&gt; new_index = ['Safari', 'Iceweasel', 'Comodo Dragon', 'IE10',\n...              'Chrome']\n&gt;&gt;&gt; df.reindex(new_index)\n               http_status  response_time\nSafari               404.0           0.07\nIceweasel              NaN            NaN\nComodo Dragon          NaN            NaN\nIE10                 404.0           0.08\nChrome               200.0           0.02\n</code></pre> <p>We can fill in the missing values by passing a value to the keyword <code>fill_value</code>. Because the index is not monotonically increasing or decreasing, we cannot use arguments to the keyword <code>method</code> to fill the <code>NaN</code> values.</p> <pre><code>&gt;&gt;&gt; df.reindex(new_index, fill_value=0)\n               http_status  response_time\nSafari                 404           0.07\nIceweasel                0           0.00\nComodo Dragon            0           0.00\nIE10                   404           0.08\nChrome                 200           0.02\n</code></pre> <pre><code>&gt;&gt;&gt; df.reindex(new_index, fill_value='missing')\n              http_status response_time\nSafari                404          0.07\nIceweasel         missing       missing\nComodo Dragon     missing       missing\nIE10                  404          0.08\nChrome                200          0.02\n</code></pre> <p>We can also reindex the columns.</p> <pre><code>&gt;&gt;&gt; df.reindex(columns=['http_status', 'user_agent'])\n           http_status  user_agent\nFirefox            200         NaN\nChrome             200         NaN\nSafari             404         NaN\nIE10               404         NaN\nKonqueror          301         NaN\n</code></pre> <p>Or we can use \"axis-style\" keyword arguments</p> <pre><code>&gt;&gt;&gt; df.reindex(['http_status', 'user_agent'], axis=\"columns\")\n           http_status  user_agent\nFirefox            200         NaN\nChrome             200         NaN\nSafari             404         NaN\nIE10               404         NaN\nKonqueror          301         NaN\n</code></pre> <p>To further illustrate the filling functionality in <code>reindex</code>, we will create a dataframe with a monotonically increasing index (for example, a sequence of dates).</p> <pre><code>&gt;&gt;&gt; date_index = pd.date_range('1/1/2010', periods=6, freq='D')\n&gt;&gt;&gt; df2 = pd.DataFrame({\"prices\": [100, 101, np.nan, 100, 89, 88]},\n...                    index=date_index)\n&gt;&gt;&gt; df2\n            prices\n2010-01-01   100.0\n2010-01-02   101.0\n2010-01-03     NaN\n2010-01-04   100.0\n2010-01-05    89.0\n2010-01-06    88.0\n</code></pre> <p>Suppose we decide to expand the dataframe to cover a wider date range.</p> <pre><code>&gt;&gt;&gt; date_index2 = pd.date_range('12/29/2009', periods=10, freq='D')\n&gt;&gt;&gt; df2.reindex(date_index2)\n            prices\n2009-12-29     NaN\n2009-12-30     NaN\n2009-12-31     NaN\n2010-01-01   100.0\n2010-01-02   101.0\n2010-01-03     NaN\n2010-01-04   100.0\n2010-01-05    89.0\n2010-01-06    88.0\n2010-01-07     NaN\n</code></pre> <p>The index entries that did not have a value in the original data frame (for example, '2009-12-29') are by default filled with <code>NaN</code>. If desired, we can fill in the missing values using one of several options.</p> <p>For example, to back-propagate the last valid value to fill the <code>NaN</code> values, pass <code>bfill</code> as an argument to the <code>method</code> keyword.</p> <pre><code>&gt;&gt;&gt; df2.reindex(date_index2, method='bfill')\n            prices\n2009-12-29   100.0\n2009-12-30   100.0\n2009-12-31   100.0\n2010-01-01   100.0\n2010-01-02   101.0\n2010-01-03     NaN\n2010-01-04   100.0\n2010-01-05    89.0\n2010-01-06    88.0\n2010-01-07     NaN\n</code></pre> <p>Please note that the <code>NaN</code> value present in the original dataframe (at index value 2010-01-03) will not be filled by any of the value propagation schemes. This is because filling while reindexing does not look at dataframe values, but only compares the original and desired indexes. If you do want to fill in the <code>NaN</code> values present in the original dataframe, use the <code>fillna()</code> method.</p> <p>See the :ref:<code>user guide &lt;basics.reindexing&gt;</code> for more.</p> method &lt;/&gt; <p>Drop specified labels from rows or columns.</p><p>Remove rows or columns by specifying label names and corresponding axis, or by directly specifying index or column names. When using a multi-index, labels on different levels can be removed by specifying the level. See the :ref:<code>user guide &lt;advanced.shown_levels&gt;</code> for more information about the now unused levels.</p> Parameters <ul> <li><code>labels</code> (single label or list-like) \u2014 Index or column labels to drop. A tuple will be used as a singlelabel and not treated as a list-like. </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Whether to drop labels from the index (0 or 'index') orcolumns (1 or 'columns'). </li> <li><code>index</code> (single label or list-like) \u2014 Alternative to specifying axis (<code>labels, axis=0</code>is equivalent to <code>index=labels</code>). </li> <li><code>columns</code> (single label or list-like) \u2014 Alternative to specifying axis (<code>labels, axis=1</code>is equivalent to <code>columns=labels</code>). </li> <li><code>level</code> (int or level name, optional) \u2014 For MultiIndex, level from which the labels will be removed.</li> <li><code>inplace</code> (bool, default False) \u2014 If False, return a copy. Otherwise, do operationin place and return None. </li> <li><code>errors</code> ({'ignore', 'raise'}, default 'raise') \u2014 If 'ignore', suppress error and only existing labels aredropped. </li> </ul> Returns (DataFrame or None) <p>Returns DataFrame or None DataFrame with the specifiedindex or column labels removed or None if inplace=True.</p> Raises <ul> <li><code>KeyError</code> \u2014 If any of the labels is not found in the selected axis.</li> </ul> See Also <p>DataFrame.loc : Label-location based indexer for selection by label.DataFrame.dropna : Return DataFrame with labels on given axis omitted     where (all or any) data are missing. DataFrame.dropduplicates : Return DataFrame with duplicate rows     removed, optionally only considering certain columns. Series.drop : Return Series with specified index labels removed.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.arange(12).reshape(3, 4),...                   columns=['A', 'B', 'C', 'D'])\n&gt;&gt;&gt; df\n   A  B   C   D\n0  0  1   2   3\n1  4  5   6   7\n2  8  9  10  11\n</code></pre> <p>Drop columns</p> <pre><code>&gt;&gt;&gt; df.drop(['B', 'C'], axis=1)\n   A   D\n0  0   3\n1  4   7\n2  8  11\n</code></pre> <pre><code>&gt;&gt;&gt; df.drop(columns=['B', 'C'])\n   A   D\n0  0   3\n1  4   7\n2  8  11\n</code></pre> <p>Drop a row by index</p> <pre><code>&gt;&gt;&gt; df.drop([0, 1])\n   A  B   C   D\n2  8  9  10  11\n</code></pre> <p>Drop columns and/or rows of MultiIndex DataFrame</p> <pre><code>&gt;&gt;&gt; midx = pd.MultiIndex(levels=[['llama', 'cow', 'falcon'],\n...                              ['speed', 'weight', 'length']],\n...                      codes=[[0, 0, 0, 1, 1, 1, 2, 2, 2],\n...                             [0, 1, 2, 0, 1, 2, 0, 1, 2]])\n&gt;&gt;&gt; df = pd.DataFrame(index=midx, columns=['big', 'small'],\n...                   data=[[45, 30], [200, 100], [1.5, 1], [30, 20],\n...                         [250, 150], [1.5, 0.8], [320, 250],\n...                         [1, 0.8], [0.3, 0.2]])\n&gt;&gt;&gt; df\n                big     small\nllama   speed   45.0    30.0\n        weight  200.0   100.0\n        length  1.5     1.0\ncow     speed   30.0    20.0\n        weight  250.0   150.0\n        length  1.5     0.8\nfalcon  speed   320.0   250.0\n        weight  1.0     0.8\n        length  0.3     0.2\n</code></pre> <p>Drop a specific index combination from the MultiIndex DataFrame, i.e., drop the combination <code>'falcon'</code> and <code>'weight'</code>, which deletes only the corresponding row</p> <pre><code>&gt;&gt;&gt; df.drop(index=('falcon', 'weight'))\n                big     small\nllama   speed   45.0    30.0\n        weight  200.0   100.0\n        length  1.5     1.0\ncow     speed   30.0    20.0\n        weight  250.0   150.0\n        length  1.5     0.8\nfalcon  speed   320.0   250.0\n        length  0.3     0.2\n</code></pre> <pre><code>&gt;&gt;&gt; df.drop(index='cow', columns='small')\n                big\nllama   speed   45.0\n        weight  200.0\n        length  1.5\nfalcon  speed   320.0\n        weight  1.0\n        length  0.3\n</code></pre> <pre><code>&gt;&gt;&gt; df.drop(index='length', level=1)\n                big     small\nllama   speed   45.0    30.0\n        weight  200.0   100.0\ncow     speed   30.0    20.0\n        weight  250.0   150.0\nfalcon  speed   320.0   250.0\n        weight  1.0     0.8\n</code></pre> method &lt;/&gt; <p>Rename columns or index labels.</p><p>Function / dict values must be unique (1-to-1). Labels not contained in a dict / Series will be left as-is. Extra labels listed don't throw an error.</p> <p>See the :ref:<code>user guide &lt;basics.rename&gt;</code> for more.</p> Parameters <ul> <li><code>mapper</code> (dict-like or function) \u2014 Dict-like or function transformations to apply tothat axis' values. Use either <code>mapper</code> and <code>axis</code> to specify the axis to target with <code>mapper</code>, or <code>index</code> and <code>columns</code>. </li> <li><code>index</code> (dict-like or function) \u2014 Alternative to specifying axis (<code>mapper, axis=0</code>is equivalent to <code>index=mapper</code>). </li> <li><code>columns</code> (dict-like or function) \u2014 Alternative to specifying axis (<code>mapper, axis=1</code>is equivalent to <code>columns=mapper</code>). </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Axis to target with <code>mapper</code>. Can be either the axis name('index', 'columns') or number (0, 1). The default is 'index'. </li> <li><code>copy</code> (bool, default True) \u2014 Also copy underlying data... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> <li><code>inplace</code> (bool, default False) \u2014 Whether to modify the DataFrame rather than creating a new one.If True then value of copy is ignored. </li> <li><code>level</code> (int or level name, default None) \u2014 In case of a MultiIndex, only rename labels in the specifiedlevel. </li> <li><code>errors</code> ({'ignore', 'raise'}, default 'ignore') \u2014 If 'raise', raise a <code>KeyError</code> when a dict-like <code>mapper</code>, <code>index</code>,or <code>columns</code> contains labels that are not present in the Index being transformed. If 'ignore', existing keys will be renamed and extra keys will be ignored. </li> </ul> Returns (DataFrame or None) <p>DataFrame with the renamed axis labels or None if <code>inplace=True</code>.</p> Raises <ul> <li><code>KeyError</code> \u2014 If any of the labels is not found in the selected axis and\"errors='raise'\". </li> </ul> See Also <p>DataFrame.renameaxis : Set the name of the axis.</p> Examples <p><code>DataFrame.rename</code> supports two calling conventions</p><ul> <li><code>(index=index_mapper, columns=columns_mapper, ...)</code></li> <li><code>(mapper, axis={'index', 'columns'}, ...)</code></li> </ul> <p>We highly recommend using keyword arguments to clarify your intent.</p> <p>Rename columns using a mapping:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n&gt;&gt;&gt; df.rename(columns={\"A\": \"a\", \"B\": \"c\"})\n   a  c\n0  1  4\n1  2  5\n2  3  6\n</code></pre> <p>Rename index using a mapping:</p> <pre><code>&gt;&gt;&gt; df.rename(index={0: \"x\", 1: \"y\", 2: \"z\"})\n   A  B\nx  1  4\ny  2  5\nz  3  6\n</code></pre> <p>Cast index labels to a different type:</p> <pre><code>&gt;&gt;&gt; df.index\nRangeIndex(start=0, stop=3, step=1)\n&gt;&gt;&gt; df.rename(index=str).index\nIndex(['0', '1', '2'], dtype='object')\n</code></pre> <pre><code>&gt;&gt;&gt; df.rename(columns={\"A\": \"a\", \"B\": \"b\", \"C\": \"c\"}, errors=\"raise\")\nTraceback (most recent call last):\nKeyError: ['C'] not found in axis\n</code></pre> <p>Using axis-style parameters:</p> <pre><code>&gt;&gt;&gt; df.rename(str.lower, axis='columns')\n   a  b\n0  1  4\n1  2  5\n2  3  6\n</code></pre> <pre><code>&gt;&gt;&gt; df.rename({1: 2, 2: 4}, axis='index')\n   A  B\n0  1  4\n2  2  5\n4  3  6\n</code></pre> method &lt;/&gt; <p>Return item and drop from frame. Raise KeyError if not found.</p> Parameters <ul> <li><code>item</code> (label) \u2014 Label of column to be popped.</li> </ul> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([('falcon', 'bird', 389.0),...                    ('parrot', 'bird', 24.0),\n...                    ('lion', 'mammal', 80.5),\n...                    ('monkey', 'mammal', np.nan)],\n...                   columns=('name', 'class', 'max_speed'))\n&gt;&gt;&gt; df\n     name   class  max_speed\n0  falcon    bird      389.0\n1  parrot    bird       24.0\n2    lion  mammal       80.5\n3  monkey  mammal        NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.pop('class')\n0      bird\n1      bird\n2    mammal\n3    mammal\nName: class, dtype: object\n</code></pre> <pre><code>&gt;&gt;&gt; df\n     name  max_speed\n0  falcon      389.0\n1  parrot       24.0\n2    lion       80.5\n3  monkey        NaN\n</code></pre> method &lt;/&gt; <p>Shift index by desired number of periods with an optional time <code>freq</code>.</p><p>When <code>freq</code> is not passed, shift the index without realigning the data. If <code>freq</code> is passed (in this case, the index must be date or datetime, or it will raise a <code>NotImplementedError</code>), the index will be increased using the periods and the <code>freq</code>. <code>freq</code> can be inferred when specified as \"infer\" as long as either freq or inferred_freq attribute is set in the index.</p> Parameters <ul> <li><code>periods</code> (int or Sequence) \u2014 Number of periods to shift. Can be positive or negative.If an iterable of ints, the data will be shifted once by each int. This is equivalent to shifting by one value at a time and concatenating all resulting frames. The resulting columns will have the shift suffixed to their column names. For multiple periods, axis must not be 1. </li> <li><code>freq</code> (DateOffset, tseries.offsets, timedelta, or str, optional) \u2014 Offset to use from the tseries module or time rule (e.g. 'EOM').If <code>freq</code> is specified then the index values are shifted but the data is not realigned. That is, use <code>freq</code> if you would like to extend the index when shifting and preserve the original data. If <code>freq</code> is specified as \"infer\" then it will be inferred from the freq or inferred_freq attributes of the index. If neither of those attributes exist, a ValueError is thrown. </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default None) \u2014 Shift direction. For <code>Series</code> this parameter is unused and defaults to 0.</li> <li><code>fill_value</code> (object, optional) \u2014 The scalar value to use for newly introduced missing values.the default depends on the dtype of <code>self</code>. For numeric data, <code>np.nan</code> is used. For datetime, timedelta, or period data, etc. :attr:<code>NaT</code> is used. For extension dtypes, <code>self.dtype.na_value</code> is used. </li> <li><code>suffix</code> (str, optional) \u2014 If str and periods is an iterable, this is added after the columnname and before the shift value for each shifted column name. </li> </ul> Returns (DataFrame) <p>Copy of input object, shifted.</p> See Also <p>Index.shift : Shift values of Index.DatetimeIndex.shift : Shift values of DatetimeIndex. PeriodIndex.shift : Shift values of PeriodIndex.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"Col1\": [10, 20, 15, 30, 45],...                    \"Col2\": [13, 23, 18, 33, 48],\n...                    \"Col3\": [17, 27, 22, 37, 52]},\n...                   index=pd.date_range(\"2020-01-01\", \"2020-01-05\"))\n&gt;&gt;&gt; df\n            Col1  Col2  Col3\n2020-01-01    10    13    17\n2020-01-02    20    23    27\n2020-01-03    15    18    22\n2020-01-04    30    33    37\n2020-01-05    45    48    52\n</code></pre> <pre><code>&gt;&gt;&gt; df.shift(periods=3)\n            Col1  Col2  Col3\n2020-01-01   NaN   NaN   NaN\n2020-01-02   NaN   NaN   NaN\n2020-01-03   NaN   NaN   NaN\n2020-01-04  10.0  13.0  17.0\n2020-01-05  20.0  23.0  27.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.shift(periods=1, axis=\"columns\")\n            Col1  Col2  Col3\n2020-01-01   NaN    10    13\n2020-01-02   NaN    20    23\n2020-01-03   NaN    15    18\n2020-01-04   NaN    30    33\n2020-01-05   NaN    45    48\n</code></pre> <pre><code>&gt;&gt;&gt; df.shift(periods=3, fill_value=0)\n            Col1  Col2  Col3\n2020-01-01     0     0     0\n2020-01-02     0     0     0\n2020-01-03     0     0     0\n2020-01-04    10    13    17\n2020-01-05    20    23    27\n</code></pre> <pre><code>&gt;&gt;&gt; df.shift(periods=3, freq=\"D\")\n            Col1  Col2  Col3\n2020-01-04    10    13    17\n2020-01-05    20    23    27\n2020-01-06    15    18    22\n2020-01-07    30    33    37\n2020-01-08    45    48    52\n</code></pre> <pre><code>&gt;&gt;&gt; df.shift(periods=3, freq=\"infer\")\n            Col1  Col2  Col3\n2020-01-04    10    13    17\n2020-01-05    20    23    27\n2020-01-06    15    18    22\n2020-01-07    30    33    37\n2020-01-08    45    48    52\n</code></pre> <pre><code>&gt;&gt;&gt; df['Col1'].shift(periods=[0, 1, 2])\n            Col1_0  Col1_1  Col1_2\n2020-01-01      10     NaN     NaN\n2020-01-02      20    10.0     NaN\n2020-01-03      15    20.0    10.0\n2020-01-04      30    15.0    20.0\n2020-01-05      45    30.0    15.0\n</code></pre> method &lt;/&gt; <p>Set the DataFrame index using existing columns.</p><p>Set the DataFrame index (row labels) using one or more existing columns or arrays (of the correct length). The index can replace the existing index or expand on it.</p> Parameters <ul> <li><code>keys</code> (label or array-like or list of labels/arrays) \u2014 This parameter can be either a single column key, a single array ofthe same length as the calling DataFrame, or a list containing an arbitrary combination of column keys and arrays. Here, \"array\" encompasses :class:<code>Series</code>, :class:<code>Index</code>, <code>np.ndarray</code>, and instances of :class:<code>~collections.abc.Iterator</code>. </li> <li><code>drop</code> (bool, default True) \u2014 Delete columns to be used as the new index.</li> <li><code>append</code> (bool, default False) \u2014 Whether to append columns to existing index.</li> <li><code>inplace</code> (bool, default False) \u2014 Whether to modify the DataFrame rather than creating a new one.</li> <li><code>verify_integrity</code> (bool, default False) \u2014 Check the new index for duplicates. Otherwise defer the check untilnecessary. Setting to False will improve the performance of this method. </li> </ul> Returns (DataFrame or None) <p>Changed row labels or None if <code>inplace=True</code>.</p> See Also <p>DataFrame.reset_index : Opposite of set_index.DataFrame.reindex : Change to new indices or expand indices. DataFrame.reindexlike : Change to same indices as other DataFrame.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'month': [1, 4, 7, 10],...                    'year': [2012, 2014, 2013, 2014],\n...                    'sale': [55, 40, 84, 31]})\n&gt;&gt;&gt; df\n   month  year  sale\n0      1  2012    55\n1      4  2014    40\n2      7  2013    84\n3     10  2014    31\n</code></pre> <p>Set the index to become the 'month' column:</p> <pre><code>&gt;&gt;&gt; df.set_index('month')\n       year  sale\nmonth\n1      2012    55\n4      2014    40\n7      2013    84\n10     2014    31\n</code></pre> <p>Create a MultiIndex using columns 'year' and 'month':</p> <pre><code>&gt;&gt;&gt; df.set_index(['year', 'month'])\n            sale\nyear  month\n2012  1     55\n2014  4     40\n2013  7     84\n2014  10    31\n</code></pre> <p>Create a MultiIndex using an Index and a column:</p> <pre><code>&gt;&gt;&gt; df.set_index([pd.Index([1, 2, 3, 4]), 'year'])\n         month  sale\n   year\n1  2012  1      55\n2  2014  4      40\n3  2013  7      84\n4  2014  10     31\n</code></pre> <p>Create a MultiIndex using two Series:</p> <pre><code>&gt;&gt;&gt; s = pd.Series([1, 2, 3, 4])\n&gt;&gt;&gt; df.set_index([s, s**2])\n      month  year  sale\n1 1       1  2012    55\n2 4       4  2014    40\n3 9       7  2013    84\n4 16     10  2014    31\n</code></pre> method &lt;/&gt; <p>Reset the index, or a level of it.</p><p>Reset the index of the DataFrame, and use the default one instead. If the DataFrame has a MultiIndex, this method can remove one or more levels.</p> Parameters <ul> <li><code>level</code> (int, str, tuple, or list, default None) \u2014 Only remove the given levels from the index. Removes all levels bydefault. </li> <li><code>drop</code> (bool, default False) \u2014 Do not try to insert index into dataframe columns. This resetsthe index to the default integer index. </li> <li><code>inplace</code> (bool, default False) \u2014 Whether to modify the DataFrame rather than creating a new one.</li> <li><code>col_level</code> (int or str, default 0) \u2014 If the columns have multiple levels, determines which level thelabels are inserted into. By default it is inserted into the first level. </li> <li><code>col_fill</code> (object, default '') \u2014 If the columns have multiple levels, determines how the otherlevels are named. If None then the index name is repeated. </li> <li><code>allow_duplicates</code> (bool, optional, default lib.no_default) \u2014 Allow duplicate column labels to be created... versionadded:: 1.5.0 </li> <li><code>names</code> (int, str or 1-dimensional list, default None) \u2014 Using the given string, rename the DataFrame column which contains theindex data. If the DataFrame has a MultiIndex, this has to be a list or tuple with length equal to the number of levels. .. versionadded:: 1.5.0 </li> </ul> Returns (DataFrame or None) <p>DataFrame with the new index or None if <code>inplace=True</code>.</p> See Also <p>DataFrame.set_index : Opposite of reset_index.DataFrame.reindex : Change to new indices or expand indices. DataFrame.reindexlike : Change to same indices as other DataFrame.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([('bird', 389.0),...                    ('bird', 24.0),\n...                    ('mammal', 80.5),\n...                    ('mammal', np.nan)],\n...                   index=['falcon', 'parrot', 'lion', 'monkey'],\n...                   columns=('class', 'max_speed'))\n&gt;&gt;&gt; df\n         class  max_speed\nfalcon    bird      389.0\nparrot    bird       24.0\nlion    mammal       80.5\nmonkey  mammal        NaN\n</code></pre> <p>When we reset the index, the old index is added as a column, and a new sequential index is used:</p> <pre><code>&gt;&gt;&gt; df.reset_index()\n    index   class  max_speed\n0  falcon    bird      389.0\n1  parrot    bird       24.0\n2    lion  mammal       80.5\n3  monkey  mammal        NaN\n</code></pre> <p>We can use the <code>drop</code> parameter to avoid the old index being added as a column:</p> <pre><code>&gt;&gt;&gt; df.reset_index(drop=True)\n    class  max_speed\n0    bird      389.0\n1    bird       24.0\n2  mammal       80.5\n3  mammal        NaN\n</code></pre> <p>You can also use <code>reset_index</code> with <code>MultiIndex</code>.</p> <pre><code>&gt;&gt;&gt; index = pd.MultiIndex.from_tuples([('bird', 'falcon'),\n...                                    ('bird', 'parrot'),\n...                                    ('mammal', 'lion'),\n...                                    ('mammal', 'monkey')],\n...                                   names=['class', 'name'])\n&gt;&gt;&gt; columns = pd.MultiIndex.from_tuples([('speed', 'max'),\n...                                      ('species', 'type')])\n&gt;&gt;&gt; df = pd.DataFrame([(389.0, 'fly'),\n...                    (24.0, 'fly'),\n...                    (80.5, 'run'),\n...                    (np.nan, 'jump')],\n...                   index=index,\n...                   columns=columns)\n&gt;&gt;&gt; df\n               speed species\n                 max    type\nclass  name\nbird   falcon  389.0     fly\n       parrot   24.0     fly\nmammal lion     80.5     run\n       monkey    NaN    jump\n</code></pre> <p>Using the <code>names</code> parameter, choose a name for the index column:</p> <pre><code>&gt;&gt;&gt; df.reset_index(names=['classes', 'names'])\n  classes   names  speed species\n                     max    type\n0    bird  falcon  389.0     fly\n1    bird  parrot   24.0     fly\n2  mammal    lion   80.5     run\n3  mammal  monkey    NaN    jump\n</code></pre> <p>If the index has multiple levels, we can reset a subset of them:</p> <pre><code>&gt;&gt;&gt; df.reset_index(level='class')\n         class  speed species\n                  max    type\nname\nfalcon    bird  389.0     fly\nparrot    bird   24.0     fly\nlion    mammal   80.5     run\nmonkey  mammal    NaN    jump\n</code></pre> <p>If we are not dropping the index, by default, it is placed in the top level. We can place it in another level:</p> <pre><code>&gt;&gt;&gt; df.reset_index(level='class', col_level=1)\n                speed species\n         class    max    type\nname\nfalcon    bird  389.0     fly\nparrot    bird   24.0     fly\nlion    mammal   80.5     run\nmonkey  mammal    NaN    jump\n</code></pre> <p>When the index is inserted under another level, we can specify under which one with the parameter <code>col_fill</code>:</p> <pre><code>&gt;&gt;&gt; df.reset_index(level='class', col_level=1, col_fill='species')\n              species  speed species\n                class    max    type\nname\nfalcon           bird  389.0     fly\nparrot           bird   24.0     fly\nlion           mammal   80.5     run\nmonkey         mammal    NaN    jump\n</code></pre> <p>If we specify a nonexistent level for <code>col_fill</code>, it is created:</p> <pre><code>&gt;&gt;&gt; df.reset_index(level='class', col_level=1, col_fill='genus')\n                genus  speed species\n                class    max    type\nname\nfalcon           bird  389.0     fly\nparrot           bird   24.0     fly\nlion           mammal   80.5     run\nmonkey         mammal    NaN    jump\n</code></pre> method &lt;/&gt; <p>Detect missing values.</p><p>Return a boolean same-sized object indicating if the values are NA. NA values, such as None or :attr:<code>numpy.NaN</code>, gets mapped to True values. Everything else gets mapped to False values. Characters such as empty strings <code>''</code> or :attr:<code>numpy.inf</code> are not considered NA values (unless you set <code>pandas.options.mode.use_inf_as_na = True</code>).</p> Returns (DataFrame) <p>Mask of bool values for each element in DataFrame thatindicates whether an element is an NA value.</p> See Also <p>DataFrame.isnull : Alias of isna.DataFrame.notna : Boolean inverse of isna. DataFrame.dropna : Omit axes labels with missing values. isna : Top-level isna.</p> Examples <p>Show which entries in a DataFrame are NA.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp('1939-05-27'),\n...                              pd.Timestamp('1940-04-25')],\n...                        name=['Alfred', 'Batman', ''],\n...                        toy=[None, 'Batmobile', 'Joker']))\n&gt;&gt;&gt; df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker\n</code></pre> <pre><code>&gt;&gt;&gt; df.isna()\n     age   born   name    toy\n0  False   True  False   True\n1  False  False  False  False\n2   True  False  False  False\n</code></pre> <p>Show which entries in a Series are NA.</p> <pre><code>&gt;&gt;&gt; ser = pd.Series([5, 6, np.nan])\n&gt;&gt;&gt; ser\n0    5.0\n1    6.0\n2    NaN\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; ser.isna()\n0    False\n1    False\n2     True\ndtype: bool\n</code></pre> method &lt;/&gt; <p>DataFrame.isnull is an alias for DataFrame.isna.</p><p>Detect missing values.</p> <p>Return a boolean same-sized object indicating if the values are NA. NA values, such as None or :attr:<code>numpy.NaN</code>, gets mapped to True values. Everything else gets mapped to False values. Characters such as empty strings <code>''</code> or :attr:<code>numpy.inf</code> are not considered NA values (unless you set <code>pandas.options.mode.use_inf_as_na = True</code>).</p> Returns (DataFrame) <p>Mask of bool values for each element in DataFrame thatindicates whether an element is an NA value.</p> See Also <p>DataFrame.isnull : Alias of isna.DataFrame.notna : Boolean inverse of isna. DataFrame.dropna : Omit axes labels with missing values. isna : Top-level isna.</p> Examples <p>Show which entries in a DataFrame are NA.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp('1939-05-27'),\n...                              pd.Timestamp('1940-04-25')],\n...                        name=['Alfred', 'Batman', ''],\n...                        toy=[None, 'Batmobile', 'Joker']))\n&gt;&gt;&gt; df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker\n</code></pre> <pre><code>&gt;&gt;&gt; df.isna()\n     age   born   name    toy\n0  False   True  False   True\n1  False  False  False  False\n2   True  False  False  False\n</code></pre> <p>Show which entries in a Series are NA.</p> <pre><code>&gt;&gt;&gt; ser = pd.Series([5, 6, np.nan])\n&gt;&gt;&gt; ser\n0    5.0\n1    6.0\n2    NaN\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; ser.isna()\n0    False\n1    False\n2     True\ndtype: bool\n</code></pre> method &lt;/&gt; <p>Detect existing (non-missing) values.</p><p>Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to True. Characters such as empty strings <code>''</code> or :attr:<code>numpy.inf</code> are not considered NA values (unless you set <code>pandas.options.mode.use_inf_as_na = True</code>). NA values, such as None or :attr:<code>numpy.NaN</code>, get mapped to False values.</p> Returns (DataFrame) <p>Mask of bool values for each element in DataFrame thatindicates whether an element is not an NA value.</p> See Also <p>DataFrame.notnull : Alias of notna.DataFrame.isna : Boolean inverse of notna. DataFrame.dropna : Omit axes labels with missing values. notna : Top-level notna.</p> Examples <p>Show which entries in a DataFrame are not NA.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp('1939-05-27'),\n...                              pd.Timestamp('1940-04-25')],\n...                        name=['Alfred', 'Batman', ''],\n...                        toy=[None, 'Batmobile', 'Joker']))\n&gt;&gt;&gt; df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker\n</code></pre> <pre><code>&gt;&gt;&gt; df.notna()\n     age   born  name    toy\n0   True  False  True  False\n1   True   True  True   True\n2  False   True  True   True\n</code></pre> <p>Show which entries in a Series are not NA.</p> <pre><code>&gt;&gt;&gt; ser = pd.Series([5, 6, np.nan])\n&gt;&gt;&gt; ser\n0    5.0\n1    6.0\n2    NaN\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; ser.notna()\n0     True\n1     True\n2    False\ndtype: bool\n</code></pre> method &lt;/&gt; <p>DataFrame.notnull is an alias for DataFrame.notna.</p><p>Detect existing (non-missing) values.</p> <p>Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to True. Characters such as empty strings <code>''</code> or :attr:<code>numpy.inf</code> are not considered NA values (unless you set <code>pandas.options.mode.use_inf_as_na = True</code>). NA values, such as None or :attr:<code>numpy.NaN</code>, get mapped to False values.</p> Returns (DataFrame) <p>Mask of bool values for each element in DataFrame thatindicates whether an element is not an NA value.</p> See Also <p>DataFrame.notnull : Alias of notna.DataFrame.isna : Boolean inverse of notna. DataFrame.dropna : Omit axes labels with missing values. notna : Top-level notna.</p> Examples <p>Show which entries in a DataFrame are not NA.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp('1939-05-27'),\n...                              pd.Timestamp('1940-04-25')],\n...                        name=['Alfred', 'Batman', ''],\n...                        toy=[None, 'Batmobile', 'Joker']))\n&gt;&gt;&gt; df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker\n</code></pre> <pre><code>&gt;&gt;&gt; df.notna()\n     age   born  name    toy\n0   True  False  True  False\n1   True   True  True   True\n2  False   True  True   True\n</code></pre> <p>Show which entries in a Series are not NA.</p> <pre><code>&gt;&gt;&gt; ser = pd.Series([5, 6, np.nan])\n&gt;&gt;&gt; ser\n0    5.0\n1    6.0\n2    NaN\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; ser.notna()\n0     True\n1     True\n2    False\ndtype: bool\n</code></pre> method &lt;/&gt; <p>Remove missing values.</p><p>See the :ref:<code>User Guide &lt;missing_data&gt;</code> for more on which values are considered missing, and how to work with missing data.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Determine if rows or columns which contain missing values areremoved. <ul> <li>0, or 'index' : Drop rows which contain missing values.</li> <li>1, or 'columns' : Drop columns which contain missing value.</li> </ul> Only a single axis is allowed. </li> <li><code>how</code> ({'any', 'all'}, default 'any') \u2014 Determine if row or column is removed from DataFrame, when we haveat least one NA or all NA. <ul> <li>'any' : If any NA values are present, drop that row or column.</li> <li>'all' : If all values are NA, drop that row or column.</li> </ul> </li> <li><code>thresh</code> (int, optional) \u2014 Require that many non-NA values. Cannot be combined with how.</li> <li><code>subset</code> (column label or sequence of labels, optional) \u2014 Labels along other axis to consider, e.g. if you are dropping rowsthese would be a list of columns to include. </li> <li><code>inplace</code> (bool, default False) \u2014 Whether to modify the DataFrame rather than creating a new one.</li> <li><code>ignore_index</code> (bool, default ``False``) \u2014 If <code>True</code>, the resulting axis will be labeled 0, 1, \u2026, n - 1... versionadded:: 2.0.0 </li> </ul> Returns (DataFrame or None) <p>DataFrame with NA entries dropped from it or None if <code>inplace=True</code>.</p> See Also <p>DataFrame.isna: Indicate missing values.DataFrame.notna : Indicate existing (non-missing) values. DataFrame.fillna : Replace missing values. Series.dropna : Drop missing values. Index.dropna : Drop missing indices.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"name\": ['Alfred', 'Batman', 'Catwoman'],...                    \"toy\": [np.nan, 'Batmobile', 'Bullwhip'],\n...                    \"born\": [pd.NaT, pd.Timestamp(\"1940-04-25\"),\n...                             pd.NaT]})\n&gt;&gt;&gt; df\n       name        toy       born\n0    Alfred        NaN        NaT\n1    Batman  Batmobile 1940-04-25\n2  Catwoman   Bullwhip        NaT\n</code></pre> <p>Drop the rows where at least one element is missing.</p> <pre><code>&gt;&gt;&gt; df.dropna()\n     name        toy       born\n1  Batman  Batmobile 1940-04-25\n</code></pre> <p>Drop the columns where at least one element is missing.</p> <pre><code>&gt;&gt;&gt; df.dropna(axis='columns')\n       name\n0    Alfred\n1    Batman\n2  Catwoman\n</code></pre> <p>Drop the rows where all elements are missing.</p> <pre><code>&gt;&gt;&gt; df.dropna(how='all')\n       name        toy       born\n0    Alfred        NaN        NaT\n1    Batman  Batmobile 1940-04-25\n2  Catwoman   Bullwhip        NaT\n</code></pre> <p>Keep only the rows with at least 2 non-NA values.</p> <pre><code>&gt;&gt;&gt; df.dropna(thresh=2)\n       name        toy       born\n1    Batman  Batmobile 1940-04-25\n2  Catwoman   Bullwhip        NaT\n</code></pre> <p>Define in which columns to look for missing values.</p> <pre><code>&gt;&gt;&gt; df.dropna(subset=['name', 'toy'])\n       name        toy       born\n1    Batman  Batmobile 1940-04-25\n2  Catwoman   Bullwhip        NaT\n</code></pre> method &lt;/&gt; <p>Return DataFrame with duplicate rows removed.</p><p>Considering certain columns is optional. Indexes, including time indexes are ignored.</p> Parameters <ul> <li><code>subset</code> (column label or sequence of labels, optional) \u2014 Only consider certain columns for identifying duplicates, bydefault use all of the columns. </li> <li><code>keep</code> ({'first', 'last', ``False``}, default 'first') \u2014 Determines which duplicates (if any) to keep.<ul> <li>'first' : Drop duplicates except for the first occurrence.</li> <li>'last' : Drop duplicates except for the last occurrence.</li> <li><code>False</code> : Drop all duplicates.</li> </ul> </li> <li><code>inplace</code> (bool, default ``False``) \u2014 Whether to modify the DataFrame rather than creating a new one.</li> <li><code>ignore_index</code> (bool, default ``False``) \u2014 If <code>True</code>, the resulting axis will be labeled 0, 1, \u2026, n - 1.</li> </ul> Returns (DataFrame or None) <p>DataFrame with duplicates removed or None if <code>inplace=True</code>.</p> See Also <p>DataFrame.value_counts: Count unique combinations of columns.</p> Examples <p>Consider dataset containing ramen rating.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'brand': ['Yum Yum', 'Yum Yum', 'Indomie', 'Indomie', 'Indomie'],\n...     'style': ['cup', 'cup', 'cup', 'pack', 'pack'],\n...     'rating': [4, 4, 3.5, 15, 5]\n... })\n&gt;&gt;&gt; df\n    brand style  rating\n0  Yum Yum   cup     4.0\n1  Yum Yum   cup     4.0\n2  Indomie   cup     3.5\n3  Indomie  pack    15.0\n4  Indomie  pack     5.0\n</code></pre> <p>By default, it removes duplicate rows based on all columns.</p> <pre><code>&gt;&gt;&gt; df.drop_duplicates()\n    brand style  rating\n0  Yum Yum   cup     4.0\n2  Indomie   cup     3.5\n3  Indomie  pack    15.0\n4  Indomie  pack     5.0\n</code></pre> <p>To remove duplicates on specific column(s), use <code>subset</code>.</p> <pre><code>&gt;&gt;&gt; df.drop_duplicates(subset=['brand'])\n    brand style  rating\n0  Yum Yum   cup     4.0\n2  Indomie   cup     3.5\n</code></pre> <p>To remove duplicates and keep last occurrences, use <code>keep</code>.</p> <pre><code>&gt;&gt;&gt; df.drop_duplicates(subset=['brand', 'style'], keep='last')\n    brand style  rating\n1  Yum Yum   cup     4.0\n2  Indomie   cup     3.5\n4  Indomie  pack     5.0\n</code></pre> method &lt;/&gt; <p>Return boolean Series denoting duplicate rows.</p><p>Considering certain columns is optional.</p> Parameters <ul> <li><code>subset</code> (column label or sequence of labels, optional) \u2014 Only consider certain columns for identifying duplicates, bydefault use all of the columns. </li> <li><code>keep</code> ({'first', 'last', False}, default 'first') \u2014 Determines which duplicates (if any) to mark.<ul> <li><code>first</code> : Mark duplicates as <code>True</code> except for the first occurrence.</li> <li><code>last</code> : Mark duplicates as <code>True</code> except for the last occurrence.</li> <li>False : Mark all duplicates as <code>True</code>.</li> </ul> </li> </ul> Returns (Series) <p>Boolean series for each duplicated rows.</p> See Also <p>Index.duplicated : Equivalent method on index.Series.duplicated : Equivalent method on Series. Series.dropduplicates : Remove duplicate values from Series. DataFrame.dropduplicates : Remove duplicate values from DataFrame.</p> Examples <p>Consider dataset containing ramen rating.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     'brand': ['Yum Yum', 'Yum Yum', 'Indomie', 'Indomie', 'Indomie'],\n...     'style': ['cup', 'cup', 'cup', 'pack', 'pack'],\n...     'rating': [4, 4, 3.5, 15, 5]\n... })\n&gt;&gt;&gt; df\n    brand style  rating\n0  Yum Yum   cup     4.0\n1  Yum Yum   cup     4.0\n2  Indomie   cup     3.5\n3  Indomie  pack    15.0\n4  Indomie  pack     5.0\n</code></pre> <p>By default, for each set of duplicated values, the first occurrence is set on False and all others on True.</p> <pre><code>&gt;&gt;&gt; df.duplicated()\n0    False\n1     True\n2    False\n3    False\n4    False\ndtype: bool\n</code></pre> <p>By using 'last', the last occurrence of each set of duplicated values is set on False and all others on True.</p> <pre><code>&gt;&gt;&gt; df.duplicated(keep='last')\n0     True\n1    False\n2    False\n3    False\n4    False\ndtype: bool\n</code></pre> <p>By setting <code>keep</code> on False, all duplicates are True.</p> <pre><code>&gt;&gt;&gt; df.duplicated(keep=False)\n0     True\n1     True\n2    False\n3    False\n4    False\ndtype: bool\n</code></pre> <p>To find duplicates on specific column(s), use <code>subset</code>.</p> <pre><code>&gt;&gt;&gt; df.duplicated(subset=['brand'])\n0    False\n1     True\n2    False\n3     True\n4     True\ndtype: bool\n</code></pre> method &lt;/&gt; <p>Sort by the values along either axis.</p> Parameters <ul> <li><code>by</code> (str or list of str) \u2014 Name or list of names to sort by.<ul> <li>if <code>axis</code> is 0 or <code>'index'</code> then <code>by</code> may contain index   levels and/or column labels.</li> <li>if <code>axis</code> is 1 or <code>'columns'</code> then <code>by</code> may contain column   levels and/or index labels.</li> </ul> </li> <li><code>axis</code> (\"{0 or 'index', 1 or 'columns'}\", default 0) \u2014 Axis to be sorted.</li> <li><code>ascending</code> (bool or list of bool, default True) \u2014 Sort ascending vs. descending. Specify list for multiple sortorders.  If this is a list of bools, must match the length of the by. </li> <li><code>inplace</code> (bool, default False) \u2014 If True, perform operation in-place.</li> <li><code>kind</code> ({'quicksort', 'mergesort', 'heapsort', 'stable'}, default 'quicksort') \u2014 Choice of sorting algorithm. See also :func:<code>numpy.sort</code> for moreinformation. <code>mergesort</code> and <code>stable</code> are the only stable algorithms. For DataFrames, this option is only applied when sorting on a single column or label. </li> <li><code>na_position</code> ({'first', 'last'}, default 'last') \u2014 Puts NaNs at the beginning if <code>first</code>; <code>last</code> puts NaNs at theend. </li> <li><code>ignore_index</code> (bool, default False) \u2014 If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.</li> <li><code>key</code> (callable, optional) \u2014 Apply the key function to the valuesbefore sorting. This is similar to the <code>key</code> argument in the builtin :meth:<code>sorted</code> function, with the notable difference that this <code>key</code> function should be vectorized. It should expect a <code>Series</code> and return a Series with the same shape as the input. It will be applied to each column in <code>by</code> independently. </li> </ul> Returns (DataFrame or None) <p>DataFrame with sorted values or None if <code>inplace=True</code>.</p> See Also <p>DataFrame.sort_index : Sort a DataFrame by the index.Series.sort_values : Similar method for a Series.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({...     'col1': ['A', 'A', 'B', np.nan, 'D', 'C'],\n...     'col2': [2, 1, 9, 8, 7, 4],\n...     'col3': [0, 1, 9, 4, 2, 3],\n...     'col4': ['a', 'B', 'c', 'D', 'e', 'F']\n... })\n&gt;&gt;&gt; df\n  col1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\n</code></pre> <p>Sort by col1</p> <pre><code>&gt;&gt;&gt; df.sort_values(by=['col1'])\n  col1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n5    C     4     3    F\n4    D     7     2    e\n3  NaN     8     4    D\n</code></pre> <p>Sort by multiple columns</p> <pre><code>&gt;&gt;&gt; df.sort_values(by=['col1', 'col2'])\n  col1  col2  col3 col4\n1    A     1     1    B\n0    A     2     0    a\n2    B     9     9    c\n5    C     4     3    F\n4    D     7     2    e\n3  NaN     8     4    D\n</code></pre> <p>Sort Descending</p> <pre><code>&gt;&gt;&gt; df.sort_values(by='col1', ascending=False)\n  col1  col2  col3 col4\n4    D     7     2    e\n5    C     4     3    F\n2    B     9     9    c\n0    A     2     0    a\n1    A     1     1    B\n3  NaN     8     4    D\n</code></pre> <p>Putting NAs first</p> <pre><code>&gt;&gt;&gt; df.sort_values(by='col1', ascending=False, na_position='first')\n  col1  col2  col3 col4\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\n2    B     9     9    c\n0    A     2     0    a\n1    A     1     1    B\n</code></pre> <p>Sorting with a key function</p> <pre><code>&gt;&gt;&gt; df.sort_values(by='col4', key=lambda col: col.str.lower())\n   col1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F\n</code></pre> <p>Natural sort with the key argument, using the <code>natsort &lt;https://github.com/SethMMorton/natsort&gt;</code> package.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...    \"time\": ['0hr', '128hr', '72hr', '48hr', '96hr'],\n...    \"value\": [10, 20, 30, 40, 50]\n... })\n&gt;&gt;&gt; df\n    time  value\n0    0hr     10\n1  128hr     20\n2   72hr     30\n3   48hr     40\n4   96hr     50\n&gt;&gt;&gt; from natsort import index_natsorted\n&gt;&gt;&gt; df.sort_values(\n...     by=\"time\",\n...     key=lambda x: np.argsort(index_natsorted(df[\"time\"]))\n... )\n    time  value\n0    0hr     10\n3   48hr     40\n2   72hr     30\n4   96hr     50\n1  128hr     20\n</code></pre> method &lt;/&gt; <p>Sort object by labels (along an axis).</p><p>Returns a new DataFrame sorted by label if <code>inplace</code> argument is <code>False</code>, otherwise updates the original DataFrame and returns None.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis along which to sort.  The value 0 identifies the rows,and 1 identifies the columns. </li> <li><code>level</code> (int or level name or list of ints or list of level names) \u2014 If not None, sort on values in specified index level(s).</li> <li><code>ascending</code> (bool or list-like of bools, default True) \u2014 Sort ascending vs. descending. When the index is a MultiIndex thesort direction can be controlled for each level individually. </li> <li><code>inplace</code> (bool, default False) \u2014 Whether to modify the DataFrame rather than creating a new one.</li> <li><code>kind</code> ({'quicksort', 'mergesort', 'heapsort', 'stable'}, default 'quicksort') \u2014 Choice of sorting algorithm. See also :func:<code>numpy.sort</code> for moreinformation. <code>mergesort</code> and <code>stable</code> are the only stable algorithms. For DataFrames, this option is only applied when sorting on a single column or label. </li> <li><code>na_position</code> ({'first', 'last'}, default 'last') \u2014 Puts NaNs at the beginning if <code>first</code>; <code>last</code> puts NaNs at the end.Not implemented for MultiIndex. </li> <li><code>sort_remaining</code> (bool, default True) \u2014 If True and sorting by level and index is multilevel, sort by otherlevels too (in order) after sorting by specified level. </li> <li><code>ignore_index</code> (bool, default False) \u2014 If True, the resulting axis will be labeled 0, 1, \u2026, n - 1.</li> <li><code>key</code> (callable, optional) \u2014 If not None, apply the key function to the index valuesbefore sorting. This is similar to the <code>key</code> argument in the builtin :meth:<code>sorted</code> function, with the notable difference that this <code>key</code> function should be vectorized. It should expect an <code>Index</code> and return an <code>Index</code> of the same shape. For MultiIndex inputs, the key is applied per level. </li> </ul> Returns (DataFrame or None) <p>The original DataFrame sorted by the labels or None if <code>inplace=True</code>.</p> See Also <p>Series.sort_index : Sort Series by the index.DataFrame.sort_values : Sort DataFrame by the value. Series.sort_values : Sort Series by the value.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([1, 2, 3, 4, 5], index=[100, 29, 234, 1, 150],...                   columns=['A'])\n&gt;&gt;&gt; df.sort_index()\n     A\n1    4\n29   2\n100  1\n150  5\n234  3\n</code></pre> <p>By default, it sorts in ascending order, to sort in descending order, use <code>ascending=False</code></p> <pre><code>&gt;&gt;&gt; df.sort_index(ascending=False)\n     A\n234  3\n150  5\n100  1\n29   2\n1    4\n</code></pre> <p>A key function can be specified which is applied to the index before sorting. For a <code>MultiIndex</code> this is applied to each level separately.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"a\": [1, 2, 3, 4]}, index=['A', 'b', 'C', 'd'])\n&gt;&gt;&gt; df.sort_index(key=lambda x: x.str.lower())\n   a\nA  1\nb  2\nC  3\nd  4\n</code></pre> method &lt;/&gt; <p>Return a Series containing the frequency of each distinct row in the Dataframe.</p> Parameters <ul> <li><code>subset</code> (label or list of labels, optional) \u2014 Columns to use when counting unique combinations.</li> <li><code>normalize</code> (bool, default False) \u2014 Return proportions rather than frequencies.</li> <li><code>sort</code> (bool, default True) \u2014 Sort by frequencies when True. Sort by DataFrame column values when False.</li> <li><code>ascending</code> (bool, default False) \u2014 Sort in ascending order.</li> <li><code>dropna</code> (bool, default True) \u2014 Don't include counts of rows that contain NA values... versionadded:: 1.3.0 </li> </ul> See Also <p>Series.value_counts: Equivalent method on Series.</p> <p>Notes</p> <p>The returned Series will have a MultiIndex with one level per input column but an Index (non-multi) for a single label. By default, rows that contain any NA values are omitted from the result. By default, the resulting Series will be in descending order so that the first element is the most frequently-occurring row.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'num_legs': [2, 4, 4, 6],...                    'num_wings': [2, 0, 0, 0]},\n...                   index=['falcon', 'dog', 'cat', 'ant'])\n&gt;&gt;&gt; df\n        num_legs  num_wings\nfalcon         2          2\ndog            4          0\ncat            4          0\nant            6          0\n</code></pre> <pre><code>&gt;&gt;&gt; df.value_counts()\nnum_legs  num_wings\n4         0            2\n2         2            1\n6         0            1\nName: count, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.value_counts(sort=False)\nnum_legs  num_wings\n2         2            1\n4         0            2\n6         0            1\nName: count, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.value_counts(ascending=True)\nnum_legs  num_wings\n2         2            1\n6         0            1\n4         0            2\nName: count, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.value_counts(normalize=True)\nnum_legs  num_wings\n4         0            0.50\n2         2            0.25\n6         0            0.25\nName: proportion, dtype: float64\n</code></pre> <p>With <code>dropna</code> set to <code>False</code> we can also count rows with NA values.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'first_name': ['John', 'Anne', 'John', 'Beth'],\n...                    'middle_name': ['Smith', pd.NA, pd.NA, 'Louise']})\n&gt;&gt;&gt; df\n  first_name middle_name\n0       John       Smith\n1       Anne        &lt;NA&gt;\n2       John        &lt;NA&gt;\n3       Beth      Louise\n</code></pre> <pre><code>&gt;&gt;&gt; df.value_counts()\nfirst_name  middle_name\nBeth        Louise         1\nJohn        Smith          1\nName: count, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.value_counts(dropna=False)\nfirst_name  middle_name\nAnne        NaN            1\nBeth        Louise         1\nJohn        Smith          1\n            NaN            1\nName: count, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.value_counts(\"first_name\")\nfirst_name\nJohn    2\nAnne    1\nBeth    1\nName: count, dtype: int64\n</code></pre> method &lt;/&gt; <p>Return the first <code>n</code> rows ordered by <code>columns</code> in descending order.</p><p>Return the first <code>n</code> rows with the largest values in <code>columns</code>, in descending order. The columns that are not specified are returned as well, but not used for ordering.</p> <p>This method is equivalent to <code>df.sort_values(columns, ascending=False).head(n)</code>, but more performant.</p> Parameters <ul> <li><code>n</code> (int) \u2014 Number of rows to return.</li> <li><code>columns</code> (label or list of labels) \u2014 Column label(s) to order by.</li> <li><code>keep</code> ({'first', 'last', 'all'}, default 'first') \u2014 Where there are duplicate values:<ul> <li><code>first</code> : prioritize the first occurrence(s)</li> <li><code>last</code> : prioritize the last occurrence(s)</li> <li><code>all</code> : keep all the ties of the smallest item even if it means   selecting more than <code>n</code> items.</li> </ul> </li> </ul> Returns (DataFrame) <p>The first <code>n</code> rows ordered by the given columns in descendingorder.</p> See Also <p>DataFrame.nsmallest : Return the first <code>n</code> rows ordered by <code>columns</code> in    ascending order. DataFrame.sort_values : Sort DataFrame by the values. DataFrame.head : Return the first <code>n</code> rows without re-ordering.</p> <p>Notes</p> <p>This function cannot be used with all column types. For example, when specifying columns with <code>object</code> or <code>category</code> dtypes, <code>TypeError</code> is raised.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'population': [59000000, 65000000, 434000,...                                   434000, 434000, 337000, 11300,\n...                                   11300, 11300],\n...                    'GDP': [1937894, 2583560 , 12011, 4520, 12128,\n...                            17036, 182, 38, 311],\n...                    'alpha-2': [\"IT\", \"FR\", \"MT\", \"MV\", \"BN\",\n...                                \"IS\", \"NR\", \"TV\", \"AI\"]},\n...                   index=[\"Italy\", \"France\", \"Malta\",\n...                          \"Maldives\", \"Brunei\", \"Iceland\",\n...                          \"Nauru\", \"Tuvalu\", \"Anguilla\"])\n&gt;&gt;&gt; df\n          population      GDP alpha-2\nItaly       59000000  1937894      IT\nFrance      65000000  2583560      FR\nMalta         434000    12011      MT\nMaldives      434000     4520      MV\nBrunei        434000    12128      BN\nIceland       337000    17036      IS\nNauru          11300      182      NR\nTuvalu         11300       38      TV\nAnguilla       11300      311      AI\n</code></pre> <p>In the following example, we will use <code>nlargest</code> to select the three rows having the largest values in column \"population\".</p> <pre><code>&gt;&gt;&gt; df.nlargest(3, 'population')\n        population      GDP alpha-2\nFrance    65000000  2583560      FR\nItaly     59000000  1937894      IT\nMalta       434000    12011      MT\n</code></pre> <p>When using <code>keep='last'</code>, ties are resolved in reverse order:</p> <pre><code>&gt;&gt;&gt; df.nlargest(3, 'population', keep='last')\n        population      GDP alpha-2\nFrance    65000000  2583560      FR\nItaly     59000000  1937894      IT\nBrunei      434000    12128      BN\n</code></pre> <p>When using <code>keep='all'</code>, the number of element kept can go beyond <code>n</code> if there are duplicate values for the smallest element, all the ties are kept:</p> <pre><code>&gt;&gt;&gt; df.nlargest(3, 'population', keep='all')\n          population      GDP alpha-2\nFrance      65000000  2583560      FR\nItaly       59000000  1937894      IT\nMalta         434000    12011      MT\nMaldives      434000     4520      MV\nBrunei        434000    12128      BN\n</code></pre> <p>However, <code>nlargest</code> does not keep <code>n</code> distinct largest elements:</p> <pre><code>&gt;&gt;&gt; df.nlargest(5, 'population', keep='all')\n          population      GDP alpha-2\nFrance      65000000  2583560      FR\nItaly       59000000  1937894      IT\nMalta         434000    12011      MT\nMaldives      434000     4520      MV\nBrunei        434000    12128      BN\n</code></pre> <p>To order by the largest values in column \"population\" and then \"GDP\", we can specify multiple columns like in the next example.</p> <pre><code>&gt;&gt;&gt; df.nlargest(3, ['population', 'GDP'])\n        population      GDP alpha-2\nFrance    65000000  2583560      FR\nItaly     59000000  1937894      IT\nBrunei      434000    12128      BN\n</code></pre> method &lt;/&gt; <p>Return the first <code>n</code> rows ordered by <code>columns</code> in ascending order.</p><p>Return the first <code>n</code> rows with the smallest values in <code>columns</code>, in ascending order. The columns that are not specified are returned as well, but not used for ordering.</p> <p>This method is equivalent to <code>df.sort_values(columns, ascending=True).head(n)</code>, but more performant.</p> Parameters <ul> <li><code>n</code> (int) \u2014 Number of items to retrieve.</li> <li><code>columns</code> (list or str) \u2014 Column name or names to order by.</li> <li><code>keep</code> ({'first', 'last', 'all'}, default 'first') \u2014 Where there are duplicate values:<ul> <li><code>first</code> : take the first occurrence.</li> <li><code>last</code> : take the last occurrence.</li> <li><code>all</code> : keep all the ties of the largest item even if it means   selecting more than <code>n</code> items.</li> </ul> </li> </ul> See Also <p>DataFrame.nlargest : Return the first <code>n</code> rows ordered by <code>columns</code> in    descending order. DataFrame.sort_values : Sort DataFrame by the values. DataFrame.head : Return the first <code>n</code> rows without re-ordering.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'population': [59000000, 65000000, 434000,...                                   434000, 434000, 337000, 337000,\n...                                   11300, 11300],\n...                    'GDP': [1937894, 2583560 , 12011, 4520, 12128,\n...                            17036, 182, 38, 311],\n...                    'alpha-2': [\"IT\", \"FR\", \"MT\", \"MV\", \"BN\",\n...                                \"IS\", \"NR\", \"TV\", \"AI\"]},\n...                   index=[\"Italy\", \"France\", \"Malta\",\n...                          \"Maldives\", \"Brunei\", \"Iceland\",\n...                          \"Nauru\", \"Tuvalu\", \"Anguilla\"])\n&gt;&gt;&gt; df\n          population      GDP alpha-2\nItaly       59000000  1937894      IT\nFrance      65000000  2583560      FR\nMalta         434000    12011      MT\nMaldives      434000     4520      MV\nBrunei        434000    12128      BN\nIceland       337000    17036      IS\nNauru         337000      182      NR\nTuvalu         11300       38      TV\nAnguilla       11300      311      AI\n</code></pre> <p>In the following example, we will use <code>nsmallest</code> to select the three rows having the smallest values in column \"population\".</p> <pre><code>&gt;&gt;&gt; df.nsmallest(3, 'population')\n          population    GDP alpha-2\nTuvalu         11300     38      TV\nAnguilla       11300    311      AI\nIceland       337000  17036      IS\n</code></pre> <p>When using <code>keep='last'</code>, ties are resolved in reverse order:</p> <pre><code>&gt;&gt;&gt; df.nsmallest(3, 'population', keep='last')\n          population  GDP alpha-2\nAnguilla       11300  311      AI\nTuvalu         11300   38      TV\nNauru         337000  182      NR\n</code></pre> <p>When using <code>keep='all'</code>, the number of element kept can go beyond <code>n</code> if there are duplicate values for the largest element, all the ties are kept.</p> <pre><code>&gt;&gt;&gt; df.nsmallest(3, 'population', keep='all')\n          population    GDP alpha-2\nTuvalu         11300     38      TV\nAnguilla       11300    311      AI\nIceland       337000  17036      IS\nNauru         337000    182      NR\n</code></pre> <p>However, <code>nsmallest</code> does not keep <code>n</code> distinct smallest elements:</p> <pre><code>&gt;&gt;&gt; df.nsmallest(4, 'population', keep='all')\n          population    GDP alpha-2\nTuvalu         11300     38      TV\nAnguilla       11300    311      AI\nIceland       337000  17036      IS\nNauru         337000    182      NR\n</code></pre> <p>To order by the smallest values in column \"population\" and then \"GDP\", we can specify multiple columns like in the next example.</p> <pre><code>&gt;&gt;&gt; df.nsmallest(3, ['population', 'GDP'])\n          population  GDP alpha-2\nTuvalu         11300   38      TV\nAnguilla       11300  311      AI\nNauru         337000  182      NR\n</code></pre> method &lt;/&gt; <p>Swap levels i and j in a :class:<code>MultiIndex</code>.</p><p>Default is to swap the two innermost levels of the index.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to swap levels on. 0 or 'index' for row-wise, 1 or'columns' for column-wise. </li> </ul> Returns (DataFrame) <p>DataFrame with levels swapped in MultiIndex.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(...     {\"Grade\": [\"A\", \"B\", \"A\", \"C\"]},\n...     index=[\n...         [\"Final exam\", \"Final exam\", \"Coursework\", \"Coursework\"],\n...         [\"History\", \"Geography\", \"History\", \"Geography\"],\n...         [\"January\", \"February\", \"March\", \"April\"],\n...     ],\n... )\n&gt;&gt;&gt; df\n                                    Grade\nFinal exam  History     January      A\n            Geography   February     B\nCoursework  History     March        A\n            Geography   April        C\n</code></pre> <p>In the following example, we will swap the levels of the indices. Here, we will swap the levels column-wise, but levels can be swapped row-wise in a similar manner. Note that column-wise is the default behaviour. By not supplying any arguments for i and j, we swap the last and second to last indices.</p> <pre><code>&gt;&gt;&gt; df.swaplevel()\n                                    Grade\nFinal exam  January     History         A\n            February    Geography       B\nCoursework  March       History         A\n            April       Geography       C\n</code></pre> <p>By supplying one argument, we can choose which index to swap the last index with. We can for example swap the first index with the last one as follows.</p> <pre><code>&gt;&gt;&gt; df.swaplevel(0)\n                                    Grade\nJanuary     History     Final exam      A\nFebruary    Geography   Final exam      B\nMarch       History     Coursework      A\nApril       Geography   Coursework      C\n</code></pre> <p>We can also define explicitly which indices we want to swap by supplying values for both i and j. Here, we for example swap the first and second indices.</p> <pre><code>&gt;&gt;&gt; df.swaplevel(0, 1)\n                                    Grade\nHistory     Final exam  January         A\nGeography   Final exam  February        B\nHistory     Coursework  March           A\nGeography   Coursework  April           C\n</code></pre> method &lt;/&gt; <p>Rearrange index levels using input order. May not drop or duplicate levels.</p> Parameters <ul> <li><code>order</code> (list of int or list of str) \u2014 List representing new level order. Reference level by number(position) or by key (label). </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Where to reorder levels.</li> </ul> Examples <pre><code>&gt;&gt;&gt; data = {...     \"class\": [\"Mammals\", \"Mammals\", \"Reptiles\"],\n...     \"diet\": [\"Omnivore\", \"Carnivore\", \"Carnivore\"],\n...     \"species\": [\"Humans\", \"Dogs\", \"Snakes\"],\n... }\n&gt;&gt;&gt; df = pd.DataFrame(data, columns=[\"class\", \"diet\", \"species\"])\n&gt;&gt;&gt; df = df.set_index([\"class\", \"diet\"])\n&gt;&gt;&gt; df\n                                  species\nclass      diet\nMammals    Omnivore                Humans\n           Carnivore                 Dogs\nReptiles   Carnivore               Snakes\n</code></pre> <p>Let's reorder the levels of the index:</p> <pre><code>&gt;&gt;&gt; df.reorder_levels([\"diet\", \"class\"])\n                                  species\ndiet      class\nOmnivore  Mammals                  Humans\nCarnivore Mammals                    Dogs\n          Reptiles                 Snakes\n</code></pre> method &lt;/&gt; <p>Get Equal to of dataframe and other, element-wise (binary operator <code>eq</code>).</p><p>Among flexible wrappers (<code>eq</code>, <code>ne</code>, <code>le</code>, <code>lt</code>, <code>ge</code>, <code>gt</code>) to comparison operators.</p> <p>Equivalent to <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code> with support to choose axis (rows or columns) and level for comparison.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 'columns') \u2014 Whether to compare by the index (0 or 'index') or columns(1 or 'columns'). </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on the passedMultiIndex level. </li> </ul> Returns (DataFrame of bool) <p>Result of the comparison.</p> See Also <p>DataFrame.eq : Compare DataFrames for equality elementwise.DataFrame.ne : Compare DataFrames for inequality elementwise. DataFrame.le : Compare DataFrames for less than inequality     or equality elementwise. DataFrame.lt : Compare DataFrames for strictly less than     inequality elementwise. DataFrame.ge : Compare DataFrames for greater than inequality     or equality elementwise. DataFrame.gt : Compare DataFrames for strictly greater than     inequality elementwise.</p> <p>Notes</p> <p>Mismatched indices will be unioned together. <code>NaN</code> values are considered different (i.e. <code>NaN</code> != <code>NaN</code>).</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'cost': [250, 150, 100],...                    'revenue': [100, 250, 300]},\n...                   index=['A', 'B', 'C'])\n&gt;&gt;&gt; df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300\n</code></pre> <p>Comparison with a scalar, using either the operator or method:</p> <pre><code>&gt;&gt;&gt; df == 100\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <pre><code>&gt;&gt;&gt; df.eq(100)\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <p>When <code>other</code> is a :class:<code>Series</code>, the columns of a DataFrame are aligned with the index of <code>other</code> and broadcast:</p> <pre><code>&gt;&gt;&gt; df != pd.Series([100, 250], index=[\"cost\", \"revenue\"])\n    cost  revenue\nA   True     True\nB   True    False\nC  False     True\n</code></pre> <p>Use the method to control the broadcast axis:</p> <pre><code>&gt;&gt;&gt; df.ne(pd.Series([100, 300], index=[\"A\", \"D\"]), axis='index')\n   cost  revenue\nA  True    False\nB  True     True\nC  True     True\nD  True     True\n</code></pre> <p>When comparing to an arbitrary sequence, the number of columns must match the number elements in <code>other</code>:</p> <pre><code>&gt;&gt;&gt; df == [250, 100]\n    cost  revenue\nA   True     True\nB  False    False\nC  False    False\n</code></pre> <p>Use the method to control the axis:</p> <pre><code>&gt;&gt;&gt; df.eq([250, 250, 100], axis='index')\n    cost  revenue\nA   True    False\nB  False     True\nC   True    False\n</code></pre> <p>Compare to a DataFrame of different shape.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'revenue': [300, 250, 100, 150]},\n...                      index=['A', 'B', 'C', 'D'])\n&gt;&gt;&gt; other\n   revenue\nA      300\nB      250\nC      100\nD      150\n</code></pre> <pre><code>&gt;&gt;&gt; df.gt(other)\n    cost  revenue\nA  False    False\nB  False    False\nC  False     True\nD  False    False\n</code></pre> <p>Compare to a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'cost': [250, 150, 100, 150, 300, 220],\n...                              'revenue': [100, 250, 300, 200, 175, 225]},\n...                             index=[['Q1', 'Q1', 'Q1', 'Q2', 'Q2', 'Q2'],\n...                                    ['A', 'B', 'C', 'A', 'B', 'C']])\n&gt;&gt;&gt; df_multindex\n      cost  revenue\nQ1 A   250      100\n   B   150      250\n   C   100      300\nQ2 A   150      200\n   B   300      175\n   C   220      225\n</code></pre> <pre><code>&gt;&gt;&gt; df.le(df_multindex, level=1)\n       cost  revenue\nQ1 A   True     True\n   B   True     True\n   C   True     True\nQ2 A  False     True\n   B   True    False\n   C   True    False\n</code></pre> method &lt;/&gt; <p>Get Not equal to of dataframe and other, element-wise (binary operator <code>ne</code>).</p><p>Among flexible wrappers (<code>eq</code>, <code>ne</code>, <code>le</code>, <code>lt</code>, <code>ge</code>, <code>gt</code>) to comparison operators.</p> <p>Equivalent to <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code> with support to choose axis (rows or columns) and level for comparison.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 'columns') \u2014 Whether to compare by the index (0 or 'index') or columns(1 or 'columns'). </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on the passedMultiIndex level. </li> </ul> Returns (DataFrame of bool) <p>Result of the comparison.</p> See Also <p>DataFrame.eq : Compare DataFrames for equality elementwise.DataFrame.ne : Compare DataFrames for inequality elementwise. DataFrame.le : Compare DataFrames for less than inequality     or equality elementwise. DataFrame.lt : Compare DataFrames for strictly less than     inequality elementwise. DataFrame.ge : Compare DataFrames for greater than inequality     or equality elementwise. DataFrame.gt : Compare DataFrames for strictly greater than     inequality elementwise.</p> <p>Notes</p> <p>Mismatched indices will be unioned together. <code>NaN</code> values are considered different (i.e. <code>NaN</code> != <code>NaN</code>).</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'cost': [250, 150, 100],...                    'revenue': [100, 250, 300]},\n...                   index=['A', 'B', 'C'])\n&gt;&gt;&gt; df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300\n</code></pre> <p>Comparison with a scalar, using either the operator or method:</p> <pre><code>&gt;&gt;&gt; df == 100\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <pre><code>&gt;&gt;&gt; df.eq(100)\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <p>When <code>other</code> is a :class:<code>Series</code>, the columns of a DataFrame are aligned with the index of <code>other</code> and broadcast:</p> <pre><code>&gt;&gt;&gt; df != pd.Series([100, 250], index=[\"cost\", \"revenue\"])\n    cost  revenue\nA   True     True\nB   True    False\nC  False     True\n</code></pre> <p>Use the method to control the broadcast axis:</p> <pre><code>&gt;&gt;&gt; df.ne(pd.Series([100, 300], index=[\"A\", \"D\"]), axis='index')\n   cost  revenue\nA  True    False\nB  True     True\nC  True     True\nD  True     True\n</code></pre> <p>When comparing to an arbitrary sequence, the number of columns must match the number elements in <code>other</code>:</p> <pre><code>&gt;&gt;&gt; df == [250, 100]\n    cost  revenue\nA   True     True\nB  False    False\nC  False    False\n</code></pre> <p>Use the method to control the axis:</p> <pre><code>&gt;&gt;&gt; df.eq([250, 250, 100], axis='index')\n    cost  revenue\nA   True    False\nB  False     True\nC   True    False\n</code></pre> <p>Compare to a DataFrame of different shape.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'revenue': [300, 250, 100, 150]},\n...                      index=['A', 'B', 'C', 'D'])\n&gt;&gt;&gt; other\n   revenue\nA      300\nB      250\nC      100\nD      150\n</code></pre> <pre><code>&gt;&gt;&gt; df.gt(other)\n    cost  revenue\nA  False    False\nB  False    False\nC  False     True\nD  False    False\n</code></pre> <p>Compare to a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'cost': [250, 150, 100, 150, 300, 220],\n...                              'revenue': [100, 250, 300, 200, 175, 225]},\n...                             index=[['Q1', 'Q1', 'Q1', 'Q2', 'Q2', 'Q2'],\n...                                    ['A', 'B', 'C', 'A', 'B', 'C']])\n&gt;&gt;&gt; df_multindex\n      cost  revenue\nQ1 A   250      100\n   B   150      250\n   C   100      300\nQ2 A   150      200\n   B   300      175\n   C   220      225\n</code></pre> <pre><code>&gt;&gt;&gt; df.le(df_multindex, level=1)\n       cost  revenue\nQ1 A   True     True\n   B   True     True\n   C   True     True\nQ2 A  False     True\n   B   True    False\n   C   True    False\n</code></pre> method &lt;/&gt; <p>Get Less than or equal to of dataframe and other, element-wise (binary operator <code>le</code>).</p><p>Among flexible wrappers (<code>eq</code>, <code>ne</code>, <code>le</code>, <code>lt</code>, <code>ge</code>, <code>gt</code>) to comparison operators.</p> <p>Equivalent to <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code> with support to choose axis (rows or columns) and level for comparison.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 'columns') \u2014 Whether to compare by the index (0 or 'index') or columns(1 or 'columns'). </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on the passedMultiIndex level. </li> </ul> Returns (DataFrame of bool) <p>Result of the comparison.</p> See Also <p>DataFrame.eq : Compare DataFrames for equality elementwise.DataFrame.ne : Compare DataFrames for inequality elementwise. DataFrame.le : Compare DataFrames for less than inequality     or equality elementwise. DataFrame.lt : Compare DataFrames for strictly less than     inequality elementwise. DataFrame.ge : Compare DataFrames for greater than inequality     or equality elementwise. DataFrame.gt : Compare DataFrames for strictly greater than     inequality elementwise.</p> <p>Notes</p> <p>Mismatched indices will be unioned together. <code>NaN</code> values are considered different (i.e. <code>NaN</code> != <code>NaN</code>).</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'cost': [250, 150, 100],...                    'revenue': [100, 250, 300]},\n...                   index=['A', 'B', 'C'])\n&gt;&gt;&gt; df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300\n</code></pre> <p>Comparison with a scalar, using either the operator or method:</p> <pre><code>&gt;&gt;&gt; df == 100\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <pre><code>&gt;&gt;&gt; df.eq(100)\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <p>When <code>other</code> is a :class:<code>Series</code>, the columns of a DataFrame are aligned with the index of <code>other</code> and broadcast:</p> <pre><code>&gt;&gt;&gt; df != pd.Series([100, 250], index=[\"cost\", \"revenue\"])\n    cost  revenue\nA   True     True\nB   True    False\nC  False     True\n</code></pre> <p>Use the method to control the broadcast axis:</p> <pre><code>&gt;&gt;&gt; df.ne(pd.Series([100, 300], index=[\"A\", \"D\"]), axis='index')\n   cost  revenue\nA  True    False\nB  True     True\nC  True     True\nD  True     True\n</code></pre> <p>When comparing to an arbitrary sequence, the number of columns must match the number elements in <code>other</code>:</p> <pre><code>&gt;&gt;&gt; df == [250, 100]\n    cost  revenue\nA   True     True\nB  False    False\nC  False    False\n</code></pre> <p>Use the method to control the axis:</p> <pre><code>&gt;&gt;&gt; df.eq([250, 250, 100], axis='index')\n    cost  revenue\nA   True    False\nB  False     True\nC   True    False\n</code></pre> <p>Compare to a DataFrame of different shape.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'revenue': [300, 250, 100, 150]},\n...                      index=['A', 'B', 'C', 'D'])\n&gt;&gt;&gt; other\n   revenue\nA      300\nB      250\nC      100\nD      150\n</code></pre> <pre><code>&gt;&gt;&gt; df.gt(other)\n    cost  revenue\nA  False    False\nB  False    False\nC  False     True\nD  False    False\n</code></pre> <p>Compare to a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'cost': [250, 150, 100, 150, 300, 220],\n...                              'revenue': [100, 250, 300, 200, 175, 225]},\n...                             index=[['Q1', 'Q1', 'Q1', 'Q2', 'Q2', 'Q2'],\n...                                    ['A', 'B', 'C', 'A', 'B', 'C']])\n&gt;&gt;&gt; df_multindex\n      cost  revenue\nQ1 A   250      100\n   B   150      250\n   C   100      300\nQ2 A   150      200\n   B   300      175\n   C   220      225\n</code></pre> <pre><code>&gt;&gt;&gt; df.le(df_multindex, level=1)\n       cost  revenue\nQ1 A   True     True\n   B   True     True\n   C   True     True\nQ2 A  False     True\n   B   True    False\n   C   True    False\n</code></pre> method &lt;/&gt; <p>Get Less than of dataframe and other, element-wise (binary operator <code>lt</code>).</p><p>Among flexible wrappers (<code>eq</code>, <code>ne</code>, <code>le</code>, <code>lt</code>, <code>ge</code>, <code>gt</code>) to comparison operators.</p> <p>Equivalent to <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code> with support to choose axis (rows or columns) and level for comparison.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 'columns') \u2014 Whether to compare by the index (0 or 'index') or columns(1 or 'columns'). </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on the passedMultiIndex level. </li> </ul> Returns (DataFrame of bool) <p>Result of the comparison.</p> See Also <p>DataFrame.eq : Compare DataFrames for equality elementwise.DataFrame.ne : Compare DataFrames for inequality elementwise. DataFrame.le : Compare DataFrames for less than inequality     or equality elementwise. DataFrame.lt : Compare DataFrames for strictly less than     inequality elementwise. DataFrame.ge : Compare DataFrames for greater than inequality     or equality elementwise. DataFrame.gt : Compare DataFrames for strictly greater than     inequality elementwise.</p> <p>Notes</p> <p>Mismatched indices will be unioned together. <code>NaN</code> values are considered different (i.e. <code>NaN</code> != <code>NaN</code>).</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'cost': [250, 150, 100],...                    'revenue': [100, 250, 300]},\n...                   index=['A', 'B', 'C'])\n&gt;&gt;&gt; df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300\n</code></pre> <p>Comparison with a scalar, using either the operator or method:</p> <pre><code>&gt;&gt;&gt; df == 100\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <pre><code>&gt;&gt;&gt; df.eq(100)\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <p>When <code>other</code> is a :class:<code>Series</code>, the columns of a DataFrame are aligned with the index of <code>other</code> and broadcast:</p> <pre><code>&gt;&gt;&gt; df != pd.Series([100, 250], index=[\"cost\", \"revenue\"])\n    cost  revenue\nA   True     True\nB   True    False\nC  False     True\n</code></pre> <p>Use the method to control the broadcast axis:</p> <pre><code>&gt;&gt;&gt; df.ne(pd.Series([100, 300], index=[\"A\", \"D\"]), axis='index')\n   cost  revenue\nA  True    False\nB  True     True\nC  True     True\nD  True     True\n</code></pre> <p>When comparing to an arbitrary sequence, the number of columns must match the number elements in <code>other</code>:</p> <pre><code>&gt;&gt;&gt; df == [250, 100]\n    cost  revenue\nA   True     True\nB  False    False\nC  False    False\n</code></pre> <p>Use the method to control the axis:</p> <pre><code>&gt;&gt;&gt; df.eq([250, 250, 100], axis='index')\n    cost  revenue\nA   True    False\nB  False     True\nC   True    False\n</code></pre> <p>Compare to a DataFrame of different shape.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'revenue': [300, 250, 100, 150]},\n...                      index=['A', 'B', 'C', 'D'])\n&gt;&gt;&gt; other\n   revenue\nA      300\nB      250\nC      100\nD      150\n</code></pre> <pre><code>&gt;&gt;&gt; df.gt(other)\n    cost  revenue\nA  False    False\nB  False    False\nC  False     True\nD  False    False\n</code></pre> <p>Compare to a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'cost': [250, 150, 100, 150, 300, 220],\n...                              'revenue': [100, 250, 300, 200, 175, 225]},\n...                             index=[['Q1', 'Q1', 'Q1', 'Q2', 'Q2', 'Q2'],\n...                                    ['A', 'B', 'C', 'A', 'B', 'C']])\n&gt;&gt;&gt; df_multindex\n      cost  revenue\nQ1 A   250      100\n   B   150      250\n   C   100      300\nQ2 A   150      200\n   B   300      175\n   C   220      225\n</code></pre> <pre><code>&gt;&gt;&gt; df.le(df_multindex, level=1)\n       cost  revenue\nQ1 A   True     True\n   B   True     True\n   C   True     True\nQ2 A  False     True\n   B   True    False\n   C   True    False\n</code></pre> method &lt;/&gt; <p>Get Greater than or equal to of dataframe and other, element-wise (binary operator <code>ge</code>).</p><p>Among flexible wrappers (<code>eq</code>, <code>ne</code>, <code>le</code>, <code>lt</code>, <code>ge</code>, <code>gt</code>) to comparison operators.</p> <p>Equivalent to <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code> with support to choose axis (rows or columns) and level for comparison.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 'columns') \u2014 Whether to compare by the index (0 or 'index') or columns(1 or 'columns'). </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on the passedMultiIndex level. </li> </ul> Returns (DataFrame of bool) <p>Result of the comparison.</p> See Also <p>DataFrame.eq : Compare DataFrames for equality elementwise.DataFrame.ne : Compare DataFrames for inequality elementwise. DataFrame.le : Compare DataFrames for less than inequality     or equality elementwise. DataFrame.lt : Compare DataFrames for strictly less than     inequality elementwise. DataFrame.ge : Compare DataFrames for greater than inequality     or equality elementwise. DataFrame.gt : Compare DataFrames for strictly greater than     inequality elementwise.</p> <p>Notes</p> <p>Mismatched indices will be unioned together. <code>NaN</code> values are considered different (i.e. <code>NaN</code> != <code>NaN</code>).</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'cost': [250, 150, 100],...                    'revenue': [100, 250, 300]},\n...                   index=['A', 'B', 'C'])\n&gt;&gt;&gt; df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300\n</code></pre> <p>Comparison with a scalar, using either the operator or method:</p> <pre><code>&gt;&gt;&gt; df == 100\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <pre><code>&gt;&gt;&gt; df.eq(100)\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <p>When <code>other</code> is a :class:<code>Series</code>, the columns of a DataFrame are aligned with the index of <code>other</code> and broadcast:</p> <pre><code>&gt;&gt;&gt; df != pd.Series([100, 250], index=[\"cost\", \"revenue\"])\n    cost  revenue\nA   True     True\nB   True    False\nC  False     True\n</code></pre> <p>Use the method to control the broadcast axis:</p> <pre><code>&gt;&gt;&gt; df.ne(pd.Series([100, 300], index=[\"A\", \"D\"]), axis='index')\n   cost  revenue\nA  True    False\nB  True     True\nC  True     True\nD  True     True\n</code></pre> <p>When comparing to an arbitrary sequence, the number of columns must match the number elements in <code>other</code>:</p> <pre><code>&gt;&gt;&gt; df == [250, 100]\n    cost  revenue\nA   True     True\nB  False    False\nC  False    False\n</code></pre> <p>Use the method to control the axis:</p> <pre><code>&gt;&gt;&gt; df.eq([250, 250, 100], axis='index')\n    cost  revenue\nA   True    False\nB  False     True\nC   True    False\n</code></pre> <p>Compare to a DataFrame of different shape.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'revenue': [300, 250, 100, 150]},\n...                      index=['A', 'B', 'C', 'D'])\n&gt;&gt;&gt; other\n   revenue\nA      300\nB      250\nC      100\nD      150\n</code></pre> <pre><code>&gt;&gt;&gt; df.gt(other)\n    cost  revenue\nA  False    False\nB  False    False\nC  False     True\nD  False    False\n</code></pre> <p>Compare to a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'cost': [250, 150, 100, 150, 300, 220],\n...                              'revenue': [100, 250, 300, 200, 175, 225]},\n...                             index=[['Q1', 'Q1', 'Q1', 'Q2', 'Q2', 'Q2'],\n...                                    ['A', 'B', 'C', 'A', 'B', 'C']])\n&gt;&gt;&gt; df_multindex\n      cost  revenue\nQ1 A   250      100\n   B   150      250\n   C   100      300\nQ2 A   150      200\n   B   300      175\n   C   220      225\n</code></pre> <pre><code>&gt;&gt;&gt; df.le(df_multindex, level=1)\n       cost  revenue\nQ1 A   True     True\n   B   True     True\n   C   True     True\nQ2 A  False     True\n   B   True    False\n   C   True    False\n</code></pre> method &lt;/&gt; <p>Get Greater than of dataframe and other, element-wise (binary operator <code>gt</code>).</p><p>Among flexible wrappers (<code>eq</code>, <code>ne</code>, <code>le</code>, <code>lt</code>, <code>ge</code>, <code>gt</code>) to comparison operators.</p> <p>Equivalent to <code>==</code>, <code>!=</code>, <code>&lt;=</code>, <code>&lt;</code>, <code>&gt;=</code>, <code>&gt;</code> with support to choose axis (rows or columns) and level for comparison.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 'columns') \u2014 Whether to compare by the index (0 or 'index') or columns(1 or 'columns'). </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on the passedMultiIndex level. </li> </ul> Returns (DataFrame of bool) <p>Result of the comparison.</p> See Also <p>DataFrame.eq : Compare DataFrames for equality elementwise.DataFrame.ne : Compare DataFrames for inequality elementwise. DataFrame.le : Compare DataFrames for less than inequality     or equality elementwise. DataFrame.lt : Compare DataFrames for strictly less than     inequality elementwise. DataFrame.ge : Compare DataFrames for greater than inequality     or equality elementwise. DataFrame.gt : Compare DataFrames for strictly greater than     inequality elementwise.</p> <p>Notes</p> <p>Mismatched indices will be unioned together. <code>NaN</code> values are considered different (i.e. <code>NaN</code> != <code>NaN</code>).</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'cost': [250, 150, 100],...                    'revenue': [100, 250, 300]},\n...                   index=['A', 'B', 'C'])\n&gt;&gt;&gt; df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300\n</code></pre> <p>Comparison with a scalar, using either the operator or method:</p> <pre><code>&gt;&gt;&gt; df == 100\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <pre><code>&gt;&gt;&gt; df.eq(100)\n    cost  revenue\nA  False     True\nB  False    False\nC   True    False\n</code></pre> <p>When <code>other</code> is a :class:<code>Series</code>, the columns of a DataFrame are aligned with the index of <code>other</code> and broadcast:</p> <pre><code>&gt;&gt;&gt; df != pd.Series([100, 250], index=[\"cost\", \"revenue\"])\n    cost  revenue\nA   True     True\nB   True    False\nC  False     True\n</code></pre> <p>Use the method to control the broadcast axis:</p> <pre><code>&gt;&gt;&gt; df.ne(pd.Series([100, 300], index=[\"A\", \"D\"]), axis='index')\n   cost  revenue\nA  True    False\nB  True     True\nC  True     True\nD  True     True\n</code></pre> <p>When comparing to an arbitrary sequence, the number of columns must match the number elements in <code>other</code>:</p> <pre><code>&gt;&gt;&gt; df == [250, 100]\n    cost  revenue\nA   True     True\nB  False    False\nC  False    False\n</code></pre> <p>Use the method to control the axis:</p> <pre><code>&gt;&gt;&gt; df.eq([250, 250, 100], axis='index')\n    cost  revenue\nA   True    False\nB  False     True\nC   True    False\n</code></pre> <p>Compare to a DataFrame of different shape.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'revenue': [300, 250, 100, 150]},\n...                      index=['A', 'B', 'C', 'D'])\n&gt;&gt;&gt; other\n   revenue\nA      300\nB      250\nC      100\nD      150\n</code></pre> <pre><code>&gt;&gt;&gt; df.gt(other)\n    cost  revenue\nA  False    False\nB  False    False\nC  False     True\nD  False    False\n</code></pre> <p>Compare to a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'cost': [250, 150, 100, 150, 300, 220],\n...                              'revenue': [100, 250, 300, 200, 175, 225]},\n...                             index=[['Q1', 'Q1', 'Q1', 'Q2', 'Q2', 'Q2'],\n...                                    ['A', 'B', 'C', 'A', 'B', 'C']])\n&gt;&gt;&gt; df_multindex\n      cost  revenue\nQ1 A   250      100\n   B   150      250\n   C   100      300\nQ2 A   150      200\n   B   300      175\n   C   220      225\n</code></pre> <pre><code>&gt;&gt;&gt; df.le(df_multindex, level=1)\n       cost  revenue\nQ1 A   True     True\n   B   True     True\n   C   True     True\nQ2 A  False     True\n   B   True    False\n   C   True    False\n</code></pre> method &lt;/&gt; <p>Get Addition of dataframe and other, element-wise (binary operator <code>add</code>).</p><p>Equivalent to <code>dataframe + other</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>radd</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Addition of dataframe and other, element-wise (binary operator <code>radd</code>).</p><p>Equivalent to <code>other + dataframe</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>add</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Subtraction of dataframe and other, element-wise (binary operator <code>sub</code>).</p><p>Equivalent to <code>dataframe - other</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>rsub</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Subtraction of dataframe and other, element-wise (binary operator <code>rsub</code>).</p><p>Equivalent to <code>other - dataframe</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>sub</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Multiplication of dataframe and other, element-wise (binary operator <code>mul</code>).</p><p>Equivalent to <code>dataframe * other</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>rmul</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Multiplication of dataframe and other, element-wise (binary operator <code>rmul</code>).</p><p>Equivalent to <code>other * dataframe</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>mul</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Floating division of dataframe and other, element-wise (binary operator <code>truediv</code>).</p><p>Equivalent to <code>dataframe / other</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>rtruediv</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Floating division of dataframe and other, element-wise (binary operator <code>rtruediv</code>).</p><p>Equivalent to <code>other / dataframe</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>truediv</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Integer division of dataframe and other, element-wise (binary operator <code>floordiv</code>).</p><p>Equivalent to <code>dataframe // other</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>rfloordiv</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Integer division of dataframe and other, element-wise (binary operator <code>rfloordiv</code>).</p><p>Equivalent to <code>other // dataframe</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>floordiv</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Modulo of dataframe and other, element-wise (binary operator <code>mod</code>).</p><p>Equivalent to <code>dataframe % other</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>rmod</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Modulo of dataframe and other, element-wise (binary operator <code>rmod</code>).</p><p>Equivalent to <code>other % dataframe</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>mod</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Exponential power of dataframe and other, element-wise (binary operator <code>pow</code>).</p><p>Equivalent to <code>dataframe ** other</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>rpow</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Get Exponential power of dataframe and other, element-wise (binary operator <code>rpow</code>).</p><p>Equivalent to <code>other ** dataframe</code>, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, <code>pow</code>.</p> <p>Among flexible wrappers (<code>add</code>, <code>sub</code>, <code>mul</code>, <code>div</code>, <code>floordiv</code>, <code>mod</code>, <code>pow</code>) to arithmetic operators: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>//</code>, <code>%</code>, <code>**</code>.</p> Parameters <ul> <li><code>other</code> (scalar, sequence, Series, dict or DataFrame) \u2014 Any single or multiple element data structure, or list-like object.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}) \u2014 Whether to compare by the index (0 or 'index') or columns.(1 or 'columns'). For Series input, axis to match Series index on. </li> <li><code>level</code> (int or label) \u2014 Broadcast across a level, matching Index values on thepassed MultiIndex level. </li> <li><code>fill_value</code> (float or None, default None) \u2014 Fill existing missing (NaN) values, and any new element needed forsuccessful DataFrame alignment, with this value before computation. If data in both corresponding DataFrame locations is missing the result will be missing. </li> </ul> Returns (DataFrame) <p>Result of the arithmetic operation.</p> See Also <p>DataFrame.add : Add DataFrames.DataFrame.sub : Subtract DataFrames. DataFrame.mul : Multiply DataFrames. DataFrame.div : Divide DataFrames (float division). DataFrame.truediv : Divide DataFrames (float division). DataFrame.floordiv : Divide DataFrames (integer division). DataFrame.mod : Calculate modulo (remainder after division). DataFrame.pow : Calculate exponential power.</p> <p>Notes</p> <p>Mismatched indices will be unioned together.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'angles': [0, 3, 4],...                    'degrees': [360, 180, 360]},\n...                   index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360\n</code></pre> <p>Add a scalar with operator version which return the same results.</p> <pre><code>&gt;&gt;&gt; df + 1\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <pre><code>&gt;&gt;&gt; df.add(1)\n           angles  degrees\ncircle          1      361\ntriangle        4      181\nrectangle       5      361\n</code></pre> <p>Divide by constant with reverse version.</p> <pre><code>&gt;&gt;&gt; df.div(10)\n           angles  degrees\ncircle        0.0     36.0\ntriangle      0.3     18.0\nrectangle     0.4     36.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.rdiv(10)\n             angles   degrees\ncircle          inf  0.027778\ntriangle   3.333333  0.055556\nrectangle  2.500000  0.027778\n</code></pre> <p>Subtract a list and Series by axis with operator version.</p> <pre><code>&gt;&gt;&gt; df - [1, 2]\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub([1, 2], axis='columns')\n           angles  degrees\ncircle         -1      358\ntriangle        2      178\nrectangle       3      358\n</code></pre> <pre><code>&gt;&gt;&gt; df.sub(pd.Series([1, 1, 1], index=['circle', 'triangle', 'rectangle']),\n...        axis='index')\n           angles  degrees\ncircle         -1      359\ntriangle        2      179\nrectangle       3      359\n</code></pre> <p>Multiply a dictionary by axis.</p> <pre><code>&gt;&gt;&gt; df.mul({'angles': 0, 'degrees': 2})\n            angles  degrees\ncircle           0      720\ntriangle         0      360\nrectangle        0      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul({'circle': 0, 'triangle': 2, 'rectangle': 3}, axis='index')\n            angles  degrees\ncircle           0        0\ntriangle         6      360\nrectangle       12     1080\n</code></pre> <p>Multiply a DataFrame of different shape with operator version.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'angles': [0, 3, 4]},\n...                      index=['circle', 'triangle', 'rectangle'])\n&gt;&gt;&gt; other\n           angles\ncircle          0\ntriangle        3\nrectangle       4\n</code></pre> <pre><code>&gt;&gt;&gt; df * other\n           angles  degrees\ncircle          0      NaN\ntriangle        9      NaN\nrectangle      16      NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df.mul(other, fill_value=0)\n           angles  degrees\ncircle          0      0.0\ntriangle        9      0.0\nrectangle      16      0.0\n</code></pre> <p>Divide by a MultiIndex by level.</p> <pre><code>&gt;&gt;&gt; df_multindex = pd.DataFrame({'angles': [0, 3, 4, 4, 5, 6],\n...                              'degrees': [360, 180, 360, 360, 540, 720]},\n...                             index=[['A', 'A', 'A', 'B', 'B', 'B'],\n...                                    ['circle', 'triangle', 'rectangle',\n...                                     'square', 'pentagon', 'hexagon']])\n&gt;&gt;&gt; df_multindex\n             angles  degrees\nA circle          0      360\n  triangle        3      180\n  rectangle       4      360\nB square          4      360\n  pentagon        5      540\n  hexagon         6      720\n</code></pre> <pre><code>&gt;&gt;&gt; df.div(df_multindex, level=1, fill_value=0)\n             angles  degrees\nA circle        NaN      1.0\n  triangle      1.0      1.0\n  rectangle     1.0      1.0\nB square        0.0      0.0\n  pentagon      0.0      0.0\n  hexagon       0.0      0.0\n</code></pre> method &lt;/&gt; <p>Compare to another DataFrame and show the differences.</p> Parameters <ul> <li><code>other</code> (DataFrame) \u2014 Object to compare with.</li> <li><code>align_axis</code> ({0 or 'index', 1 or 'columns'}, default 1) \u2014 Determine which axis to align the comparison on.<ul> <li>0, or 'index' : Resulting differences are stacked vertically     with rows drawn alternately from self and other.</li> <li>1, or 'columns' : Resulting differences are aligned horizontally     with columns drawn alternately from self and other.</li> </ul> </li> <li><code>keep_shape</code> (bool, default False) \u2014 If true, all rows and columns are kept.Otherwise, only the ones with different values are kept. </li> <li><code>keep_equal</code> (bool, default False) \u2014 If true, the result keeps values that are equal.Otherwise, equal values are shown as NaNs. </li> <li><code>result_names</code> (tuple, default ('self', 'other')) \u2014 Set the dataframes names in the comparison... versionadded:: 1.5.0 </li> </ul> Returns (DataFrame) <p>DataFrame that shows the differences stacked side by side.</p><p>The resulting index will be a MultiIndex with 'self' and 'other' stacked alternately at the inner level.</p> Raises <ul> <li><code>ValueError</code> \u2014 When the two DataFrames don't have identical labels or shape.</li> </ul> See Also <p>Series.compare : Compare with another Series and show differences.DataFrame.equals : Test whether two objects contain the same elements.</p> <p>Notes</p> <p>Matching NaNs will not appear as a difference.</p> <p>Can only compare identically-labeled (i.e. same shape, identical row and column labels) DataFrames</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(...     {\n...         \"col1\": [\"a\", \"a\", \"b\", \"b\", \"a\"],\n...         \"col2\": [1.0, 2.0, 3.0, np.nan, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0]\n...     },\n...     columns=[\"col1\", \"col2\", \"col3\"],\n... )\n&gt;&gt;&gt; df\n  col1  col2  col3\n0    a   1.0   1.0\n1    a   2.0   2.0\n2    b   3.0   3.0\n3    b   NaN   4.0\n4    a   5.0   5.0\n</code></pre> <pre><code>&gt;&gt;&gt; df2 = df.copy()\n&gt;&gt;&gt; df2.loc[0, 'col1'] = 'c'\n&gt;&gt;&gt; df2.loc[2, 'col3'] = 4.0\n&gt;&gt;&gt; df2\n  col1  col2  col3\n0    c   1.0   1.0\n1    a   2.0   2.0\n2    b   3.0   4.0\n3    b   NaN   4.0\n4    a   5.0   5.0\n</code></pre> <p>Align the differences on columns</p> <pre><code>&gt;&gt;&gt; df.compare(df2)\n  col1       col3\n  self other self other\n0    a     c  NaN   NaN\n2  NaN   NaN  3.0   4.0\n</code></pre> <p>Assign result_names</p> <pre><code>&gt;&gt;&gt; df.compare(df2, result_names=(\"left\", \"right\"))\n  col1       col3\n  left right left right\n0    a     c  NaN   NaN\n2  NaN   NaN  3.0   4.0\n</code></pre> <p>Stack the differences on rows</p> <pre><code>&gt;&gt;&gt; df.compare(df2, align_axis=0)\n        col1  col3\n0 self     a   NaN\n  other    c   NaN\n2 self   NaN   3.0\n  other  NaN   4.0\n</code></pre> <p>Keep the equal values</p> <pre><code>&gt;&gt;&gt; df.compare(df2, keep_equal=True)\n  col1       col3\n  self other self other\n0    a     c  1.0   1.0\n2    b     b  3.0   4.0\n</code></pre> <p>Keep all original rows and columns</p> <pre><code>&gt;&gt;&gt; df.compare(df2, keep_shape=True)\n  col1       col2       col3\n  self other self other self other\n0    a     c  NaN   NaN  NaN   NaN\n1  NaN   NaN  NaN   NaN  NaN   NaN\n2  NaN   NaN  NaN   NaN  3.0   4.0\n3  NaN   NaN  NaN   NaN  NaN   NaN\n4  NaN   NaN  NaN   NaN  NaN   NaN\n</code></pre> <p>Keep all original rows and columns and also all original values</p> <pre><code>&gt;&gt;&gt; df.compare(df2, keep_shape=True, keep_equal=True)\n  col1       col2       col3\n  self other self other self other\n0    a     c  1.0   1.0  1.0   1.0\n1    a     a  2.0   2.0  2.0   2.0\n2    b     b  3.0   3.0  3.0   4.0\n3    b     b  NaN   NaN  4.0   4.0\n4    a     a  5.0   5.0  5.0   5.0\n</code></pre> method &lt;/&gt; <p>Perform column-wise combine with another DataFrame.</p><p>Combines a DataFrame with <code>other</code> DataFrame using <code>func</code> to element-wise combine columns. The row and column indexes of the resulting DataFrame will be the union of the two.</p> Parameters <ul> <li><code>other</code> (DataFrame) \u2014 The DataFrame to merge column-wise.</li> <li><code>func</code> (function) \u2014 Function that takes two series as inputs and return a Series or ascalar. Used to merge the two dataframes column by columns. </li> <li><code>fill_value</code> (scalar value, default None) \u2014 The value to fill NaNs with prior to passing any column to themerge func. </li> <li><code>overwrite</code> (bool, default True) \u2014 If True, columns in <code>self</code> that do not exist in <code>other</code> will beoverwritten with NaNs. </li> </ul> Returns (DataFrame) <p>Combination of the provided DataFrames.</p> See Also <p>DataFrame.combinefirst : Combine two DataFrame objects and default to    non-null values in frame calling the method.</p> Examples <p>Combine using a simple function that chooses the smaller column.</p><pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'A': [0, 0], 'B': [4, 4]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'A': [1, 1], 'B': [3, 3]})\n&gt;&gt;&gt; take_smaller = lambda s1, s2: s1 if s1.sum() &lt; s2.sum() else s2\n&gt;&gt;&gt; df1.combine(df2, take_smaller)\n   A  B\n0  0  3\n1  0  3\n</code></pre> <p>Example using a true element-wise combine function.</p> <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'A': [5, 0], 'B': [2, 4]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'A': [1, 1], 'B': [3, 3]})\n&gt;&gt;&gt; df1.combine(df2, np.minimum)\n   A  B\n0  1  2\n1  0  3\n</code></pre> <p>Using <code>fill_value</code> fills Nones prior to passing the column to the merge function.</p> <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'A': [0, 0], 'B': [None, 4]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'A': [1, 1], 'B': [3, 3]})\n&gt;&gt;&gt; df1.combine(df2, take_smaller, fill_value=-5)\n   A    B\n0  0 -5.0\n1  0  4.0\n</code></pre> <p>However, if the same element in both dataframes is None, that None is preserved</p> <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'A': [0, 0], 'B': [None, 4]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'A': [1, 1], 'B': [None, 3]})\n&gt;&gt;&gt; df1.combine(df2, take_smaller, fill_value=-5)\n    A    B\n0  0 -5.0\n1  0  3.0\n</code></pre> <p>Example that demonstrates the use of <code>overwrite</code> and behavior when the axis differ between the dataframes.</p> <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'A': [0, 0], 'B': [4, 4]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'B': [3, 3], 'C': [-10, 1], }, index=[1, 2])\n&gt;&gt;&gt; df1.combine(df2, take_smaller)\n     A    B     C\n0  NaN  NaN   NaN\n1  NaN  3.0 -10.0\n2  NaN  3.0   1.0\n</code></pre> <pre><code>&gt;&gt;&gt; df1.combine(df2, take_smaller, overwrite=False)\n     A    B     C\n0  0.0  NaN   NaN\n1  0.0  3.0 -10.0\n2  NaN  3.0   1.0\n</code></pre> <p>Demonstrating the preference of the passed in dataframe.</p> <pre><code>&gt;&gt;&gt; df2 = pd.DataFrame({'B': [3, 3], 'C': [1, 1], }, index=[1, 2])\n&gt;&gt;&gt; df2.combine(df1, take_smaller)\n   A    B   C\n0  0.0  NaN NaN\n1  0.0  3.0 NaN\n2  NaN  3.0 NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df2.combine(df1, take_smaller, overwrite=False)\n     A    B   C\n0  0.0  NaN NaN\n1  0.0  3.0 1.0\n2  NaN  3.0 1.0\n</code></pre> method &lt;/&gt; <p>Update null elements with value in the same location in <code>other</code>.</p><p>Combine two DataFrame objects by filling null values in one DataFrame with non-null values from other DataFrame. The row and column indexes of the resulting DataFrame will be the union of the two. The resulting dataframe contains the 'first' dataframe values and overrides the second one values where both first.loc[index, col] and second.loc[index, col] are not missing values, upon calling first.combine_first(second).</p> Parameters <ul> <li><code>other</code> (DataFrame) \u2014 Provided DataFrame to use to fill null values.</li> </ul> Returns (DataFrame) <p>The result of combining the provided DataFrame with the other object.</p> See Also <p>DataFrame.combine : Perform series-wise operation on two DataFrames    using a given function.</p> Examples <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'A': [None, 0], 'B': [None, 4]})&gt;&gt;&gt; df2 = pd.DataFrame({'A': [1, 1], 'B': [3, 3]})\n&gt;&gt;&gt; df1.combine_first(df2)\n     A    B\n0  1.0  3.0\n1  0.0  4.0\n</code></pre> <p>Null values still persist if the location of that null value does not exist in <code>other</code></p> <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'A': [None, 0], 'B': [4, None]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'B': [3, 3], 'C': [1, 1]}, index=[1, 2])\n&gt;&gt;&gt; df1.combine_first(df2)\n     A    B    C\n0  NaN  4.0  NaN\n1  0.0  3.0  1.0\n2  NaN  3.0  1.0\n</code></pre> method &lt;/&gt; <p>Modify in place using non-NA values from another DataFrame.</p><p>Aligns on indices. There is no return value.</p> Parameters <ul> <li><code>other</code> (DataFrame, or object coercible into a DataFrame) \u2014 Should have at least one matching index/column labelwith the original DataFrame. If a Series is passed, its name attribute must be set, and that will be used as the column name to align with the original DataFrame. </li> <li><code>join</code> ({'left'}, default 'left') \u2014 Only left join is implemented, keeping the index and columns of theoriginal object. </li> <li><code>overwrite</code> (bool, default True) \u2014 How to handle non-NA values for overlapping keys:<ul> <li>True: overwrite original DataFrame's values   with values from <code>other</code>.</li> <li>False: only update values that are NA in   the original DataFrame.</li> </ul> </li> <li><code>filter_func</code> (callable(1d-array) -&gt; bool 1d-array, optional) \u2014 Can choose to replace values other than NA. Return True for valuesthat should be updated. </li> <li><code>errors</code> ({'raise', 'ignore'}, default 'ignore') \u2014 If 'raise', will raise a ValueError if the DataFrame and <code>other</code>both contain non-NA data in the same place. </li> </ul> Returns (None) <p>This method directly changes calling object.</p> Raises <ul> <li><code>NotImplementedError</code> \u2014 <ul><li>If <code>join != 'left'</code></li> </ul> </li> <li><code>ValueError</code> \u2014 <ul><li>When <code>errors='raise'</code> and there's overlapping non-NA data.</li> <li>When <code>errors</code> is not either <code>'ignore'</code> or <code>'raise'</code></li> </ul> </li> </ul> See Also <p>dict.update : Similar method for dictionaries.DataFrame.merge : For column(s)-on-column(s) operations.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2, 3],...                    'B': [400, 500, 600]})\n&gt;&gt;&gt; new_df = pd.DataFrame({'B': [4, 5, 6],\n...                        'C': [7, 8, 9]})\n&gt;&gt;&gt; df.update(new_df)\n&gt;&gt;&gt; df\n   A  B\n0  1  4\n1  2  5\n2  3  6\n</code></pre> <p>The DataFrame's length does not increase as a result of the update, only values at matching index/column labels are updated.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': ['a', 'b', 'c'],\n...                    'B': ['x', 'y', 'z']})\n&gt;&gt;&gt; new_df = pd.DataFrame({'B': ['d', 'e', 'f', 'g', 'h', 'i']})\n&gt;&gt;&gt; df.update(new_df)\n&gt;&gt;&gt; df\n   A  B\n0  a  d\n1  b  e\n2  c  f\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': ['a', 'b', 'c'],\n...                    'B': ['x', 'y', 'z']})\n&gt;&gt;&gt; new_df = pd.DataFrame({'B': ['d', 'f']}, index=[0, 2])\n&gt;&gt;&gt; df.update(new_df)\n&gt;&gt;&gt; df\n   A  B\n0  a  d\n1  b  y\n2  c  f\n</code></pre> <p>For Series, its name attribute must be set.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': ['a', 'b', 'c'],\n...                    'B': ['x', 'y', 'z']})\n&gt;&gt;&gt; new_column = pd.Series(['d', 'e', 'f'], name='B')\n&gt;&gt;&gt; df.update(new_column)\n&gt;&gt;&gt; df\n   A  B\n0  a  d\n1  b  e\n2  c  f\n</code></pre> <p>If <code>other</code> contains NaNs the corresponding values are not updated in the original dataframe.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2, 3],\n...                    'B': [400., 500., 600.]})\n&gt;&gt;&gt; new_df = pd.DataFrame({'B': [4, np.nan, 6]})\n&gt;&gt;&gt; df.update(new_df)\n&gt;&gt;&gt; df\n   A      B\n0  1    4.0\n1  2  500.0\n2  3    6.0\n</code></pre> method &lt;/&gt; <p>Group DataFrame using a mapper or by a Series of columns.</p><p>A groupby operation involves some combination of splitting the object, applying a function, and combining the results. This can be used to group large amounts of data and compute operations on these groups.</p> Parameters <ul> <li><code>by</code> (mapping, function, label, pd.Grouper or list of such) \u2014 Used to determine the groups for the groupby.If <code>by</code> is a function, it's called on each value of the object's index. If a dict or Series is passed, the Series or dict VALUES will be used to determine the groups (the Series' values are first aligned; see <code>.align()</code> method). If a list or ndarray of length equal to the selected axis is passed (see the <code>groupby user guide &lt;https://pandas.pydata.org/pandas-docs/stable/user_guide/groupby.html#splitting-an-object-into-groups&gt;</code>_), the values are used as-is to determine the groups. A label or list of labels may be passed to group by the columns in <code>self</code>. Notice that a tuple is interpreted as a (single) key. </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Split along rows (0) or columns (1). For <code>Series</code> this parameteris unused and defaults to 0. .. deprecated:: 2.1.0 <pre><code>Will be removed and behave like axis=0 in a future version.\nFor ``axis=1``, do ``frame.T.groupby(...)`` instead.\n</code></pre> </li> <li><code>level</code> (int, level name, or sequence of such, default None) \u2014 If the axis is a MultiIndex (hierarchical), group by a particularlevel or levels. Do not specify both <code>by</code> and <code>level</code>. </li> <li><code>as_index</code> (bool, default True) \u2014 Return object with group labels as theindex. Only relevant for DataFrame input. as_index=False is effectively \"SQL-style\" grouped output. This argument has no effect on filtrations (see the <code>filtrations in the user guide &lt;https://pandas.pydata.org/docs/dev/user_guide/groupby.html#filtration&gt;</code>), such as <code>head()</code>, <code>tail()</code>, <code>nth()</code> and in transformations (see the <code>transformations in the user guide &lt;https://pandas.pydata.org/docs/dev/user_guide/groupby.html#transformation&gt;</code>). </li> <li><code>sort</code> (bool, default True) \u2014 Sort group keys. Get better performance by turning this off.Note this does not influence the order of observations within each group. Groupby preserves the order of rows within each group. If False, the groups will appear in the same order as they did in the original DataFrame. This argument has no effect on filtrations (see the <code>filtrations in the user guide &lt;https://pandas.pydata.org/docs/dev/user_guide/groupby.html#filtration&gt;</code>), such as <code>head()</code>, <code>tail()</code>, <code>nth()</code> and in transformations (see the <code>transformations in the user guide &lt;https://pandas.pydata.org/docs/dev/user_guide/groupby.html#transformation&gt;</code>). .. versionchanged:: 2.0.0 <pre><code>Specifying ``sort=False`` with an ordered categorical grouper will no\nlonger sort the values.\n</code></pre> </li> <li><code>group_keys</code> (bool, default True) \u2014 When calling apply and the <code>by</code> argument produces a like-indexed(i.e. :ref:<code>a transform &lt;groupby.transform&gt;</code>) result, add group keys to index to identify pieces. By default group keys are not included when the result's index (and column) labels match the inputs, and are included otherwise. .. versionchanged:: 1.5.0 Warns that <code>group_keys</code> will no longer be ignored when the    result from <code>apply</code> is a like-indexed Series or DataFrame.    Specify <code>group_keys</code> explicitly to include the group keys or    not. .. versionchanged:: 2.0.0 <code>group_keys</code> now defaults to <code>True</code>. </li> <li><code>observed</code> (bool, default False) \u2014 This only applies if any of the groupers are Categoricals.If True: only show observed values for categorical groupers. If False: show all values for categorical groupers. .. deprecated:: 2.1.0 <pre><code>The default value will change to True in a future version of pandas.\n</code></pre> </li> <li><code>dropna</code> (bool, default True) \u2014 If True, and if group keys contain NA values, NA values togetherwith row/column will be dropped. If False, NA values will also be treated as the key in groups. </li> </ul> Returns (pandas.api.typing.DataFrameGroupBy) <p>Returns a groupby object that contains information about the groups.</p> See Also <p>resample : Convenience method for frequency conversion and resampling    of time series.</p> <p>Notes</p> <p>See the <code>user guide &lt;https://pandas.pydata.org/pandas-docs/stable/groupby.html&gt;</code>__ for more detailed usage and examples, including splitting an object into groups, iterating through groups, selecting a group, aggregation, and more.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'Animal': ['Falcon', 'Falcon',...                               'Parrot', 'Parrot'],\n...                    'Max Speed': [380., 370., 24., 26.]})\n&gt;&gt;&gt; df\n   Animal  Max Speed\n0  Falcon      380.0\n1  Falcon      370.0\n2  Parrot       24.0\n3  Parrot       26.0\n&gt;&gt;&gt; df.groupby(['Animal']).mean()\n        Max Speed\nAnimal\nFalcon      375.0\nParrot       25.0\n</code></pre> <p>Hierarchical Indexes</p> <p>We can groupby different levels of a hierarchical index using the <code>level</code> parameter:</p> <pre><code>&gt;&gt;&gt; arrays = [['Falcon', 'Falcon', 'Parrot', 'Parrot'],\n...           ['Captive', 'Wild', 'Captive', 'Wild']]\n&gt;&gt;&gt; index = pd.MultiIndex.from_arrays(arrays, names=('Animal', 'Type'))\n&gt;&gt;&gt; df = pd.DataFrame({'Max Speed': [390., 350., 30., 20.]},\n...                   index=index)\n&gt;&gt;&gt; df\n                Max Speed\nAnimal Type\nFalcon Captive      390.0\n       Wild         350.0\nParrot Captive       30.0\n       Wild          20.0\n&gt;&gt;&gt; df.groupby(level=0).mean()\n        Max Speed\nAnimal\nFalcon      370.0\nParrot       25.0\n&gt;&gt;&gt; df.groupby(level=\"Type\").mean()\n         Max Speed\nType\nCaptive      210.0\nWild         185.0\n</code></pre> <p>We can also choose to include NA in group keys or not by setting <code>dropna</code> parameter, the default setting is <code>True</code>.</p> <pre><code>&gt;&gt;&gt; l = [[1, 2, 3], [1, None, 4], [2, 1, 3], [1, 2, 2]]\n&gt;&gt;&gt; df = pd.DataFrame(l, columns=[\"a\", \"b\", \"c\"])\n</code></pre> <pre><code>&gt;&gt;&gt; df.groupby(by=[\"b\"]).sum()\n    a   c\nb\n1.0 2   3\n2.0 2   5\n</code></pre> <pre><code>&gt;&gt;&gt; df.groupby(by=[\"b\"], dropna=False).sum()\n    a   c\nb\n1.0 2   3\n2.0 2   5\nNaN 1   4\n</code></pre> <pre><code>&gt;&gt;&gt; l = [[\"a\", 12, 12], [None, 12.3, 33.], [\"b\", 12.3, 123], [\"a\", 1, 1]]\n&gt;&gt;&gt; df = pd.DataFrame(l, columns=[\"a\", \"b\", \"c\"])\n</code></pre> <pre><code>&gt;&gt;&gt; df.groupby(by=\"a\").sum()\n    b     c\na\na   13.0   13.0\nb   12.3  123.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.groupby(by=\"a\", dropna=False).sum()\n    b     c\na\na   13.0   13.0\nb   12.3  123.0\nNaN 12.3   33.0\n</code></pre> <p>When using <code>.apply()</code>, use <code>group_keys</code> to include or exclude the group keys. The <code>group_keys</code> argument defaults to <code>True</code> (include).</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'Animal': ['Falcon', 'Falcon',\n...                               'Parrot', 'Parrot'],\n...                    'Max Speed': [380., 370., 24., 26.]})\n&gt;&gt;&gt; df.groupby(\"Animal\", group_keys=True)[['Max Speed']].apply(lambda x: x)\n          Max Speed\nAnimal\nFalcon 0      380.0\n       1      370.0\nParrot 2       24.0\n       3       26.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.groupby(\"Animal\", group_keys=False)[['Max Speed']].apply(lambda x: x)\n   Max Speed\n0      380.0\n1      370.0\n2       24.0\n3       26.0\n</code></pre> method &lt;/&gt; <p>Return reshaped DataFrame organized by given index / column values.</p><p>Reshape data (produce a \"pivot\" table) based on column values. Uses unique values from specified <code>index</code> / <code>columns</code> to form axes of the resulting DataFrame. This function does not support data aggregation, multiple values will result in a MultiIndex in the columns. See the :ref:<code>User Guide &lt;reshaping&gt;</code> for more on reshaping.</p> Parameters <ul> <li><code>columns</code> (str or object or a list of str) \u2014 Column to use to make new frame's columns.</li> <li><code>index</code> (str or object or a list of str, optional) \u2014 Column to use to make new frame's index. If not given, uses existing index.</li> <li><code>values</code> (str, object or a list of the previous, optional) \u2014 Column(s) to use for populating new frame's values. If notspecified, all remaining columns will be used and the result will have hierarchically indexed columns. </li> </ul> Returns (DataFrame) <p>Returns reshaped DataFrame.</p> Raises <ul> <li><code>ValueError</code> \u2014 When there are any <code>index</code>, <code>columns</code> combinations with multiplevalues. <code>DataFrame.pivot_table</code> when you need to aggregate. </li> </ul> See Also <p>DataFrame.pivottable : Generalization of pivot that can handle    duplicate values for one index/column pair. DataFrame.unstack : Pivot based on the index values instead of a     column. wide_to_long : Wide panel to long format. Less flexible but more     user-friendly than melt.</p> <p>Notes</p> <p>For finer-tuned control, see hierarchical indexing documentation along with the related stack/unstack methods.</p> <p>Reference :ref:<code>the user guide &lt;reshaping.pivot&gt;</code> for more examples.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'foo': ['one', 'one', 'one', 'two', 'two',...                            'two'],\n...                    'bar': ['A', 'B', 'C', 'A', 'B', 'C'],\n...                    'baz': [1, 2, 3, 4, 5, 6],\n...                    'zoo': ['x', 'y', 'z', 'q', 'w', 't']})\n&gt;&gt;&gt; df\n    foo   bar  baz  zoo\n0   one   A    1    x\n1   one   B    2    y\n2   one   C    3    z\n3   two   A    4    q\n4   two   B    5    w\n5   two   C    6    t\n</code></pre> <pre><code>&gt;&gt;&gt; df.pivot(index='foo', columns='bar', values='baz')\nbar  A   B   C\nfoo\none  1   2   3\ntwo  4   5   6\n</code></pre> <pre><code>&gt;&gt;&gt; df.pivot(index='foo', columns='bar')['baz']\nbar  A   B   C\nfoo\none  1   2   3\ntwo  4   5   6\n</code></pre> <pre><code>&gt;&gt;&gt; df.pivot(index='foo', columns='bar', values=['baz', 'zoo'])\n      baz       zoo\nbar   A  B  C   A  B  C\nfoo\none   1  2  3   x  y  z\ntwo   4  5  6   q  w  t\n</code></pre> <p>You could also assign a list of column names or a list of index names.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...        \"lev1\": [1, 1, 1, 2, 2, 2],\n...        \"lev2\": [1, 1, 2, 1, 1, 2],\n...        \"lev3\": [1, 2, 1, 2, 1, 2],\n...        \"lev4\": [1, 2, 3, 4, 5, 6],\n...        \"values\": [0, 1, 2, 3, 4, 5]})\n&gt;&gt;&gt; df\n    lev1 lev2 lev3 lev4 values\n0   1    1    1    1    0\n1   1    1    2    2    1\n2   1    2    1    3    2\n3   2    1    2    4    3\n4   2    1    1    5    4\n5   2    2    2    6    5\n</code></pre> <pre><code>&gt;&gt;&gt; df.pivot(index=\"lev1\", columns=[\"lev2\", \"lev3\"], values=\"values\")\nlev2    1         2\nlev3    1    2    1    2\nlev1\n1     0.0  1.0  2.0  NaN\n2     4.0  3.0  NaN  5.0\n</code></pre> <pre><code>&gt;&gt;&gt; df.pivot(index=[\"lev1\", \"lev2\"], columns=[\"lev3\"], values=\"values\")\n      lev3    1    2\nlev1  lev2\n   1     1  0.0  1.0\n         2  2.0  NaN\n   2     1  4.0  3.0\n         2  NaN  5.0\n</code></pre> <p>A ValueError is raised if there are any duplicates.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"foo\": ['one', 'one', 'two', 'two'],\n...                    \"bar\": ['A', 'A', 'B', 'C'],\n...                    \"baz\": [1, 2, 3, 4]})\n&gt;&gt;&gt; df\n   foo bar  baz\n0  one   A    1\n1  one   A    2\n2  two   B    3\n3  two   C    4\n</code></pre> <p>Notice that the first two rows are the same for our <code>index</code> and <code>columns</code> arguments.</p> <pre><code>&gt;&gt;&gt; df.pivot(index='foo', columns='bar', values='baz')\nTraceback (most recent call last):\n   ...\nValueError: Index contains duplicate entries, cannot reshape\n</code></pre> method &lt;/&gt; <p>Create a spreadsheet-style pivot table as a DataFrame.</p><p>The levels in the pivot table will be stored in MultiIndex objects (hierarchical indexes) on the index and columns of the result DataFrame.</p> Parameters <ul> <li><code>values</code> (list-like or scalar, optional) \u2014 Column or columns to aggregate.</li> <li><code>index</code> (column, Grouper, array, or list of the previous) \u2014 Keys to group by on the pivot table index. If a list is passed,it can contain any of the other types (except list). If an array is passed, it must be the same length as the data and will be used in the same manner as column values. </li> <li><code>columns</code> (column, Grouper, array, or list of the previous) \u2014 Keys to group by on the pivot table column. If a list is passed,it can contain any of the other types (except list). If an array is passed, it must be the same length as the data and will be used in the same manner as column values. </li> <li><code>aggfunc</code> (function, list of functions, dict, default \"mean\") \u2014 If a list of functions is passed, the resulting pivot table will havehierarchical columns whose top level are the function names (inferred from the function objects themselves). If a dict is passed, the key is column to aggregate and the value is function or list of functions. If <code>margin=True</code>, aggfunc will be used to calculate the partial aggregates. </li> <li><code>fill_value</code> (scalar, default None) \u2014 Value to replace missing values with (in the resulting pivot table,after aggregation). </li> <li><code>margins</code> (bool, default False) \u2014 If <code>margins=True</code>, special <code>All</code> columns and rowswill be added with partial group aggregates across the categories on the rows and columns. </li> <li><code>dropna</code> (bool, default True) \u2014 Do not include columns whose entries are all NaN. If True,rows with a NaN value in any column will be omitted before computing margins. </li> <li><code>margins_name</code> (str, default 'All') \u2014 Name of the row / column that will contain the totalswhen margins is True. </li> <li><code>observed</code> (bool, default False) \u2014 This only applies if any of the groupers are Categoricals.If True: only show observed values for categorical groupers. If False: show all values for categorical groupers. .. deprecated:: 2.2.0 <pre><code>The default value of ``False`` is deprecated and will change to\n``True`` in a future version of pandas.\n</code></pre> </li> <li><code>sort</code> (bool, default True) \u2014 Specifies if the result should be sorted... versionadded:: 1.3.0 </li> </ul> Returns (DataFrame) <p>An Excel style pivot table.</p> See Also <p>DataFrame.pivot : Pivot without aggregation that can handle    non-numeric data. DataFrame.melt: Unpivot a DataFrame from wide to long format,     optionally leaving identifiers set. wide_to_long : Wide panel to long format. Less flexible but more     user-friendly than melt.</p> <p>Notes</p> <p>Reference :ref:<code>the user guide &lt;reshaping.pivot&gt;</code> for more examples.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [\"foo\", \"foo\", \"foo\", \"foo\", \"foo\",...                          \"bar\", \"bar\", \"bar\", \"bar\"],\n...                    \"B\": [\"one\", \"one\", \"one\", \"two\", \"two\",\n...                          \"one\", \"one\", \"two\", \"two\"],\n...                    \"C\": [\"small\", \"large\", \"large\", \"small\",\n...                          \"small\", \"large\", \"small\", \"small\",\n...                          \"large\"],\n...                    \"D\": [1, 2, 2, 3, 3, 4, 5, 6, 7],\n...                    \"E\": [2, 4, 5, 5, 6, 6, 8, 9, 9]})\n&gt;&gt;&gt; df\n     A    B      C  D  E\n0  foo  one  small  1  2\n1  foo  one  large  2  4\n2  foo  one  large  2  5\n3  foo  two  small  3  5\n4  foo  two  small  3  6\n5  bar  one  large  4  6\n6  bar  one  small  5  8\n7  bar  two  small  6  9\n8  bar  two  large  7  9\n</code></pre> <p>This first example aggregates values by taking the sum.</p> <pre><code>&gt;&gt;&gt; table = pd.pivot_table(df, values='D', index=['A', 'B'],\n...                        columns=['C'], aggfunc=\"sum\")\n&gt;&gt;&gt; table\nC        large  small\nA   B\nbar one    4.0    5.0\n    two    7.0    6.0\nfoo one    4.0    1.0\n    two    NaN    6.0\n</code></pre> <p>We can also fill missing values using the <code>fill_value</code> parameter.</p> <pre><code>&gt;&gt;&gt; table = pd.pivot_table(df, values='D', index=['A', 'B'],\n...                        columns=['C'], aggfunc=\"sum\", fill_value=0)\n&gt;&gt;&gt; table\nC        large  small\nA   B\nbar one      4      5\n    two      7      6\nfoo one      4      1\n    two      0      6\n</code></pre> <p>The next example aggregates by taking the mean across multiple columns.</p> <pre><code>&gt;&gt;&gt; table = pd.pivot_table(df, values=['D', 'E'], index=['A', 'C'],\n...                        aggfunc={'D': \"mean\", 'E': \"mean\"})\n&gt;&gt;&gt; table\n                D         E\nA   C\nbar large  5.500000  7.500000\n    small  5.500000  8.500000\nfoo large  2.000000  4.500000\n    small  2.333333  4.333333\n</code></pre> <p>We can also calculate multiple types of aggregations for any given value column.</p> <pre><code>&gt;&gt;&gt; table = pd.pivot_table(df, values=['D', 'E'], index=['A', 'C'],\n...                        aggfunc={'D': \"mean\",\n...                                 'E': [\"min\", \"max\", \"mean\"]})\n&gt;&gt;&gt; table\n                  D   E\n               mean max      mean  min\nA   C\nbar large  5.500000   9  7.500000    6\n    small  5.500000   9  8.500000    8\nfoo large  2.000000   5  4.500000    4\n    small  2.333333   6  4.333333    2\n</code></pre> method &lt;/&gt; <p>Stack the prescribed level(s) from columns to index.</p><p>Return a reshaped DataFrame or Series having a multi-level index with one or more new inner-most levels compared to the current DataFrame. The new inner-most levels are created by pivoting the columns of the current dataframe:</p> <ul> <li>if the columns have a single level, the output is a Series;</li> <li>if the columns have multiple levels, the new index     level(s) is (are) taken from the prescribed level(s) and     the output is a DataFrame.</li> </ul> Parameters <ul> <li><code>level</code> (int, str, list, default -1) \u2014 Level(s) to stack from the column axis onto the indexaxis, defined as one index or label, or a list of indices or labels. </li> <li><code>dropna</code> (bool, default True) \u2014 Whether to drop rows in the resulting Frame/Series withmissing values. Stacking a column level onto the index axis can create combinations of index and column values that are missing from the original dataframe. See Examples section. </li> <li><code>sort</code> (bool, default True) \u2014 Whether to sort the levels of the resulting MultiIndex.</li> <li><code>future_stack</code> (bool, default False) \u2014 Whether to use the new implementation that will replace the currentimplementation in pandas 3.0. When True, dropna and sort have no impact on the result and must remain unspecified. See :ref:<code>pandas 2.1.0 Release notes &lt;whatsnew_210.enhancements.new_stack&gt;</code> for more details. </li> </ul> Returns (DataFrame or Series) <p>Stacked dataframe or series.</p> See Also <p>DataFrame.unstack : Unstack prescribed level(s) from index axis     onto column axis. DataFrame.pivot : Reshape dataframe from long format to wide      format. DataFrame.pivottable : Create a spreadsheet-style pivot table      as a DataFrame.</p> <p>Notes</p> <p>The function is named by analogy with a collection of books being reorganized from being side by side on a horizontal position (the columns of the dataframe) to being stacked vertically on top of each other (in the index of the dataframe).</p> <p>Reference :ref:<code>the user guide &lt;reshaping.stacking&gt;</code> for more examples.</p> Examples <p>Single level columns</p><pre><code>&gt;&gt;&gt; df_single_level_cols = pd.DataFrame([[0, 1], [2, 3]],\n...                                     index=['cat', 'dog'],\n...                                     columns=['weight', 'height'])\n</code></pre> <p>Stacking a dataframe with a single level column axis returns a Series:</p> <pre><code>&gt;&gt;&gt; df_single_level_cols\n     weight height\ncat       0      1\ndog       2      3\n&gt;&gt;&gt; df_single_level_cols.stack(future_stack=True)\ncat  weight    0\n     height    1\ndog  weight    2\n     height    3\ndtype: int64\n</code></pre> <p>Multi level columns: simple case</p> <pre><code>&gt;&gt;&gt; multicol1 = pd.MultiIndex.from_tuples([('weight', 'kg'),\n...                                        ('weight', 'pounds')])\n&gt;&gt;&gt; df_multi_level_cols1 = pd.DataFrame([[1, 2], [2, 4]],\n...                                     index=['cat', 'dog'],\n...                                     columns=multicol1)\n</code></pre> <p>Stacking a dataframe with a multi-level column axis:</p> <pre><code>&gt;&gt;&gt; df_multi_level_cols1\n     weight\n         kg    pounds\ncat       1        2\ndog       2        4\n&gt;&gt;&gt; df_multi_level_cols1.stack(future_stack=True)\n            weight\ncat kg           1\n    pounds       2\ndog kg           2\n    pounds       4\n</code></pre> <p>Missing values</p> <pre><code>&gt;&gt;&gt; multicol2 = pd.MultiIndex.from_tuples([('weight', 'kg'),\n...                                        ('height', 'm')])\n&gt;&gt;&gt; df_multi_level_cols2 = pd.DataFrame([[1.0, 2.0], [3.0, 4.0]],\n...                                     index=['cat', 'dog'],\n...                                     columns=multicol2)\n</code></pre> <p>It is common to have missing values when stacking a dataframe with multi-level columns, as the stacked dataframe typically has more values than the original dataframe. Missing values are filled with NaNs:</p> <pre><code>&gt;&gt;&gt; df_multi_level_cols2\n    weight height\n        kg      m\ncat    1.0    2.0\ndog    3.0    4.0\n&gt;&gt;&gt; df_multi_level_cols2.stack(future_stack=True)\n        weight  height\ncat kg     1.0     NaN\n    m      NaN     2.0\ndog kg     3.0     NaN\n    m      NaN     4.0\n</code></pre> <p>Prescribing the level(s) to be stacked</p> <p>The first parameter controls which level or levels are stacked:</p> <pre><code>&gt;&gt;&gt; df_multi_level_cols2.stack(0, future_stack=True)\n             kg    m\ncat weight  1.0  NaN\n    height  NaN  2.0\ndog weight  3.0  NaN\n    height  NaN  4.0\n&gt;&gt;&gt; df_multi_level_cols2.stack([0, 1], future_stack=True)\ncat  weight  kg    1.0\n     height  m     2.0\ndog  weight  kg    3.0\n     height  m     4.0\ndtype: float64\n</code></pre> method &lt;/&gt; <p>Transform each element of a list-like to a row, replicating index values.</p> Parameters <ul> <li><code>column</code> (IndexLabel) \u2014 Column(s) to explode.For multiple columns, specify a non-empty list with each element be str or tuple, and all specified columns their list-like data on same row of the frame must have matching length. .. versionadded:: 1.3.0     Multi-column explode </li> <li><code>ignore_index</code> (bool, default False) \u2014 If True, the resulting index will be labeled 0, 1, \u2026, n - 1.</li> </ul> Returns (DataFrame) <p>Exploded lists to rows of the subset columns;index will be duplicated for these rows.</p> Raises <ul> <li><code>ValueError</code> \u2014 <ul><li>If columns of the frame are not unique.</li> <li>If specified columns to explode is empty list.</li> <li>If specified columns to explode have not matching count of   elements rowwise in the frame.</li> </ul> </li> </ul> See Also <p>DataFrame.unstack : Pivot a level of the (necessarily hierarchical)    index labels. DataFrame.melt : Unpivot a DataFrame from wide format to long format. Series.explode : Explode a DataFrame from list-like columns to long format.</p> <p>Notes</p> <p>This routine will explode list-likes including lists, tuples, sets, Series, and np.ndarray. The result dtype of the subset rows will be object. Scalars will be returned unchanged, and empty list-likes will result in a np.nan for that row. In addition, the ordering of rows in the output will be non-deterministic when exploding sets.</p> <p>Reference :ref:<code>the user guide &lt;reshaping.explode&gt;</code> for more examples.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [[0, 1, 2], 'foo', [], [3, 4]],...                    'B': 1,\n...                    'C': [['a', 'b', 'c'], np.nan, [], ['d', 'e']]})\n&gt;&gt;&gt; df\n           A  B          C\n0  [0, 1, 2]  1  [a, b, c]\n1        foo  1        NaN\n2         []  1         []\n3     [3, 4]  1     [d, e]\n</code></pre> <p>Single-column explode.</p> <pre><code>&gt;&gt;&gt; df.explode('A')\n     A  B          C\n0    0  1  [a, b, c]\n0    1  1  [a, b, c]\n0    2  1  [a, b, c]\n1  foo  1        NaN\n2  NaN  1         []\n3    3  1     [d, e]\n3    4  1     [d, e]\n</code></pre> <p>Multi-column explode.</p> <pre><code>&gt;&gt;&gt; df.explode(list('AC'))\n     A  B    C\n0    0  1    a\n0    1  1    b\n0    2  1    c\n1  foo  1  NaN\n2  NaN  1  NaN\n3    3  1    d\n3    4  1    e\n</code></pre> method &lt;/&gt; <p>Pivot a level of the (necessarily hierarchical) index labels.</p><p>Returns a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels.</p> <p>If the index is not a MultiIndex, the output will be a Series (the analogue of stack when the columns are not a MultiIndex).</p> Parameters <ul> <li><code>level</code> (int, str, or list of these, default -1 (last level)) \u2014 Level(s) of index to unstack, can pass level name.</li> <li><code>fill_value</code> (int, str or dict) \u2014 Replace NaN with this value if the unstack produces missing values.</li> <li><code>sort</code> (bool, default True) \u2014 Sort the level(s) in the resulting MultiIndex columns.</li> </ul> See Also <p>DataFrame.pivot : Pivot a table based on column values.DataFrame.stack : Pivot a level of the column labels (inverse operation     from <code>unstack</code>).</p> <p>Notes</p> <p>Reference :ref:<code>the user guide &lt;reshaping.stacking&gt;</code> for more examples.</p> Examples <pre><code>&gt;&gt;&gt; index = pd.MultiIndex.from_tuples([('one', 'a'), ('one', 'b'),...                                    ('two', 'a'), ('two', 'b')])\n&gt;&gt;&gt; s = pd.Series(np.arange(1.0, 5.0), index=index)\n&gt;&gt;&gt; s\none  a   1.0\n     b   2.0\ntwo  a   3.0\n     b   4.0\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; s.unstack(level=-1)\n     a   b\none  1.0  2.0\ntwo  3.0  4.0\n</code></pre> <pre><code>&gt;&gt;&gt; s.unstack(level=0)\n   one  two\na  1.0   3.0\nb  2.0   4.0\n</code></pre> <pre><code>&gt;&gt;&gt; df = s.unstack(level=0)\n&gt;&gt;&gt; df.unstack()\none  a  1.0\n     b  2.0\ntwo  a  3.0\n     b  4.0\ndtype: float64\n</code></pre> method &lt;/&gt; <p>Unpivot a DataFrame from wide to long format, optionally leaving identifiers set.</p><p>This function is useful to massage a DataFrame into a format where one or more columns are identifier variables (<code>id_vars</code>), while all other columns, considered measured variables (<code>value_vars</code>), are \"unpivoted\" to the row axis, leaving just two non-identifier columns, 'variable' and 'value'.</p> Parameters <ul> <li><code>id_vars</code> (scalar, tuple, list, or ndarray, optional) \u2014 Column(s) to use as identifier variables.</li> <li><code>value_vars</code> (scalar, tuple, list, or ndarray, optional) \u2014 Column(s) to unpivot. If not specified, uses all columns thatare not set as <code>id_vars</code>. </li> <li><code>var_name</code> (scalar, default None) \u2014 Name to use for the 'variable' column. If None it uses<code>frame.columns.name</code> or 'variable'. </li> <li><code>value_name</code> (scalar, default 'value') \u2014 Name to use for the 'value' column, can't be an existing column label.</li> <li><code>col_level</code> (scalar, optional) \u2014 If columns are a MultiIndex then use this level to melt.</li> <li><code>ignore_index</code> (bool, default True) \u2014 If True, original index is ignored. If False, the original index is retained.Index labels will be repeated as necessary. </li> </ul> Returns (DataFrame) <p>Unpivoted DataFrame.</p> See Also <p>melt : Identical method.pivot_table : Create a spreadsheet-style pivot table as a DataFrame. DataFrame.pivot : Return reshaped DataFrame organized     by given index / column values. DataFrame.explode : Explode a DataFrame from list-like         columns to long format.</p> <p>Notes</p> <p>Reference :ref:<code>the user guide &lt;reshaping.melt&gt;</code> for more examples.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': {0: 'a', 1: 'b', 2: 'c'},...                    'B': {0: 1, 1: 3, 2: 5},\n...                    'C': {0: 2, 1: 4, 2: 6}})\n&gt;&gt;&gt; df\n   A  B  C\n0  a  1  2\n1  b  3  4\n2  c  5  6\n</code></pre> <pre><code>&gt;&gt;&gt; df.melt(id_vars=['A'], value_vars=['B'])\n   A variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n</code></pre> <pre><code>&gt;&gt;&gt; df.melt(id_vars=['A'], value_vars=['B', 'C'])\n   A variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n3  a        C      2\n4  b        C      4\n5  c        C      6\n</code></pre> <p>The names of 'variable' and 'value' columns can be customized:</p> <pre><code>&gt;&gt;&gt; df.melt(id_vars=['A'], value_vars=['B'],\n...         var_name='myVarname', value_name='myValname')\n   A myVarname  myValname\n0  a         B          1\n1  b         B          3\n2  c         B          5\n</code></pre> <p>Original index values can be kept around:</p> <pre><code>&gt;&gt;&gt; df.melt(id_vars=['A'], value_vars=['B', 'C'], ignore_index=False)\n   A variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n0  a        C      2\n1  b        C      4\n2  c        C      6\n</code></pre> <p>If you have multi-index columns:</p> <pre><code>&gt;&gt;&gt; df.columns = [list('ABC'), list('DEF')]\n&gt;&gt;&gt; df\n   A  B  C\n   D  E  F\n0  a  1  2\n1  b  3  4\n2  c  5  6\n</code></pre> <pre><code>&gt;&gt;&gt; df.melt(col_level=0, id_vars=['A'], value_vars=['B'])\n   A variable  value\n0  a        B      1\n1  b        B      3\n2  c        B      5\n</code></pre> <pre><code>&gt;&gt;&gt; df.melt(id_vars=[('A', 'D')], value_vars=[('B', 'E')])\n  (A, D) variable_0 variable_1  value\n0      a          B          E      1\n1      b          B          E      3\n2      c          B          E      5\n</code></pre> method &lt;/&gt; <p>First discrete difference of element.</p><p>Calculates the difference of a DataFrame element compared with another element in the DataFrame (default is element in previous row).</p> Parameters <ul> <li><code>periods</code> (int, default 1) \u2014 Periods to shift for calculating difference, accepts negativevalues. </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Take difference over rows (0) or columns (1).</li> </ul> Returns (DataFrame) <p>First differences of the Series.</p> See Also <p>DataFrame.pct_change: Percent change over given number of periods.DataFrame.shift: Shift index by desired number of periods with an     optional time freq. Series.diff: First discrete difference of object.</p> <p>Notes</p> <p>For boolean dtypes, this uses :meth:<code>operator.xor</code> rather than :meth:<code>operator.sub</code>. The result is calculated according to current dtype in DataFrame, however dtype of the result is always float64.</p> Examples <p>w</p><p>, , ) f c 1 4 9 6 5 6</p> <p>) c N 0 0 0 0 0</p> <p>n</p> <p>) c 0 3 7 3 0 8</p> <p>w</p> <p>) c N N N 0 0 0</p> <p>w</p> <p>) c 0 0 0 0 0 N</p> <p>e</p> <p>) ) a N 0</p> method &lt;/&gt; <p>Aggregate using one or more operations over the specified axis.</p> Parameters <ul> <li><code>func</code> (function, str, list or dict) \u2014 Function to use for aggregating the data. If a function, must eitherwork when passed a DataFrame or when passed to DataFrame.apply. Accepted combinations are: <ul> <li>function</li> <li>string function name</li> <li>list of functions and/or function names, e.g. <code>[np.sum, 'mean']</code></li> <li>dict of axis labels -&gt; functions, function names or list of such.</li> </ul> </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 If 0 or 'index': apply function to each column.If 1 or 'columns': apply function to each row. </li> <li><code>*args</code> \u2014 Positional arguments to pass to <code>func</code>.</li> <li><code>**kwargs</code> \u2014 Keyword arguments to pass to <code>func</code>.</li> </ul> Returns (scalar, Series or DataFrame) <p>:</p><p>n n s</p> See Also <p>DataFrame.apply : Perform any type of operations.DataFrame.transform : Perform transformation type operations. pandas.DataFrame.groupby : Perform operations over groups. pandas.DataFrame.resample : Perform operations over resampled bins. pandas.DataFrame.rolling : Perform operations over rolling window. pandas.DataFrame.expanding : Perform operations over expanding window. pandas.core.window.ewm.ExponentialMovingWindow : Perform operation over exponential     weighted window.</p> <p>Notes</p> <p>The aggregation operations are always performed over an axis, either the index (default) or the column axis. This behavior is different from <code>numpy</code> aggregation functions (<code>mean</code>, <code>median</code>, <code>prod</code>, <code>sum</code>, <code>std</code>, <code>var</code>), where the default is to compute the aggregation of the flattened array, e.g., <code>numpy.mean(arr_2d)</code> as opposed to <code>numpy.mean(arr_2d, axis=0)</code>.</p> <p><code>agg</code> is an alias for <code>aggregate</code>. Use the alias.</p> <p>Functions that mutate the passed object can produce unexpected behavior or errors and are not supported. See :ref:<code>gotchas.udf-mutation</code> for more details.</p> <p>A passed user-defined-function will be passed a Series for evaluation.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[1, 2, 3],...                    [4, 5, 6],\n...                    [7, 8, 9],\n...                    [np.nan, np.nan, np.nan]],\n...                   columns=['A', 'B', 'C'])\n</code></pre> <p>Aggregate these functions over the rows.</p> <pre><code>&gt;&gt;&gt; df.agg(['sum', 'min'])\n        A     B     C\nsum  12.0  15.0  18.0\nmin   1.0   2.0   3.0\n</code></pre> <p>Different aggregations per column.</p> <pre><code>&gt;&gt;&gt; df.agg({'A' : ['sum', 'min'], 'B' : ['min', 'max']})\n        A    B\nsum  12.0  NaN\nmin   1.0  2.0\nmax   NaN  8.0\n</code></pre> <p>Aggregate different functions over the columns and rename the index of the resulting DataFrame.</p> <pre><code>&gt;&gt;&gt; df.agg(x=('A', 'max'), y=('B', 'min'), z=('C', 'mean'))\n     A    B    C\nx  7.0  NaN  NaN\ny  NaN  2.0  NaN\nz  NaN  NaN  6.0\n</code></pre> <p>Aggregate over the columns.</p> <pre><code>&gt;&gt;&gt; df.agg(\"mean\", axis=\"columns\")\n0    2.0\n1    5.0\n2    8.0\n3    NaN\ndtype: float64\n</code></pre> method &lt;/&gt; <p>Call <code>func</code> on self producing a DataFrame with the same axis shape as self.</p> Parameters <ul> <li><code>func</code> (function, str, list-like or dict-like) \u2014 Function to use for transforming the data. If a function, must eitherwork when passed a DataFrame or when passed to DataFrame.apply. If func is both list-like and dict-like, dict-like behavior takes precedence. Accepted combinations are: <ul> <li>function</li> <li>string function name</li> <li>list-like of functions and/or function names, e.g. <code>[np.exp, 'sqrt']</code></li> <li>dict-like of axis labels -&gt; functions, function names or list-like of such.</li> </ul> </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 If 0 or 'index': apply function to each column.If 1 or 'columns': apply function to each row. </li> <li><code>*args</code> \u2014 Positional arguments to pass to <code>func</code>.</li> <li><code>**kwargs</code> \u2014 Keyword arguments to pass to <code>func</code>.</li> </ul> Returns (DataFrame) <p>A DataFrame that must have the same length as self.</p> See Also <p>DataFrame.agg : Only perform aggregating type operations.DataFrame.apply : Invoke function on a DataFrame.</p> <p>Notes</p> <p>Functions that mutate the passed object can produce unexpected behavior or errors and are not supported. See :ref:<code>gotchas.udf-mutation</code> for more details.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': range(3), 'B': range(1, 4)})&gt;&gt;&gt; df\n   A  B\n0  0  1\n1  1  2\n2  2  3\n&gt;&gt;&gt; df.transform(lambda x: x + 1)\n   A  B\n0  1  2\n1  2  3\n2  3  4\n</code></pre> <p>Even though the resulting DataFrame must have the same length as the input DataFrame, it is possible to provide several input functions:</p> <pre><code>&gt;&gt;&gt; s = pd.Series(range(3))\n&gt;&gt;&gt; s\n0    0\n1    1\n2    2\ndtype: int64\n&gt;&gt;&gt; s.transform([np.sqrt, np.exp])\n       sqrt        exp\n0  0.000000   1.000000\n1  1.000000   2.718282\n2  1.414214   7.389056\n</code></pre> <p>You can call transform on a GroupBy object:</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     \"Date\": [\n...         \"2015-05-08\", \"2015-05-07\", \"2015-05-06\", \"2015-05-05\",\n...         \"2015-05-08\", \"2015-05-07\", \"2015-05-06\", \"2015-05-05\"],\n...     \"Data\": [5, 8, 6, 1, 50, 100, 60, 120],\n... })\n&gt;&gt;&gt; df\n         Date  Data\n0  2015-05-08     5\n1  2015-05-07     8\n2  2015-05-06     6\n3  2015-05-05     1\n4  2015-05-08    50\n5  2015-05-07   100\n6  2015-05-06    60\n7  2015-05-05   120\n&gt;&gt;&gt; df.groupby('Date')['Data'].transform('sum')\n0     55\n1    108\n2     66\n3    121\n4     55\n5    108\n6     66\n7    121\nName: Data, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\n...     \"c\": [1, 1, 1, 2, 2, 2, 2],\n...     \"type\": [\"m\", \"n\", \"o\", \"m\", \"m\", \"n\", \"n\"]\n... })\n&gt;&gt;&gt; df\n   c type\n0  1    m\n1  1    n\n2  1    o\n3  2    m\n4  2    m\n5  2    n\n6  2    n\n&gt;&gt;&gt; df['size'] = df.groupby('c')['type'].transform(len)\n&gt;&gt;&gt; df\n   c type size\n0  1    m    3\n1  1    n    3\n2  1    o    3\n3  2    m    4\n4  2    m    4\n5  2    n    4\n6  2    n    4\n</code></pre> method &lt;/&gt; <p>Apply a function along an axis of the DataFrame.</p><p>Objects passed to the function are Series objects whose index is either the DataFrame's index (<code>axis=0</code>) or the DataFrame's columns (<code>axis=1</code>). By default (<code>result_type=None</code>), the final return type is inferred from the return type of the applied function. Otherwise, it depends on the <code>result_type</code> argument.</p> Parameters <ul> <li><code>func</code> (function) \u2014 Function to apply to each column or row.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Axis along which the function is applied:<ul> <li>0 or 'index': apply function to each column.</li> <li>1 or 'columns': apply function to each row.</li> </ul> </li> <li><code>raw</code> (bool, default False) \u2014 Determines if row or column is passed as a Series or ndarray object:<ul> <li><code>False</code> : passes each row or column as a Series to the   function.</li> <li><code>True</code> : the passed function will receive ndarray objects   instead.   If you are just applying a NumPy reduction function this will   achieve much better performance.</li> </ul> </li> <li><code>result_type</code> ({'expand', 'reduce', 'broadcast', None}, default None) \u2014 These only act when <code>axis=1</code> (columns):<ul> <li>'expand' : list-like results will be turned into columns.</li> <li>'reduce' : returns a Series if possible rather than expanding   list-like results. This is the opposite of 'expand'.</li> <li>'broadcast' : results will be broadcast to the original shape   of the DataFrame, the original index and columns will be   retained.</li> </ul> The default behaviour (None) depends on the return value of the applied function: list-like results will be returned as a Series of those. However if the apply function returns a Series these are expanded to columns. </li> <li><code>args</code> (tuple) \u2014 Positional arguments to pass to <code>func</code> in addition to thearray/series. </li> <li><code>by_row</code> (False or \"compat\", default \"compat\") \u2014 Only has an effect when <code>func</code> is a listlike or dictlike of funcsand the func isn't a string. If \"compat\", will if possible first translate the func into pandas methods (e.g. <code>Series().apply(np.sum)</code> will be translated to <code>Series().sum()</code>). If that doesn't work, will try call to apply again with <code>by_row=True</code> and if that fails, will call apply again with <code>by_row=False</code> (backward compatible). If False, the funcs will be passed the whole Series at once. .. versionadded:: 2.1.0 </li> <li><code>engine</code> ({'python', 'numba'}, default 'python') \u2014 Choose between the python (default) engine or the numba engine in apply.The numba engine will attempt to JIT compile the passed function, which may result in speedups for large DataFrames. It also supports the following engine_kwargs : <ul> <li>nopython (compile the function in nopython mode)</li> <li>nogil (release the GIL inside the JIT compiled function)</li> <li>parallel (try to apply the function in parallel over the DataFrame)</li> </ul> Note: Due to limitations within numba/how pandas interfaces with numba,   you should only use this if raw=True Note: The numba compiler only supports a subset of valid Python/numpy operations. Please read more about the <code>supported python features &lt;https://numba.pydata.org/numba-doc/dev/reference/pysupported.html&gt;</code> and <code>supported numpy features &lt;https://numba.pydata.org/numba-doc/dev/reference/numpysupported.html&gt;</code> in numba to learn what you can or cannot use in the passed function. .. versionadded:: 2.2.0 </li> <li><code>engine_kwargs</code> (dict) \u2014 Pass keyword arguments to the engine.This is currently only used by the numba engine, see the documentation for the engine argument for more information. </li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to pass as keywords arguments to<code>func</code>. </li> </ul> Returns (Series or DataFrame) <p>Result of applying <code>func</code> along the given axis of theDataFrame.</p> See Also <p>DataFrame.map: For elementwise operations.DataFrame.aggregate: Only perform aggregating type operations. DataFrame.transform: Only perform transforming type operations.</p> <p>Notes</p> <p>Functions that mutate the passed object can produce unexpected behavior or errors and are not supported. See :ref:<code>gotchas.udf-mutation</code> for more details.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[4, 9]] * 3, columns=['A', 'B'])&gt;&gt;&gt; df\n   A  B\n0  4  9\n1  4  9\n2  4  9\n</code></pre> <p>Using a numpy universal function (in this case the same as <code>np.sqrt(df)</code>):</p> <pre><code>&gt;&gt;&gt; df.apply(np.sqrt)\n     A    B\n0  2.0  3.0\n1  2.0  3.0\n2  2.0  3.0\n</code></pre> <p>Using a reducing function on either axis</p> <pre><code>&gt;&gt;&gt; df.apply(np.sum, axis=0)\nA    12\nB    27\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.apply(np.sum, axis=1)\n0    13\n1    13\n2    13\ndtype: int64\n</code></pre> <p>Returning a list-like will result in a Series</p> <pre><code>&gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1)\n0    [1, 2]\n1    [1, 2]\n2    [1, 2]\ndtype: object\n</code></pre> <p>Passing <code>result_type='expand'</code> will expand list-like results to columns of a Dataframe</p> <pre><code>&gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1, result_type='expand')\n   0  1\n0  1  2\n1  1  2\n2  1  2\n</code></pre> <p>Returning a Series inside the function is similar to passing <code>result_type='expand'</code>. The resulting column names will be the Series index.</p> <pre><code>&gt;&gt;&gt; df.apply(lambda x: pd.Series([1, 2], index=['foo', 'bar']), axis=1)\n   foo  bar\n0    1    2\n1    1    2\n2    1    2\n</code></pre> <p>Passing <code>result_type='broadcast'</code> will ensure the same shape result, whether list-like or scalar is returned by the function, and broadcast it along the axis. The resulting column names will be the originals.</p> <pre><code>&gt;&gt;&gt; df.apply(lambda x: [1, 2], axis=1, result_type='broadcast')\n   A  B\n0  1  2\n1  1  2\n2  1  2\n</code></pre> method &lt;/&gt; <p>Apply a function to a Dataframe elementwise.</p><p>.. versionadded:: 2.1.0</p> <p>DataFrame.applymap was deprecated and renamed to DataFrame.map.</p> <p>This method applies a function that accepts and returns a scalar to every element of a DataFrame.</p> Parameters <ul> <li><code>func</code> (callable) \u2014 Python function, returns a single value from a single value.</li> <li><code>na_action</code> ({None, 'ignore'}, default None) \u2014 If 'ignore', propagate NaN values, without passing them to func.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to pass as keywords arguments to<code>func</code>. </li> </ul> Returns (DataFrame) <p>Transformed DataFrame.</p> See Also <p>DataFrame.apply : Apply a function along input axis of DataFrame.DataFrame.replace: Replace values given in <code>to_replace</code> with <code>value</code>. Series.map : Apply a function elementwise on a Series.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[1, 2.12], [3.356, 4.567]])&gt;&gt;&gt; df\n       0      1\n0  1.000  2.120\n1  3.356  4.567\n</code></pre> <pre><code>&gt;&gt;&gt; df.map(lambda x: len(str(x)))\n   0  1\n0  3  4\n1  5  5\n</code></pre> <p>Like Series.map, NA values can be ignored:</p> <pre><code>&gt;&gt;&gt; df_copy = df.copy()\n&gt;&gt;&gt; df_copy.iloc[0, 0] = pd.NA\n&gt;&gt;&gt; df_copy.map(lambda x: len(str(x)), na_action='ignore')\n     0  1\n0  NaN  4\n1  5.0  5\n</code></pre> <p>It is also possible to use <code>map</code> with functions that are not <code>lambda</code> functions:</p> <pre><code>&gt;&gt;&gt; df.map(round, ndigits=1)\n     0    1\n0  1.0  2.1\n1  3.4  4.6\n</code></pre> <p>Note that a vectorized version of <code>func</code> often exists, which will be much faster. You could square each number elementwise.</p> <pre><code>&gt;&gt;&gt; df.map(lambda x: x**2)\n           0          1\n0   1.000000   4.494400\n1  11.262736  20.857489\n</code></pre> <p>But it's better to avoid map in that case.</p> <pre><code>&gt;&gt;&gt; df ** 2\n           0          1\n0   1.000000   4.494400\n1  11.262736  20.857489\n</code></pre> method &lt;/&gt; <p>Apply a function to a Dataframe elementwise.</p><p>.. deprecated:: 2.1.0</p> <p>DataFrame.applymap has been deprecated. Use DataFrame.map instead.</p> <p>This method applies a function that accepts and returns a scalar to every element of a DataFrame.</p> Parameters <ul> <li><code>func</code> (callable) \u2014 Python function, returns a single value from a single value.</li> <li><code>na_action</code> ({None, 'ignore'}, default None) \u2014 If 'ignore', propagate NaN values, without passing them to func.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to pass as keywords arguments to<code>func</code>. </li> </ul> Returns (DataFrame) <p>Transformed DataFrame.</p> See Also <p>DataFrame.apply : Apply a function along input axis of DataFrame.DataFrame.map : Apply a function along input axis of DataFrame. DataFrame.replace: Replace values given in <code>to_replace</code> with <code>value</code>.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[1, 2.12], [3.356, 4.567]])&gt;&gt;&gt; df\n       0      1\n0  1.000  2.120\n1  3.356  4.567\n</code></pre> <pre><code>&gt;&gt;&gt; df.map(lambda x: len(str(x)))\n   0  1\n0  3  4\n1  5  5\n</code></pre> method &lt;/&gt; <p>Join columns of another DataFrame.</p><p>Join columns with <code>other</code> DataFrame either on index or on a key column. Efficiently join multiple DataFrame objects by index at once by passing a list.</p> Parameters <ul> <li><code>other</code> (DataFrame, Series, or a list containing any combination of them) \u2014 Index should be similar to one of the columns in this one. If aSeries is passed, its name attribute must be set, and that will be used as the column name in the resulting joined DataFrame. </li> <li><code>on</code> (str, list of str, or array-like, optional) \u2014 Column or index level name(s) in the caller to join on the indexin <code>other</code>, otherwise joins index-on-index. If multiple values given, the <code>other</code> DataFrame must have a MultiIndex. Can pass an array as the join key if it is not already contained in the calling DataFrame. Like an Excel VLOOKUP operation. </li> <li><code>how</code> ({'left', 'right', 'outer', 'inner', 'cross'}, default 'left') \u2014 How to handle the operation of the two objects.<ul> <li>left: use calling frame's index (or column if on is specified)</li> <li>right: use <code>other</code>'s index.</li> <li>outer: form union of calling frame's index (or column if on is   specified) with <code>other</code>'s index, and sort it lexicographically.</li> <li>inner: form intersection of calling frame's index (or column if   on is specified) with <code>other</code>'s index, preserving the order   of the calling's one.</li> <li>cross: creates the cartesian product from both frames, preserves the order   of the left keys.</li> </ul> </li> <li><code>lsuffix</code> (str, default '') \u2014 Suffix to use from left frame's overlapping columns.</li> <li><code>rsuffix</code> (str, default '') \u2014 Suffix to use from right frame's overlapping columns.</li> <li><code>sort</code> (bool, default False) \u2014 Order result DataFrame lexicographically by the join key. If False,the order of the join key depends on the join type (how keyword). </li> <li><code>validate</code> (str, optional) \u2014 If specified, checks if join is of specified type.<ul> <li>\"one_to_one\" or \"1:1\": check if join keys are unique in both left   and right datasets.</li> <li>\"one_to_many\" or \"1:m\": check if join keys are unique in left dataset.</li> <li>\"many_to_one\" or \"m:1\": check if join keys are unique in right dataset.</li> <li>\"many_to_many\" or \"m:m\": allowed, but does not result in checks.</li> </ul> .. versionadded:: 1.5.0 </li> </ul> Returns (DataFrame) <p>A dataframe containing columns from both the caller and <code>other</code>.</p> See Also <p>DataFrame.merge : For column(s)-on-column(s) operations.</p> <p>Notes</p> <p>Parameters <code>on</code>, <code>lsuffix</code>, and <code>rsuffix</code> are not supported when passing a list of <code>DataFrame</code> objects.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3', 'K4', 'K5'],...                    'A': ['A0', 'A1', 'A2', 'A3', 'A4', 'A5']})\n</code></pre> <pre><code>&gt;&gt;&gt; df\n  key   A\n0  K0  A0\n1  K1  A1\n2  K2  A2\n3  K3  A3\n4  K4  A4\n5  K5  A5\n</code></pre> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'key': ['K0', 'K1', 'K2'],\n...                       'B': ['B0', 'B1', 'B2']})\n</code></pre> <pre><code>&gt;&gt;&gt; other\n  key   B\n0  K0  B0\n1  K1  B1\n2  K2  B2\n</code></pre> <p>Join DataFrames using their indexes.</p> <pre><code>&gt;&gt;&gt; df.join(other, lsuffix='_caller', rsuffix='_other')\n  key_caller   A key_other    B\n0         K0  A0        K0   B0\n1         K1  A1        K1   B1\n2         K2  A2        K2   B2\n3         K3  A3       NaN  NaN\n4         K4  A4       NaN  NaN\n5         K5  A5       NaN  NaN\n</code></pre> <p>If we want to join using the key columns, we need to set key to be the index in both <code>df</code> and <code>other</code>. The joined DataFrame will have key as its index.</p> <pre><code>&gt;&gt;&gt; df.set_index('key').join(other.set_index('key'))\n      A    B\nkey\nK0   A0   B0\nK1   A1   B1\nK2   A2   B2\nK3   A3  NaN\nK4   A4  NaN\nK5   A5  NaN\n</code></pre> <p>Another option to join using the key columns is to use the <code>on</code> parameter. DataFrame.join always uses <code>other</code>'s index but we can use any column in <code>df</code>. This method preserves the original DataFrame's index in the result.</p> <pre><code>&gt;&gt;&gt; df.join(other.set_index('key'), on='key')\n  key   A    B\n0  K0  A0   B0\n1  K1  A1   B1\n2  K2  A2   B2\n3  K3  A3  NaN\n4  K4  A4  NaN\n5  K5  A5  NaN\n</code></pre> <p>Using non-unique key values shows how they are matched.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'key': ['K0', 'K1', 'K1', 'K3', 'K0', 'K1'],\n...                    'A': ['A0', 'A1', 'A2', 'A3', 'A4', 'A5']})\n</code></pre> <pre><code>&gt;&gt;&gt; df\n  key   A\n0  K0  A0\n1  K1  A1\n2  K1  A2\n3  K3  A3\n4  K0  A4\n5  K1  A5\n</code></pre> <pre><code>&gt;&gt;&gt; df.join(other.set_index('key'), on='key', validate='m:1')\n  key   A    B\n0  K0  A0   B0\n1  K1  A1   B1\n2  K1  A2   B1\n3  K3  A3  NaN\n4  K0  A4   B0\n5  K1  A5   B1\n</code></pre> method &lt;/&gt; <p>Merge DataFrame or named Series objects with a database-style join.</p><p>A named Series object is treated as a DataFrame with a single named column.</p> <p>The join is done on columns or indexes. If joining columns on columns, the DataFrame indexes will be ignored. Otherwise if joining indexes on indexes or indexes on a column or columns, the index will be passed on. When performing a cross merge, no column specifications to merge on are allowed.</p> <p>.. warning::</p> <pre><code>If both key columns contain rows where the key is a null value, those\nrows will be matched against each other. This is different from usual SQL\njoin behaviour and can lead to unexpected results.\n</code></pre> Parameters <ul> <li><code>right</code> (DataFrame or named Series) \u2014 Object to merge with.</li> <li><code>how</code> ({'left', 'right', 'outer', 'inner', 'cross'}, default 'inner') \u2014 Type of merge to be performed.<ul> <li>left: use only keys from left frame, similar to a SQL left outer join;   preserve key order.</li> <li>right: use only keys from right frame, similar to a SQL right outer join;   preserve key order.</li> <li>outer: use union of keys from both frames, similar to a SQL full outer   join; sort keys lexicographically.</li> <li>inner: use intersection of keys from both frames, similar to a SQL inner   join; preserve the order of the left keys.</li> <li>cross: creates the cartesian product from both frames, preserves the order   of the left keys.</li> </ul> </li> <li><code>on</code> (label or list) \u2014 Column or index level names to join on. These must be found in bothDataFrames. If <code>on</code> is None and not merging on indexes then this defaults to the intersection of the columns in both DataFrames. </li> <li><code>left_on</code> (label or list, or array-like) \u2014 Column or index level names to join on in the left DataFrame. Can alsobe an array or list of arrays of the length of the left DataFrame. These arrays are treated as if they are columns. </li> <li><code>right_on</code> (label or list, or array-like) \u2014 Column or index level names to join on in the right DataFrame. Can alsobe an array or list of arrays of the length of the right DataFrame. These arrays are treated as if they are columns. </li> <li><code>left_index</code> (bool, default False) \u2014 Use the index from the left DataFrame as the join key(s). If it is aMultiIndex, the number of keys in the other DataFrame (either the index or a number of columns) must match the number of levels. </li> <li><code>right_index</code> (bool, default False) \u2014 Use the index from the right DataFrame as the join key. Same caveats asleft_index. </li> <li><code>sort</code> (bool, default False) \u2014 Sort the join keys lexicographically in the result DataFrame. If False,the order of the join keys depends on the join type (how keyword). </li> <li><code>suffixes</code> (list-like, default is (\"_x\", \"_y\")) \u2014 A length-2 sequence where each element is optionally a stringindicating the suffix to add to overlapping column names in <code>left</code> and <code>right</code> respectively. Pass a value of <code>None</code> instead of a string to indicate that the column name from <code>left</code> or <code>right</code> should be left as-is, with no suffix. At least one of the values must not be None. </li> <li><code>copy</code> (bool, default True) \u2014 If False, avoid copy if possible... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> <li><code>indicator</code> (bool or str, default False) \u2014 If True, adds a column to the output DataFrame called \"_merge\" withinformation on the source of each row. The column can be given a different name by providing a string argument. The column will have a Categorical type with the value of \"left_only\" for observations whose merge key only appears in the left DataFrame, \"right_only\" for observations whose merge key only appears in the right DataFrame, and \"both\" if the observation's merge key is found in both DataFrames. </li> <li><code>validate</code> (str, optional) \u2014 If specified, checks if merge is of specified type.<ul> <li>\"one_to_one\" or \"1:1\": check if merge keys are unique in both   left and right datasets.</li> <li>\"one_to_many\" or \"1:m\": check if merge keys are unique in left   dataset.</li> <li>\"many_to_one\" or \"m:1\": check if merge keys are unique in right   dataset.</li> <li>\"many_to_many\" or \"m:m\": allowed, but does not result in checks.</li> </ul> </li> </ul> Returns (DataFrame) <p>A DataFrame of the two merged objects.</p> See Also <p>merge_ordered : Merge with optional filling/interpolation.merge_asof : Merge on nearest keys. DataFrame.join : Similar method using indices.</p> Examples <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'lkey': ['foo', 'bar', 'baz', 'foo'],...                     'value': [1, 2, 3, 5]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'rkey': ['foo', 'bar', 'baz', 'foo'],\n...                     'value': [5, 6, 7, 8]})\n&gt;&gt;&gt; df1\n    lkey value\n0   foo      1\n1   bar      2\n2   baz      3\n3   foo      5\n&gt;&gt;&gt; df2\n    rkey value\n0   foo      5\n1   bar      6\n2   baz      7\n3   foo      8\n</code></pre> <p>Merge df1 and df2 on the lkey and rkey columns. The value columns have the default suffixes, _x and _y, appended.</p> <pre><code>&gt;&gt;&gt; df1.merge(df2, left_on='lkey', right_on='rkey')\n  lkey  value_x rkey  value_y\n0  foo        1  foo        5\n1  foo        1  foo        8\n2  bar        2  bar        6\n3  baz        3  baz        7\n4  foo        5  foo        5\n5  foo        5  foo        8\n</code></pre> <p>Merge DataFrames df1 and df2 with specified left and right suffixes appended to any overlapping columns.</p> <pre><code>&gt;&gt;&gt; df1.merge(df2, left_on='lkey', right_on='rkey',\n...           suffixes=('_left', '_right'))\n  lkey  value_left rkey  value_right\n0  foo           1  foo            5\n1  foo           1  foo            8\n2  bar           2  bar            6\n3  baz           3  baz            7\n4  foo           5  foo            5\n5  foo           5  foo            8\n</code></pre> <p>Merge DataFrames df1 and df2, but raise an exception if the DataFrames have any overlapping columns.</p> <pre><code>&gt;&gt;&gt; df1.merge(df2, left_on='lkey', right_on='rkey', suffixes=(False, False))\nTraceback (most recent call last):\n...\nValueError: columns overlap but no suffix specified:\n    Index(['value'], dtype='object')\n</code></pre> <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'a': ['foo', 'bar'], 'b': [1, 2]})\n&gt;&gt;&gt; df2 = pd.DataFrame({'a': ['foo', 'baz'], 'c': [3, 4]})\n&gt;&gt;&gt; df1\n      a  b\n0   foo  1\n1   bar  2\n&gt;&gt;&gt; df2\n      a  c\n0   foo  3\n1   baz  4\n</code></pre> <pre><code>&gt;&gt;&gt; df1.merge(df2, how='inner', on='a')\n      a  b  c\n0   foo  1  3\n</code></pre> <pre><code>&gt;&gt;&gt; df1.merge(df2, how='left', on='a')\n      a  b  c\n0   foo  1  3.0\n1   bar  2  NaN\n</code></pre> <pre><code>&gt;&gt;&gt; df1 = pd.DataFrame({'left': ['foo', 'bar']})\n&gt;&gt;&gt; df2 = pd.DataFrame({'right': [7, 8]})\n&gt;&gt;&gt; df1\n    left\n0   foo\n1   bar\n&gt;&gt;&gt; df2\n    right\n0   7\n1   8\n</code></pre> <pre><code>&gt;&gt;&gt; df1.merge(df2, how='cross')\n   left  right\n0   foo      7\n1   foo      8\n2   bar      7\n3   bar      8\n</code></pre> method &lt;/&gt; <p>Round a DataFrame to a variable number of decimal places.</p> Parameters <ul> <li><code>decimals</code> (int, dict, Series) \u2014 Number of decimal places to round each column to. If an int isgiven, round each column to the same number of places. Otherwise dict and Series round to variable numbers of places. Column names should be in the keys if <code>decimals</code> is a dict-like, or in the index if <code>decimals</code> is a Series. Any columns not included in <code>decimals</code> will be left as is. Elements of <code>decimals</code> which are not columns of the input will be ignored. </li> <li><code>*args</code> \u2014 Additional keywords have no effect but might be accepted forcompatibility with numpy. </li> <li><code>**kwargs</code> \u2014 Additional keywords have no effect but might be accepted forcompatibility with numpy. </li> </ul> Returns (DataFrame) <p>A DataFrame with the affected columns rounded to the specifiednumber of decimal places.</p> See Also <p>numpy.around : Round a numpy array to the given number of decimals.Series.round : Round a Series to the given number of decimals.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([(.21, .32), (.01, .67), (.66, .03), (.21, .18)],...                   columns=['dogs', 'cats'])\n&gt;&gt;&gt; df\n    dogs  cats\n0  0.21  0.32\n1  0.01  0.67\n2  0.66  0.03\n3  0.21  0.18\n</code></pre> <p>By providing an integer each column is rounded to the same number of decimal places</p> <pre><code>&gt;&gt;&gt; df.round(1)\n    dogs  cats\n0   0.2   0.3\n1   0.0   0.7\n2   0.7   0.0\n3   0.2   0.2\n</code></pre> <p>With a dict, the number of places for specific columns can be specified with the column names as key and the number of decimal places as value</p> <pre><code>&gt;&gt;&gt; df.round({'dogs': 1, 'cats': 0})\n    dogs  cats\n0   0.2   0.0\n1   0.0   1.0\n2   0.7   0.0\n3   0.2   0.0\n</code></pre> <p>Using a Series, the number of places for specific columns can be specified with the column names as index and the number of decimal places as value</p> <pre><code>&gt;&gt;&gt; decimals = pd.Series([0, 1], index=['cats', 'dogs'])\n&gt;&gt;&gt; df.round(decimals)\n    dogs  cats\n0   0.2   0.0\n1   0.0   1.0\n2   0.7   0.0\n3   0.2   0.0\n</code></pre> method &lt;/&gt; <p>Compute pairwise correlation of columns, excluding NA/null values.</p> Parameters <ul> <li><code>method</code> ({'pearson', 'kendall', 'spearman'} or callable) \u2014 Method of correlation:<ul> <li>pearson : standard correlation coefficient</li> <li>kendall : Kendall Tau correlation coefficient</li> <li>spearman : Spearman rank correlation</li> <li>callable: callable with input two 1d ndarrays     and returning a float. Note that the returned matrix from corr     will have 1 along the diagonals and will be symmetric     regardless of the callable's behavior.</li> </ul> </li> <li><code>min_periods</code> (int, optional) \u2014 Minimum number of observations required per pair of columnsto have a valid result. Currently only available for Pearson and Spearman correlation. </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only <code>float</code>, <code>int</code> or <code>boolean</code> data... versionadded:: 1.5.0 .. versionchanged:: 2.0.0     The default value of <code>numeric_only</code> is now <code>False</code>. </li> </ul> Returns (DataFrame) <p>Correlation matrix.</p> See Also <p>DataFrame.corrwith : Compute pairwise correlation with another    DataFrame or Series. Series.corr : Compute the correlation between two Series.</p> <p>Notes</p> <p>Pearson, Kendall and Spearman correlation are currently computed using pairwise complete observations.</p> <ul> <li><code>Pearson correlation coefficient &lt;https://en.wikipedia.org/wiki/Pearson_correlation_coefficient&gt;</code>_</li> <li><code>Kendall rank correlation coefficient &lt;https://en.wikipedia.org/wiki/Kendall_rank_correlation_coefficient&gt;</code>_</li> <li><code>Spearman's rank correlation coefficient &lt;https://en.wikipedia.org/wiki/Spearman%27s_rank_correlation_coefficient&gt;</code>_</li> </ul> Examples <pre><code>&gt;&gt;&gt; def histogram_intersection(a, b):...     v = np.minimum(a, b).sum().round(decimals=1)\n...     return v\n&gt;&gt;&gt; df = pd.DataFrame([(.2, .3), (.0, .6), (.6, .0), (.2, .1)],\n...                   columns=['dogs', 'cats'])\n&gt;&gt;&gt; df.corr(method=histogram_intersection)\n      dogs  cats\ndogs   1.0   0.3\ncats   0.3   1.0\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame([(1, 1), (2, np.nan), (np.nan, 3), (4, 4)],\n...                   columns=['dogs', 'cats'])\n&gt;&gt;&gt; df.corr(min_periods=3)\n      dogs  cats\ndogs   1.0   NaN\ncats   NaN   1.0\n</code></pre> method &lt;/&gt; <p>Compute pairwise covariance of columns, excluding NA/null values.</p><p>Compute the pairwise covariance among the series of a DataFrame. The returned data frame is the <code>covariance matrix &lt;https://en.wikipedia.org/wiki/Covariance_matrix&gt;</code>__ of the columns of the DataFrame.</p> <p>Both NA and null values are automatically excluded from the calculation. (See the note below about bias from missing values.) A threshold can be set for the minimum number of observations for each value created. Comparisons with observations below this threshold will be returned as <code>NaN</code>.</p> <p>This method is generally used for the analysis of time series data to understand the relationship between different measures across time.</p> Parameters <ul> <li><code>min_periods</code> (int, optional) \u2014 Minimum number of observations required per pair of columnsto have a valid result. </li> <li><code>ddof</code> (int, default 1) \u2014 Delta degrees of freedom.  The divisor used in calculationsis <code>N - ddof</code>, where <code>N</code> represents the number of elements. This argument is applicable only when no <code>nan</code> is in the dataframe. </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only <code>float</code>, <code>int</code> or <code>boolean</code> data... versionadded:: 1.5.0 .. versionchanged:: 2.0.0     The default value of <code>numeric_only</code> is now <code>False</code>. </li> </ul> Returns (DataFrame) <p>The covariance matrix of the series of the DataFrame.</p> See Also <p>Series.cov : Compute covariance with another Series.core.window.ewm.ExponentialMovingWindow.cov : Exponential weighted sample     covariance. core.window.expanding.Expanding.cov : Expanding sample covariance. core.window.rolling.Rolling.cov : Rolling sample covariance.</p> <p>Notes</p> <p>Returns the covariance matrix of the DataFrame's time series. The covariance is normalized by N-ddof.</p> <p>For DataFrames that have Series that are missing data (assuming that data is <code>missing at random &lt;https://en.wikipedia.org/wiki/Missing_data#Missing_at_random&gt;</code>__) the returned covariance matrix will be an unbiased estimate of the variance and covariance between the member Series.</p> <p>However, for many applications this estimate may not be acceptable because the estimate covariance matrix is not guaranteed to be positive semi-definite. This could lead to estimate correlations having absolute values which are greater than one, and/or a non-invertible covariance matrix. See <code>Estimation of covariance matrices &lt;https://en.wikipedia.org/w/index.php?title=Estimation_of_covariance_ matrices&gt;</code>__ for more details.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([(1, 2), (0, 3), (2, 0), (1, 1)],...                   columns=['dogs', 'cats'])\n&gt;&gt;&gt; df.cov()\n          dogs      cats\ndogs  0.666667 -1.000000\ncats -1.000000  1.666667\n</code></pre> <pre><code>&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; df = pd.DataFrame(np.random.randn(1000, 5),\n...                   columns=['a', 'b', 'c', 'd', 'e'])\n&gt;&gt;&gt; df.cov()\n          a         b         c         d         e\na  0.998438 -0.020161  0.059277 -0.008943  0.014144\nb -0.020161  1.059352 -0.008543 -0.024738  0.009826\nc  0.059277 -0.008543  1.010670 -0.001486 -0.000271\nd -0.008943 -0.024738 -0.001486  0.921297 -0.013692\ne  0.014144  0.009826 -0.000271 -0.013692  0.977795\n</code></pre> <p>Minimum number of periods</p> <p>This method also supports an optional <code>min_periods</code> keyword that specifies the required minimum number of non-NA observations for each column pair in order to have a valid result:</p> <pre><code>&gt;&gt;&gt; np.random.seed(42)\n&gt;&gt;&gt; df = pd.DataFrame(np.random.randn(20, 3),\n...                   columns=['a', 'b', 'c'])\n&gt;&gt;&gt; df.loc[df.index[:5], 'a'] = np.nan\n&gt;&gt;&gt; df.loc[df.index[5:10], 'b'] = np.nan\n&gt;&gt;&gt; df.cov(min_periods=12)\n          a         b         c\na  0.316741       NaN -0.150812\nb       NaN  1.248003  0.191417\nc -0.150812  0.191417  0.895202\n</code></pre> method &lt;/&gt; <p>Compute pairwise correlation.</p><p>Pairwise correlation is computed between rows or columns of DataFrame with rows or columns of Series or DataFrame. DataFrames are first aligned along both axes before computing the correlations.</p> Parameters <ul> <li><code>other</code> (DataFrame, Series) \u2014 Object with which to compute correlations.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to use. 0 or 'index' to compute row-wise, 1 or 'columns' forcolumn-wise. </li> <li><code>drop</code> (bool, default False) \u2014 Drop missing indices from result.</li> <li><code>method</code> ({'pearson', 'kendall', 'spearman'} or callable) \u2014 Method of correlation:<ul> <li>pearson : standard correlation coefficient</li> <li>kendall : Kendall Tau correlation coefficient</li> <li>spearman : Spearman rank correlation</li> <li>callable: callable with input two 1d ndarrays     and returning a float.</li> </ul> </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only <code>float</code>, <code>int</code> or <code>boolean</code> data... versionadded:: 1.5.0 .. versionchanged:: 2.0.0     The default value of <code>numeric_only</code> is now <code>False</code>. </li> </ul> Returns (Series) <p>Pairwise correlations.</p> See Also <p>DataFrame.corr : Compute pairwise correlation of columns.</p> Examples <pre><code>&gt;&gt;&gt; index = [\"a\", \"b\", \"c\", \"d\", \"e\"]&gt;&gt;&gt; columns = [\"one\", \"two\", \"three\", \"four\"]\n&gt;&gt;&gt; df1 = pd.DataFrame(np.arange(20).reshape(5, 4), index=index, columns=columns)\n&gt;&gt;&gt; df2 = pd.DataFrame(np.arange(16).reshape(4, 4), index=index[:4], columns=columns)\n&gt;&gt;&gt; df1.corrwith(df2)\none      1.0\ntwo      1.0\nthree    1.0\nfour     1.0\ndtype: float64\n</code></pre> <pre><code>&gt;&gt;&gt; df2.corrwith(df1, axis=1)\na    1.0\nb    1.0\nc    1.0\nd    1.0\ne    NaN\ndtype: float64\n</code></pre> method &lt;/&gt; <p>Count non-NA cells for each column or row.</p><p>The values <code>None</code>, <code>NaN</code>, <code>NaT</code>, <code>pandas.NA</code> are considered NA.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 If 0 or 'index' counts are generated for each column.If 1 or 'columns' counts are generated for each row. </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only <code>float</code>, <code>int</code> or <code>boolean</code> data.</li> </ul> Returns (Series) <p>For each column/row the number of non-NA/null entries.</p> See Also <p>Series.count: Number of non-NA elements in a Series.DataFrame.value_counts: Count unique combinations of columns. DataFrame.shape: Number of DataFrame rows and columns (including NA     elements). DataFrame.isna: Boolean same-sized DataFrame showing places of NA     elements.</p> Examples <p>Constructing DataFrame from a dictionary:</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"Person\":\n...                    [\"John\", \"Myla\", \"Lewis\", \"John\", \"Myla\"],\n...                    \"Age\": [24., np.nan, 21., 33, 26],\n...                    \"Single\": [False, True, True, True, False]})\n&gt;&gt;&gt; df\n   Person   Age  Single\n0    John  24.0   False\n1    Myla   NaN    True\n2   Lewis  21.0    True\n3    John  33.0    True\n4    Myla  26.0   False\n</code></pre> <p>Notice the uncounted NA values:</p> <pre><code>&gt;&gt;&gt; df.count()\nPerson    5\nAge       4\nSingle    5\ndtype: int64\n</code></pre> <p>Counts for each row:</p> <pre><code>&gt;&gt;&gt; df.count(axis='columns')\n0    3\n1    2\n2    3\n3    3\n4    3\ndtype: int64\n</code></pre> method &lt;/&gt; <p>Return whether any element is True, potentially over an axis.</p><p>Returns False unless there is at least one element within a series or along a Dataframe axis that is True or equivalent (e.g. non-zero or non-empty).</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default 0) \u2014 Indicate which axis or axes should be reduced. For <code>Series</code> this parameteris unused and defaults to 0. <ul> <li>0 / 'index' : reduce the index, return a Series whose index is the   original column labels.</li> <li>1 / 'columns' : reduce the columns, return a Series whose index is the   original index.</li> <li>None : reduce all axes, return a scalar.</li> </ul> </li> <li><code>bool_only</code> (bool, default False) \u2014 Include only boolean columns. Not implemented for Series.</li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If the entire row/column is NA and skipna isTrue, then the result will be False, as for an empty row/column. If skipna is False, then NA are treated as True, because these are not equal to zero. </li> <li><code>**kwargs</code> (any, default None) \u2014 Additional keywords have no effect but might be accepted forcompatibility with NumPy. </li> </ul> Returns (Series or DataFrame) <p>If level is specified, then, DataFrame is returned; otherwise, Seriesis returned.</p> See Also <p>numpy.any : Numpy version of this method.Series.any : Return whether any element is True. Series.all : Return whether all elements are True. DataFrame.any : Return whether any element is True over requested axis. DataFrame.all : Return whether all elements are True over requested axis.</p> Examples <p>Series</p><p>For Series input, the output is a scalar indicating whether any element is True.</p> <pre><code>&gt;&gt;&gt; pd.Series([False, False]).any()\nFalse\n&gt;&gt;&gt; pd.Series([True, False]).any()\nTrue\n&gt;&gt;&gt; pd.Series([], dtype=\"float64\").any()\nFalse\n&gt;&gt;&gt; pd.Series([np.nan]).any()\nFalse\n&gt;&gt;&gt; pd.Series([np.nan]).any(skipna=False)\nTrue\n</code></pre> <p>DataFrame</p> <p>Whether each column contains at least one True element (the default).</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [1, 2], \"B\": [0, 2], \"C\": [0, 0]})\n&gt;&gt;&gt; df\n   A  B  C\n0  1  0  0\n1  2  2  0\n</code></pre> <pre><code>&gt;&gt;&gt; df.any()\nA     True\nB     True\nC    False\ndtype: bool\n</code></pre> <p>Aggregating over the columns.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [True, False], \"B\": [1, 2]})\n&gt;&gt;&gt; df\n       A  B\n0   True  1\n1  False  2\n</code></pre> <pre><code>&gt;&gt;&gt; df.any(axis='columns')\n0    True\n1    True\ndtype: bool\n</code></pre> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({\"A\": [True, False], \"B\": [1, 0]})\n&gt;&gt;&gt; df\n       A  B\n0   True  1\n1  False  0\n</code></pre> <pre><code>&gt;&gt;&gt; df.any(axis='columns')\n0    True\n1    False\ndtype: bool\n</code></pre> <p>Aggregating over the entire DataFrame with <code>axis=None</code>.</p> <pre><code>&gt;&gt;&gt; df.any(axis=None)\nTrue\n</code></pre> <p><code>any</code> for an empty DataFrame is an empty Series.</p> <pre><code>&gt;&gt;&gt; pd.DataFrame([]).any()\nSeries([], dtype: bool)\n</code></pre> method &lt;/&gt; <p>Return whether all elements are True, potentially over an axis.</p><p>Returns True unless there at least one element within a series or along a Dataframe axis that is False or equivalent (e.g. zero or empty).</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns', None}, default 0) \u2014 Indicate which axis or axes should be reduced. For <code>Series</code> this parameteris unused and defaults to 0. <ul> <li>0 / 'index' : reduce the index, return a Series whose index is the   original column labels.</li> <li>1 / 'columns' : reduce the columns, return a Series whose index is the   original index.</li> <li>None : reduce all axes, return a scalar.</li> </ul> </li> <li><code>bool_only</code> (bool, default False) \u2014 Include only boolean columns. Not implemented for Series.</li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If the entire row/column is NA and skipna isTrue, then the result will be True, as for an empty row/column. If skipna is False, then NA are treated as True, because these are not equal to zero. </li> <li><code>**kwargs</code> (any, default None) \u2014 Additional keywords have no effect but might be accepted forcompatibility with NumPy. </li> </ul> Returns (Series or DataFrame) <p>If level is specified, then, DataFrame is returned; otherwise, Seriesis returned.</p> See Also <p>Series.all : Return True if all elements are True.DataFrame.any : Return True if one (or more) elements are True.</p> Examples <p>Series</p><pre><code>&gt;&gt;&gt; pd.Series([True, True]).all()\nTrue\n&gt;&gt;&gt; pd.Series([True, False]).all()\nFalse\n&gt;&gt;&gt; pd.Series([], dtype=\"float64\").all()\nTrue\n&gt;&gt;&gt; pd.Series([np.nan]).all()\nTrue\n&gt;&gt;&gt; pd.Series([np.nan]).all(skipna=False)\nTrue\n</code></pre> <p>DataFrames</p> <p>Create a dataframe from a dictionary.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'col1': [True, True], 'col2': [True, False]})\n&gt;&gt;&gt; df\n   col1   col2\n0  True   True\n1  True  False\n</code></pre> <p>Default behaviour checks if values in each column all return True.</p> <pre><code>&gt;&gt;&gt; df.all()\ncol1     True\ncol2    False\ndtype: bool\n</code></pre> <p>Specify <code>axis='columns'</code> to check if values in each row all return True.</p> <pre><code>&gt;&gt;&gt; df.all(axis='columns')\n0     True\n1    False\ndtype: bool\n</code></pre> <p>Or <code>axis=None</code> for whether every value is True.</p> <pre><code>&gt;&gt;&gt; df.all(axis=None)\nFalse\n</code></pre> method &lt;/&gt; <p>Return the minimum of the values over the requested axis.</p><p>If you want the index of the minimum, use <code>idxmin</code>. This is the equivalent of the <code>numpy.ndarray</code> method <code>argmin</code>.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 Axis for the function to be applied on.For <code>Series</code> this parameter is unused and defaults to 0. For DataFrames, specifying <code>axis=None</code> will apply the aggregation across both axes. .. versionadded:: 2.0.0 </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values when computing the result.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to be passed to the function.</li> </ul> See Also <p>Series.sum : Return the sum.Series.min : Return the minimum. Series.max : Return the maximum. Series.idxmin : Return the index of the minimum. Series.idxmax : Return the index of the maximum. DataFrame.sum : Return the sum over the requested axis. DataFrame.min : Return the minimum over the requested axis. DataFrame.max : Return the maximum over the requested axis. DataFrame.idxmin : Return the index of the minimum over the requested axis. DataFrame.idxmax : Return the index of the maximum over the requested axis.</p> Examples <pre><code>&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([...     ['warm', 'warm', 'cold', 'cold'],\n...     ['dog', 'falcon', 'fish', 'spider']],\n...     names=['blooded', 'animal'])\n&gt;&gt;&gt; s = pd.Series([4, 2, 0, 8], name='legs', index=idx)\n&gt;&gt;&gt; s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s.min()\n0\n</code></pre> method &lt;/&gt; <p>Return the maximum of the values over the requested axis.</p><p>If you want the index of the maximum, use <code>idxmax</code>. This is the equivalent of the <code>numpy.ndarray</code> method <code>argmax</code>.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 Axis for the function to be applied on.For <code>Series</code> this parameter is unused and defaults to 0. For DataFrames, specifying <code>axis=None</code> will apply the aggregation across both axes. .. versionadded:: 2.0.0 </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values when computing the result.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to be passed to the function.</li> </ul> See Also <p>Series.sum : Return the sum.Series.min : Return the minimum. Series.max : Return the maximum. Series.idxmin : Return the index of the minimum. Series.idxmax : Return the index of the maximum. DataFrame.sum : Return the sum over the requested axis. DataFrame.min : Return the minimum over the requested axis. DataFrame.max : Return the maximum over the requested axis. DataFrame.idxmin : Return the index of the minimum over the requested axis. DataFrame.idxmax : Return the index of the maximum over the requested axis.</p> Examples <pre><code>&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([...     ['warm', 'warm', 'cold', 'cold'],\n...     ['dog', 'falcon', 'fish', 'spider']],\n...     names=['blooded', 'animal'])\n&gt;&gt;&gt; s = pd.Series([4, 2, 0, 8], name='legs', index=idx)\n&gt;&gt;&gt; s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s.max()\n8\n</code></pre> method &lt;/&gt; <p>Return the sum of the values over the requested axis.</p><p>This is equivalent to the method <code>numpy.sum</code>.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 Axis for the function to be applied on.For <code>Series</code> this parameter is unused and defaults to 0. .. warning:: <pre><code>The behavior of DataFrame.sum with ``axis=None`` is deprecated,\nin a future version this will reduce over both axes and return a scalar\nTo retain the old behavior, pass axis=0 (or do not pass axis).\n</code></pre> .. versionadded:: 2.0.0 </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values when computing the result.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> <li><code>min_count</code> (int, default 0) \u2014 The required number of valid values to perform the operation. If fewer than<code>min_count</code> non-NA values are present the result will be NA. </li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to be passed to the function.</li> </ul> See Also <p>Series.sum : Return the sum.Series.min : Return the minimum. Series.max : Return the maximum. Series.idxmin : Return the index of the minimum. Series.idxmax : Return the index of the maximum. DataFrame.sum : Return the sum over the requested axis. DataFrame.min : Return the minimum over the requested axis. DataFrame.max : Return the maximum over the requested axis. DataFrame.idxmin : Return the index of the minimum over the requested axis. DataFrame.idxmax : Return the index of the maximum over the requested axis.</p> Examples <pre><code>&gt;&gt;&gt; idx = pd.MultiIndex.from_arrays([...     ['warm', 'warm', 'cold', 'cold'],\n...     ['dog', 'falcon', 'fish', 'spider']],\n...     names=['blooded', 'animal'])\n&gt;&gt;&gt; s = pd.Series([4, 2, 0, 8], name='legs', index=idx)\n&gt;&gt;&gt; s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; s.sum()\n14\n</code></pre> <p>By default, the sum of an empty or all-NA Series is <code>0</code>.</p> <pre><code>&gt;&gt;&gt; pd.Series([], dtype=\"float64\").sum()  # min_count=0 is the default\n0.0\n</code></pre> <p>This can be controlled with the <code>min_count</code> parameter. For example, if you'd like the sum of an empty series to be NaN, pass <code>min_count=1</code>.</p> <pre><code>&gt;&gt;&gt; pd.Series([], dtype=\"float64\").sum(min_count=1)\nnan\n</code></pre> <p>Thanks to the <code>skipna</code> parameter, <code>min_count</code> handles all-NA and empty series identically.</p> <pre><code>&gt;&gt;&gt; pd.Series([np.nan]).sum()\n0.0\n</code></pre> <pre><code>&gt;&gt;&gt; pd.Series([np.nan]).sum(min_count=1)\nnan\n</code></pre> method &lt;/&gt; <p>Return the product of the values over the requested axis.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 Axis for the function to be applied on.For <code>Series</code> this parameter is unused and defaults to 0. .. warning:: <pre><code>The behavior of DataFrame.prod with ``axis=None`` is deprecated,\nin a future version this will reduce over both axes and return a scalar\nTo retain the old behavior, pass axis=0 (or do not pass axis).\n</code></pre> .. versionadded:: 2.0.0 </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values when computing the result.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> <li><code>min_count</code> (int, default 0) \u2014 The required number of valid values to perform the operation. If fewer than<code>min_count</code> non-NA values are present the result will be NA. </li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to be passed to the function.</li> </ul> See Also <p>Series.sum : Return the sum.Series.min : Return the minimum. Series.max : Return the maximum. Series.idxmin : Return the index of the minimum. Series.idxmax : Return the index of the maximum. DataFrame.sum : Return the sum over the requested axis. DataFrame.min : Return the minimum over the requested axis. DataFrame.max : Return the maximum over the requested axis. DataFrame.idxmin : Return the index of the minimum over the requested axis. DataFrame.idxmax : Return the index of the maximum over the requested axis.</p> Examples <p>By default, the product of an empty or all-NA Series is <code>1</code></p><pre><code>&gt;&gt;&gt; pd.Series([], dtype=\"float64\").prod()\n1.0\n</code></pre> <p>This can be controlled with the <code>min_count</code> parameter</p> <pre><code>&gt;&gt;&gt; pd.Series([], dtype=\"float64\").prod(min_count=1)\nnan\n</code></pre> <p>Thanks to the <code>skipna</code> parameter, <code>min_count</code> handles all-NA and empty series identically.</p> <pre><code>&gt;&gt;&gt; pd.Series([np.nan]).prod()\n1.0\n</code></pre> <pre><code>&gt;&gt;&gt; pd.Series([np.nan]).prod(min_count=1)\nnan\n</code></pre> method &lt;/&gt; <p>Return the mean of the values over the requested axis.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 Axis for the function to be applied on.For <code>Series</code> this parameter is unused and defaults to 0. For DataFrames, specifying <code>axis=None</code> will apply the aggregation across both axes. .. versionadded:: 2.0.0 </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values when computing the result.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to be passed to the function.</li> </ul> Returns (Series or scalar) method &lt;/&gt; <p>Return the median of the values over the requested axis.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 Axis for the function to be applied on.For <code>Series</code> this parameter is unused and defaults to 0. For DataFrames, specifying <code>axis=None</code> will apply the aggregation across both axes. .. versionadded:: 2.0.0 </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values when computing the result.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to be passed to the function.</li> </ul> Returns (Series or scalar) method &lt;/&gt; <p>Return unbiased standard error of the mean over requested axis.</p><p>Normalized by N-1 by default. This can be changed using the ddof argument</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 For <code>Series</code> this parameter is unused and defaults to 0... warning:: <pre><code>The behavior of DataFrame.sem with ``axis=None`` is deprecated,\nin a future version this will reduce over both axes and return a scalar\nTo retain the old behavior, pass axis=0 (or do not pass axis).\n</code></pre> </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> <li><code>ddof</code> (int, default 1) \u2014 Delta Degrees of Freedom. The divisor used in calculations is N - ddof,where N represents the number of elements. </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> </ul> Returns (Series or DataFrame (if level specified)) method &lt;/&gt; <p>Return unbiased variance over requested axis.</p><p>Normalized by N-1 by default. This can be changed using the ddof argument.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 For <code>Series</code> this parameter is unused and defaults to 0... warning:: <pre><code>The behavior of DataFrame.var with ``axis=None`` is deprecated,\nin a future version this will reduce over both axes and return a scalar\nTo retain the old behavior, pass axis=0 (or do not pass axis).\n</code></pre> </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> <li><code>ddof</code> (int, default 1) \u2014 Delta Degrees of Freedom. The divisor used in calculations is N - ddof,where N represents the number of elements. </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> </ul> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'person_id': [0, 1, 2, 3],...                    'age': [21, 25, 62, 43],\n...                    'height': [1.61, 1.87, 1.49, 2.01]}\n...                   ).set_index('person_id')\n&gt;&gt;&gt; df\n           age  height\nperson_id\n0           21    1.61\n1           25    1.87\n2           62    1.49\n3           43    2.01\n</code></pre> <pre><code>&gt;&gt;&gt; df.var()\nage       352.916667\nheight      0.056367\ndtype: float64\n</code></pre> <p>Alternatively, <code>ddof=0</code> can be set to normalize by N instead of N-1:</p> <pre><code>&gt;&gt;&gt; df.var(ddof=0)\nage       264.687500\nheight      0.042275\ndtype: float64\n</code></pre> method &lt;/&gt; <p>Return sample standard deviation over requested axis.</p><p>Normalized by N-1 by default. This can be changed using the ddof argument.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 For <code>Series</code> this parameter is unused and defaults to 0... warning:: <pre><code>The behavior of DataFrame.std with ``axis=None`` is deprecated,\nin a future version this will reduce over both axes and return a scalar\nTo retain the old behavior, pass axis=0 (or do not pass axis).\n</code></pre> </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> <li><code>ddof</code> (int, default 1) \u2014 Delta Degrees of Freedom. The divisor used in calculations is N - ddof,where N represents the number of elements. </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> </ul> <p>Notes</p> <p>To have the same behaviour as <code>numpy.std</code>, use <code>ddof=0</code> (instead of the default <code>ddof=1</code>)</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'person_id': [0, 1, 2, 3],...                    'age': [21, 25, 62, 43],\n...                    'height': [1.61, 1.87, 1.49, 2.01]}\n...                   ).set_index('person_id')\n&gt;&gt;&gt; df\n           age  height\nperson_id\n0           21    1.61\n1           25    1.87\n2           62    1.49\n3           43    2.01\n</code></pre> <p>The standard deviation of the columns can be found as follows:</p> <pre><code>&gt;&gt;&gt; df.std()\nage       18.786076\nheight     0.237417\ndtype: float64\n</code></pre> <p>Alternatively, <code>ddof=0</code> can be set to normalize by N instead of N-1:</p> <pre><code>&gt;&gt;&gt; df.std(ddof=0)\nage       16.269219\nheight     0.205609\ndtype: float64\n</code></pre> method &lt;/&gt; <p>Return unbiased skew over requested axis.</p><p>Normalized by N-1.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 Axis for the function to be applied on.For <code>Series</code> this parameter is unused and defaults to 0. For DataFrames, specifying <code>axis=None</code> will apply the aggregation across both axes. .. versionadded:: 2.0.0 </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values when computing the result.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to be passed to the function.</li> </ul> Returns (Series or scalar) method &lt;/&gt; <p>Return unbiased kurtosis over requested axis.</p><p>Kurtosis obtained using Fisher's definition of kurtosis (kurtosis of normal == 0.0). Normalized by N-1.</p> Parameters <ul> <li><code>axis</code> ({index (0), columns (1)}) \u2014 Axis for the function to be applied on.For <code>Series</code> this parameter is unused and defaults to 0. For DataFrames, specifying <code>axis=None</code> will apply the aggregation across both axes. .. versionadded:: 2.0.0 </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values when computing the result.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only float, int, boolean columns. Not implemented for Series.</li> <li><code>**kwargs</code> \u2014 Additional keyword arguments to be passed to the function.</li> </ul> Returns (Series or scalar) method &lt;/&gt; <p>Return cumulative minimum over a DataFrame or Series axis.</p><p>Returns a DataFrame or Series of the same size containing the cumulative minimum.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The index or the name of the axis. 0 is equivalent to None or 'index'.For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> </ul> Returns (Series or DataFrame) <p>Return cumulative minimum of Series or DataFrame.</p> See Also <p>core.window.expanding.Expanding.min : Similar functionality    but ignores <code>NaN</code> values. DataFrame.min : Return the minimum over     DataFrame axis. DataFrame.cummax : Return cumulative maximum over DataFrame axis. DataFrame.cummin : Return cumulative minimum over DataFrame axis. DataFrame.cumsum : Return cumulative sum over DataFrame axis. DataFrame.cumprod : Return cumulative product over DataFrame axis.</p> Examples <p>Series</p><pre><code>&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])\n&gt;&gt;&gt; s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64\n</code></pre> <p>By default, NA values are ignored.</p> <pre><code>&gt;&gt;&gt; s.cummin()\n0    2.0\n1    NaN\n2    2.0\n3   -1.0\n4   -1.0\ndtype: float64\n</code></pre> <p>To include NA values in the operation, use <code>skipna=False</code></p> <pre><code>&gt;&gt;&gt; s.cummin(skipna=False)\n0    2.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64\n</code></pre> <p>DataFrame</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],\n...                    [3.0, np.nan],\n...                    [1.0, 0.0]],\n...                   columns=list('AB'))\n&gt;&gt;&gt; df\n     A    B\n0  2.0  1.0\n1  3.0  NaN\n2  1.0  0.0\n</code></pre> <p>By default, iterates over rows and finds the minimum in each column. This is equivalent to <code>axis=None</code> or <code>axis='index'</code>.</p> <pre><code>&gt;&gt;&gt; df.cummin()\n     A    B\n0  2.0  1.0\n1  2.0  NaN\n2  1.0  0.0\n</code></pre> <p>To iterate over columns and find the minimum in each row, use <code>axis=1</code></p> <pre><code>&gt;&gt;&gt; df.cummin(axis=1)\n     A    B\n0  2.0  1.0\n1  3.0  NaN\n2  1.0  0.0\n</code></pre> method &lt;/&gt; <p>Return cumulative maximum over a DataFrame or Series axis.</p><p>Returns a DataFrame or Series of the same size containing the cumulative maximum.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The index or the name of the axis. 0 is equivalent to None or 'index'.For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> </ul> Returns (Series or DataFrame) <p>Return cumulative maximum of Series or DataFrame.</p> See Also <p>core.window.expanding.Expanding.max : Similar functionality    but ignores <code>NaN</code> values. DataFrame.max : Return the maximum over     DataFrame axis. DataFrame.cummax : Return cumulative maximum over DataFrame axis. DataFrame.cummin : Return cumulative minimum over DataFrame axis. DataFrame.cumsum : Return cumulative sum over DataFrame axis. DataFrame.cumprod : Return cumulative product over DataFrame axis.</p> Examples <p>Series</p><pre><code>&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])\n&gt;&gt;&gt; s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64\n</code></pre> <p>By default, NA values are ignored.</p> <pre><code>&gt;&gt;&gt; s.cummax()\n0    2.0\n1    NaN\n2    5.0\n3    5.0\n4    5.0\ndtype: float64\n</code></pre> <p>To include NA values in the operation, use <code>skipna=False</code></p> <pre><code>&gt;&gt;&gt; s.cummax(skipna=False)\n0    2.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64\n</code></pre> <p>DataFrame</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],\n...                    [3.0, np.nan],\n...                    [1.0, 0.0]],\n...                   columns=list('AB'))\n&gt;&gt;&gt; df\n     A    B\n0  2.0  1.0\n1  3.0  NaN\n2  1.0  0.0\n</code></pre> <p>By default, iterates over rows and finds the maximum in each column. This is equivalent to <code>axis=None</code> or <code>axis='index'</code>.</p> <pre><code>&gt;&gt;&gt; df.cummax()\n     A    B\n0  2.0  1.0\n1  3.0  NaN\n2  3.0  1.0\n</code></pre> <p>To iterate over columns and find the maximum in each row, use <code>axis=1</code></p> <pre><code>&gt;&gt;&gt; df.cummax(axis=1)\n     A    B\n0  2.0  2.0\n1  3.0  NaN\n2  1.0  1.0\n</code></pre> method &lt;/&gt; <p>Return cumulative sum over a DataFrame or Series axis.</p><p>Returns a DataFrame or Series of the same size containing the cumulative sum.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The index or the name of the axis. 0 is equivalent to None or 'index'.For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> </ul> Returns (Series or DataFrame) <p>Return cumulative sum of Series or DataFrame.</p> See Also <p>core.window.expanding.Expanding.sum : Similar functionality    but ignores <code>NaN</code> values. DataFrame.sum : Return the sum over     DataFrame axis. DataFrame.cummax : Return cumulative maximum over DataFrame axis. DataFrame.cummin : Return cumulative minimum over DataFrame axis. DataFrame.cumsum : Return cumulative sum over DataFrame axis. DataFrame.cumprod : Return cumulative product over DataFrame axis.</p> Examples <p>Series</p><pre><code>&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])\n&gt;&gt;&gt; s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64\n</code></pre> <p>By default, NA values are ignored.</p> <pre><code>&gt;&gt;&gt; s.cumsum()\n0    2.0\n1    NaN\n2    7.0\n3    6.0\n4    6.0\ndtype: float64\n</code></pre> <p>To include NA values in the operation, use <code>skipna=False</code></p> <pre><code>&gt;&gt;&gt; s.cumsum(skipna=False)\n0    2.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64\n</code></pre> <p>DataFrame</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],\n...                    [3.0, np.nan],\n...                    [1.0, 0.0]],\n...                   columns=list('AB'))\n&gt;&gt;&gt; df\n     A    B\n0  2.0  1.0\n1  3.0  NaN\n2  1.0  0.0\n</code></pre> <p>By default, iterates over rows and finds the sum in each column. This is equivalent to <code>axis=None</code> or <code>axis='index'</code>.</p> <pre><code>&gt;&gt;&gt; df.cumsum()\n     A    B\n0  2.0  1.0\n1  5.0  NaN\n2  6.0  1.0\n</code></pre> <p>To iterate over columns and find the sum in each row, use <code>axis=1</code></p> <pre><code>&gt;&gt;&gt; df.cumsum(axis=1)\n     A    B\n0  2.0  3.0\n1  3.0  NaN\n2  1.0  1.0\n</code></pre> method &lt;/&gt; <p>Return cumulative product over a DataFrame or Series axis.</p><p>Returns a DataFrame or Series of the same size containing the cumulative product.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The index or the name of the axis. 0 is equivalent to None or 'index'.For <code>Series</code> this parameter is unused and defaults to 0. </li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> </ul> Returns (Series or DataFrame) <p>Return cumulative product of Series or DataFrame.</p> See Also <p>core.window.expanding.Expanding.prod : Similar functionality    but ignores <code>NaN</code> values. DataFrame.prod : Return the product over     DataFrame axis. DataFrame.cummax : Return cumulative maximum over DataFrame axis. DataFrame.cummin : Return cumulative minimum over DataFrame axis. DataFrame.cumsum : Return cumulative sum over DataFrame axis. DataFrame.cumprod : Return cumulative product over DataFrame axis.</p> Examples <p>Series</p><pre><code>&gt;&gt;&gt; s = pd.Series([2, np.nan, 5, -1, 0])\n&gt;&gt;&gt; s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64\n</code></pre> <p>By default, NA values are ignored.</p> <pre><code>&gt;&gt;&gt; s.cumprod()\n0     2.0\n1     NaN\n2    10.0\n3   -10.0\n4    -0.0\ndtype: float64\n</code></pre> <p>To include NA values in the operation, use <code>skipna=False</code></p> <pre><code>&gt;&gt;&gt; s.cumprod(skipna=False)\n0    2.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64\n</code></pre> <p>DataFrame</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame([[2.0, 1.0],\n...                    [3.0, np.nan],\n...                    [1.0, 0.0]],\n...                   columns=list('AB'))\n&gt;&gt;&gt; df\n     A    B\n0  2.0  1.0\n1  3.0  NaN\n2  1.0  0.0\n</code></pre> <p>By default, iterates over rows and finds the product in each column. This is equivalent to <code>axis=None</code> or <code>axis='index'</code>.</p> <pre><code>&gt;&gt;&gt; df.cumprod()\n     A    B\n0  2.0  1.0\n1  6.0  NaN\n2  6.0  0.0\n</code></pre> <p>To iterate over columns and find the product in each row, use <code>axis=1</code></p> <pre><code>&gt;&gt;&gt; df.cumprod(axis=1)\n     A    B\n0  2.0  2.0\n1  3.0  NaN\n2  1.0  0.0\n</code></pre> method &lt;/&gt; <p>Count number of distinct elements in specified axis.</p><p>Return Series with number of distinct elements. Can ignore NaN values.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to use. 0 or 'index' for row-wise, 1 or 'columns' forcolumn-wise. </li> <li><code>dropna</code> (bool, default True) \u2014 Don't include NaN in the counts.</li> </ul> See Also <p>Series.nunique: Method nunique for Series.DataFrame.count: Count non-NA cells for each column or row.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [4, 5, 6], 'B': [4, 1, 1]})&gt;&gt;&gt; df.nunique()\nA    3\nB    2\ndtype: int64\n</code></pre> <pre><code>&gt;&gt;&gt; df.nunique(axis=1)\n0    1\n1    2\n2    2\ndtype: int64\n</code></pre> method &lt;/&gt; <p>Return index of first occurrence of minimum over requested axis.</p><p>NA/null values are excluded.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to use. 0 or 'index' for row-wise, 1 or 'columns' for column-wise.</li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only <code>float</code>, <code>int</code> or <code>boolean</code> data... versionadded:: 1.5.0 </li> </ul> Returns (Series) <p>Indexes of minima along the specified axis.</p> Raises <ul> <li><code>ValueError</code> \u2014 <ul><li>If the row/column is empty</li> </ul> </li> </ul> See Also <p>Series.idxmin : Return index of the minimum element.</p> <p>Notes</p> <p>This method is the DataFrame version of <code>ndarray.argmin</code>.</p> Examples <p>Consider a dataset containing food consumption in Argentina.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame({'consumption': [10.51, 103.11, 55.48],\n...                     'co2_emissions': [37.2, 19.66, 1712]},\n...                   index=['Pork', 'Wheat Products', 'Beef'])\n</code></pre> <pre><code>&gt;&gt;&gt; df\n                consumption  co2_emissions\nPork                  10.51         37.20\nWheat Products       103.11         19.66\nBeef                  55.48       1712.00\n</code></pre> <p>By default, it returns the index for the minimum value in each column.</p> <pre><code>&gt;&gt;&gt; df.idxmin()\nconsumption                Pork\nco2_emissions    Wheat Products\ndtype: object\n</code></pre> <p>To return the index for the minimum value in each row, use <code>axis=\"columns\"</code>.</p> <pre><code>&gt;&gt;&gt; df.idxmin(axis=\"columns\")\nPork                consumption\nWheat Products    co2_emissions\nBeef                consumption\ndtype: object\n</code></pre> method &lt;/&gt; <p>Return index of first occurrence of maximum over requested axis.</p><p>NA/null values are excluded.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to use. 0 or 'index' for row-wise, 1 or 'columns' for column-wise.</li> <li><code>skipna</code> (bool, default True) \u2014 Exclude NA/null values. If an entire row/column is NA, the resultwill be NA. </li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only <code>float</code>, <code>int</code> or <code>boolean</code> data... versionadded:: 1.5.0 </li> </ul> Returns (Series) <p>Indexes of maxima along the specified axis.</p> Raises <ul> <li><code>ValueError</code> \u2014 <ul><li>If the row/column is empty</li> </ul> </li> </ul> See Also <p>Series.idxmax : Return index of the maximum element.</p> <p>Notes</p> <p>This method is the DataFrame version of <code>ndarray.argmax</code>.</p> Examples <p>Consider a dataset containing food consumption in Argentina.</p><pre><code>&gt;&gt;&gt; df = pd.DataFrame({'consumption': [10.51, 103.11, 55.48],\n...                     'co2_emissions': [37.2, 19.66, 1712]},\n...                   index=['Pork', 'Wheat Products', 'Beef'])\n</code></pre> <pre><code>&gt;&gt;&gt; df\n                consumption  co2_emissions\nPork                  10.51         37.20\nWheat Products       103.11         19.66\nBeef                  55.48       1712.00\n</code></pre> <p>By default, it returns the index for the maximum value in each column.</p> <pre><code>&gt;&gt;&gt; df.idxmax()\nconsumption     Wheat Products\nco2_emissions             Beef\ndtype: object\n</code></pre> <p>To return the index for the maximum value in each row, use <code>axis=\"columns\"</code>.</p> <pre><code>&gt;&gt;&gt; df.idxmax(axis=\"columns\")\nPork              co2_emissions\nWheat Products     consumption\nBeef              co2_emissions\ndtype: object\n</code></pre> method &lt;/&gt; <p>Get the mode(s) of each element along the selected axis.</p><p>The mode of a set of values is the value that appears most often. It can be multiple values.</p> Parameters <ul> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to iterate over while searching for the mode:<ul> <li>0 or 'index' : get mode of each column</li> <li>1 or 'columns' : get mode of each row.</li> </ul> </li> <li><code>numeric_only</code> (bool, default False) \u2014 If True, only apply to numeric columns.</li> <li><code>dropna</code> (bool, default True) \u2014 Don't consider counts of NaN/NaT.</li> </ul> Returns (DataFrame) <p>The modes of each column or row.</p> See Also <p>Series.mode : Return the highest frequency value in a Series.Series.value_counts : Return the counts of values in a Series.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame([('bird', 2, 2),...                    ('mammal', 4, np.nan),\n...                    ('arthropod', 8, 0),\n...                    ('bird', 2, np.nan)],\n...                   index=('falcon', 'horse', 'spider', 'ostrich'),\n...                   columns=('species', 'legs', 'wings'))\n&gt;&gt;&gt; df\n           species  legs  wings\nfalcon        bird     2    2.0\nhorse       mammal     4    NaN\nspider   arthropod     8    0.0\nostrich       bird     2    NaN\n</code></pre> <p>By default, missing values are not considered, and the mode of wings are both 0 and 2. Because the resulting DataFrame has two rows, the second row of <code>species</code> and <code>legs</code> contains <code>NaN</code>.</p> <pre><code>&gt;&gt;&gt; df.mode()\n  species  legs  wings\n0    bird   2.0    0.0\n1     NaN   NaN    2.0\n</code></pre> <p>Setting <code>dropna=False</code> <code>NaN</code> values are considered and they can be the mode (like for wings).</p> <pre><code>&gt;&gt;&gt; df.mode(dropna=False)\n  species  legs  wings\n0    bird     2    NaN\n</code></pre> <p>Setting <code>numeric_only=True</code>, only the mode of numeric columns is computed, and columns of other types are ignored.</p> <pre><code>&gt;&gt;&gt; df.mode(numeric_only=True)\n   legs  wings\n0   2.0    0.0\n1   NaN    2.0\n</code></pre> <p>To compute the mode over columns and not rows, use the axis parameter:</p> <pre><code>&gt;&gt;&gt; df.mode(axis='columns', numeric_only=True)\n           0    1\nfalcon   2.0  NaN\nhorse    4.0  NaN\nspider   0.0  8.0\nostrich  2.0  NaN\n</code></pre> method &lt;/&gt; <p>Return values at the given quantile over requested axis.</p> Parameters <ul> <li><code>q</code> (float or array-like, default 0.5 (50% quantile)) \u2014 Value between 0 &lt;= q &lt;= 1, the quantile(s) to compute.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 Equals 0 or 'index' for row-wise, 1 or 'columns' for column-wise.</li> <li><code>numeric_only</code> (bool, default False) \u2014 Include only <code>float</code>, <code>int</code> or <code>boolean</code> data... versionchanged:: 2.0.0     The default value of <code>numeric_only</code> is now <code>False</code>. </li> <li><code>interpolation</code> ({'linear', 'lower', 'higher', 'midpoint', 'nearest'}) \u2014 This optional parameter specifies the interpolation method to use,when the desired quantile lies between two data points <code>i</code> and <code>j</code>: <ul> <li>linear: <code>i + (j - i) * fraction</code>, where <code>fraction</code> is the   fractional part of the index surrounded by <code>i</code> and <code>j</code>.</li> <li>lower: <code>i</code>.</li> <li>higher: <code>j</code>.</li> <li>nearest: <code>i</code> or <code>j</code> whichever is nearest.</li> <li>midpoint: (<code>i</code> + <code>j</code>) / 2.</li> </ul> </li> <li><code>method</code> ({'single', 'table'}, default 'single') \u2014 Whether to compute quantiles per-column ('single') or over all columns('table'). When 'table', the only allowed interpolation methods are 'nearest', 'lower', and 'higher'. </li> </ul> Returns (Series or DataFrame) <p>ee . e .</p> See Also <p>core.window.rolling.Rolling.quantile: Rolling quantile.numpy.percentile: Numpy function to compute the percentile.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame(np.array([[1, 1], [2, 10], [3, 100], [4, 100]]),...                   columns=['a', 'b'])\n&gt;&gt;&gt; df.quantile(.1)\na    1.3\nb    3.7\nName: 0.1, dtype: float64\n&gt;&gt;&gt; df.quantile([.1, .5])\n       a     b\n0.1  1.3   3.7\n0.5  2.5  55.0\n</code></pre> <p>Specifying <code>method='table'</code> will compute the quantile over all columns.</p> <pre><code>&gt;&gt;&gt; df.quantile(.1, method=\"table\", interpolation=\"nearest\")\na    1\nb    1\nName: 0.1, dtype: int64\n&gt;&gt;&gt; df.quantile([.1, .5], method=\"table\", interpolation=\"nearest\")\n     a    b\n0.1  1    1\n0.5  3  100\n</code></pre> <p>Specifying <code>numeric_only=False</code> will also compute the quantile of datetime and timedelta data.</p> <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'A': [1, 2],\n...                    'B': [pd.Timestamp('2010'),\n...                          pd.Timestamp('2011')],\n...                    'C': [pd.Timedelta('1 days'),\n...                          pd.Timedelta('2 days')]})\n&gt;&gt;&gt; df.quantile(0.5, numeric_only=False)\nA                    1.5\nB    2010-07-02 12:00:00\nC        1 days 12:00:00\nName: 0.5, dtype: object\n</code></pre> method &lt;/&gt; <p>Cast to DatetimeIndex of timestamps, at beginning of period.</p> Parameters <ul> <li><code>freq</code> (str, default frequency of PeriodIndex) \u2014 Desired frequency.</li> <li><code>how</code> ({'s', 'e', 'start', 'end'}) \u2014 Convention for converting period to timestamp; start of periodvs. end. </li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to convert (the index by default).</li> <li><code>copy</code> (bool, default True) \u2014 If False then underlying input data is not copied... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> </ul> Returns (DataFrame) <p>The DataFrame has a DatetimeIndex.</p> Examples <pre><code>&gt;&gt;&gt; idx = pd.PeriodIndex(['2023', '2024'], freq='Y')&gt;&gt;&gt; d = {'col1': [1, 2], 'col2': [3, 4]}\n&gt;&gt;&gt; df1 = pd.DataFrame(data=d, index=idx)\n&gt;&gt;&gt; df1\n      col1   col2\n2023     1      3\n2024     2      4\n</code></pre> <p>The resulting timestamps will be at the beginning of the year in this case</p> <pre><code>&gt;&gt;&gt; df1 = df1.to_timestamp()\n&gt;&gt;&gt; df1\n            col1   col2\n2023-01-01     1      3\n2024-01-01     2      4\n&gt;&gt;&gt; df1.index\nDatetimeIndex(['2023-01-01', '2024-01-01'], dtype='datetime64[ns]', freq=None)\n</code></pre> <p>Using <code>freq</code> which is the offset that the Timestamps will have</p> <pre><code>&gt;&gt;&gt; df2 = pd.DataFrame(data=d, index=idx)\n&gt;&gt;&gt; df2 = df2.to_timestamp(freq='M')\n&gt;&gt;&gt; df2\n            col1   col2\n2023-01-31     1      3\n2024-01-31     2      4\n&gt;&gt;&gt; df2.index\nDatetimeIndex(['2023-01-31', '2024-01-31'], dtype='datetime64[ns]', freq=None)\n</code></pre> method &lt;/&gt; <p>Convert DataFrame from DatetimeIndex to PeriodIndex.</p><p>Convert DataFrame from DatetimeIndex to PeriodIndex with desired frequency (inferred from index if not passed).</p> Parameters <ul> <li><code>freq</code> (str, default) \u2014 Frequency of the PeriodIndex.</li> <li><code>axis</code> ({0 or 'index', 1 or 'columns'}, default 0) \u2014 The axis to convert (the index by default).</li> <li><code>copy</code> (bool, default True) \u2014 If False then underlying input data is not copied... note::     The <code>copy</code> keyword will change behavior in pandas 3.0.     <code>Copy-on-Write     &lt;https://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html&gt;</code>__     will be enabled by default, which means that all methods with a     <code>copy</code> keyword will use a lazy copy mechanism to defer the copy and     ignore the <code>copy</code> keyword. The <code>copy</code> keyword will be removed in a     future version of pandas. <pre><code>You can already get the future behavior and improvements through\nenabling copy on write ``pd.options.mode.copy_on_write = True``\n</code></pre> </li> </ul> Returns (DataFrame) <p>The DataFrame has a PeriodIndex.</p> Examples <pre><code>&gt;&gt;&gt; idx = pd.to_datetime(...     [\n...         \"2001-03-31 00:00:00\",\n...         \"2002-05-31 00:00:00\",\n...         \"2003-08-31 00:00:00\",\n...     ]\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; idx\nDatetimeIndex(['2001-03-31', '2002-05-31', '2003-08-31'],\ndtype='datetime64[ns]', freq=None)\n</code></pre> <pre><code>&gt;&gt;&gt; idx.to_period(\"M\")\nPeriodIndex(['2001-03', '2002-05', '2003-08'], dtype='period[M]')\n</code></pre> <p>For the yearly frequency</p> <pre><code>&gt;&gt;&gt; idx.to_period(\"Y\")\nPeriodIndex(['2001', '2002', '2003'], dtype='period[Y-DEC]')\n</code></pre> method &lt;/&gt; <p>Whether each element in the DataFrame is contained in values.</p> Parameters <ul> <li><code>values</code> (iterable, Series, DataFrame or dict) \u2014 The result will only be true at a location if all thelabels match. If <code>values</code> is a Series, that's the index. If <code>values</code> is a dict, the keys must be the column names, which must match. If <code>values</code> is a DataFrame, then both the index and column labels must match. </li> </ul> Returns (DataFrame) <p>DataFrame of booleans showing whether each element in the DataFrameis contained in values.</p> See Also <p>DataFrame.eq: Equality test for DataFrame.Series.isin: Equivalent method on Series. Series.str.contains: Test if pattern or regex is contained within a     string of a Series or Index.</p> Examples <pre><code>&gt;&gt;&gt; df = pd.DataFrame({'num_legs': [2, 4], 'num_wings': [2, 0]},...                   index=['falcon', 'dog'])\n&gt;&gt;&gt; df\n        num_legs  num_wings\nfalcon         2          2\ndog            4          0\n</code></pre> <p>When <code>values</code> is a list check whether every value in the DataFrame is present in the list (which animals have 0 or 2 legs or wings)</p> <pre><code>&gt;&gt;&gt; df.isin([0, 2])\n        num_legs  num_wings\nfalcon      True       True\ndog        False       True\n</code></pre> <p>To check if <code>values</code> is not in the DataFrame, use the <code>~</code> operator:</p> <pre><code>&gt;&gt;&gt; ~df.isin([0, 2])\n        num_legs  num_wings\nfalcon     False      False\ndog         True      False\n</code></pre> <p>When <code>values</code> is a dict, we can pass values to check for each column separately:</p> <pre><code>&gt;&gt;&gt; df.isin({'num_wings': [0, 3]})\n        num_legs  num_wings\nfalcon     False      False\ndog        False       True\n</code></pre> <p>When <code>values</code> is a Series or DataFrame the index and column must match. Note that 'falcon' does not match based on the number of legs in other.</p> <pre><code>&gt;&gt;&gt; other = pd.DataFrame({'num_legs': [8, 3], 'num_wings': [0, 2]},\n...                      index=['spider', 'falcon'])\n&gt;&gt;&gt; df.isin(other)\n        num_legs  num_wings\nfalcon     False       True\ndog        False      False\n</code></pre> classmethod &lt;/&gt; <p>Create a channel from a list.</p><p>The second dimension is identified by tuple. if all elements are tuple, then a channel is created directly. Otherwise, elements are converted to tuples first and channels are created then.</p> Examples <pre><code>&gt;&gt;&gt; Channel.create([1, 2, 3]) # 3 rows, 1 column&gt;&gt;&gt; Channel.create([(1,2,3)]) # 1 row, 3 columns\n</code></pre> Parameters <ul> <li><code>value</code> (Union) \u2014 The value to create a channel</li> </ul> Returns (DataFrame) <p>A channel (dataframe)</p> classmethod &lt;/&gt; <p>Create a channel with a glob pattern</p> Parameters <ul> <li><code>ftype</code> (str, optional) \u2014 The file type, one of any, link, dir and file</li> <li><code>sortby</code> (str, optional) \u2014 How the files should be sorted. One of name, mtime and size</li> <li><code>reverse</code> (bool, optional) \u2014 Whether sort them in a reversed way.</li> </ul> Returns (DataFrame) <p>The channel</p> classmethod &lt;/&gt; <p>Create a width=2 channel with a glob pattern</p> Parameters <ul> <li><code>ftype</code> (str, optional) \u2014 The file type, one of any, link, dir and file</li> <li><code>sortby</code> (str, optional) \u2014 How the files should be sorted. One of name, mtime and size</li> <li><code>reverse</code> (bool, optional) \u2014 Whether sort them in a reversed way.</li> </ul> Returns (DataFrame) <p>The channel</p> classmethod &lt;/&gt; <p>Create a channel from a csv file</p><p>Uses pandas.read_csv() to create a channel</p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>**kwargs</code> \u2014 Arguments passing to pandas.read_csv()</li> </ul> classmethod &lt;/&gt; <p>Create a channel from an excel file.</p><p>Uses pandas.read_excel() to create a channel</p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>**kwargs</code> \u2014 Arguments passing to pandas.read_excel()</li> </ul> classmethod &lt;/&gt; <p>Create a channel from a table file.</p><p>Uses pandas.read_table() to create a channel</p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>**kwargs</code> \u2014 Arguments passing to pandas.read_table()</li> </ul> function &lt;/&gt; <p>Expand a Channel according to the files in ,other cols will keep the same.</p> <p>This is only applicable to a 1-row channel.</p> Examples <pre><code>&gt;&gt;&gt; ch = channel.create([('./', 1)])&gt;&gt;&gt; ch &gt;&gt; expand()\n&gt;&gt;&gt; [['./a', 1], ['./b', 1], ['./c', 1]]\n</code></pre> Parameters <ul> <li><code>col</code> (str | int, optional) \u2014 the index or name of the column used to expand</li> <li><code>pattern</code> (str, optional) \u2014 use a pattern to filter the files/dirs, default: <code>*</code></li> <li><code>ftype</code> (str, optional) \u2014 the type of the files/dirs to include<ul><li>- 'dir', 'file', 'link' or 'any' (default)</li></ul></li> <li><code>sortby</code> (str, optional) \u2014 how the list is sorted<ul><li>- 'name' (default), 'mtime', 'size'</li></ul></li> <li><code>reverse</code> (bool, optional) \u2014 reverse sort.</li> </ul> Returns (DataFrame) <p>The expanded channel</p> function &lt;/&gt; <p>Collapse a Channel according to the files in ,other cols will use the values in row 0.</p> <p>Note that other values in other rows will be discarded.</p> Examples <pre><code>&gt;&gt;&gt; ch = channel.create([['./a', 1], ['./b', 1], ['./c', 1]])&gt;&gt;&gt; ch &gt;&gt; collapse()\n&gt;&gt;&gt; [['.', 1]]\n</code></pre> Parameters <ul> <li><code>data</code> (DataFrame) \u2014 The original channel</li> <li><code>col</code> (str | int, optional) \u2014 the index or name of the column used to collapse on</li> </ul> Returns (DataFrame) <p>The collapsed channel</p>"},{"location":"api/pipen.channel/#pipenchannel","title":"pipen.channel","text":""},{"location":"api/pipen.channel/#pipenchannelchannel","title":"<code>pipen.channel.</code><code>Channel</code><code>(</code><code>data=None</code>, <code>index=None</code>, <code>columns=None</code>, <code>dtype=None</code>, <code>copy=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascorearraylikeopsmixinadd","title":"<code>__add__</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreaccessordirnamesmixindir","title":"<code>__dir__</code><code>(</code><code>)</code> \u2192 list","text":""},{"location":"api/pipen.channel/#pandascorebasepandasobjectsizeof","title":"<code>__sizeof__</code><code>(</code><code>)</code> \u2192 int","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeset_flags","title":"<code>set_flags</code><code>(</code><code>copy=False</code>, <code>allows_duplicate_labels=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeswapaxes","title":"<code>swapaxes</code><code>(</code><code>axis1</code>, <code>axis2</code>, <code>copy=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframedroplevel","title":"<code>droplevel</code><code>(</code><code>level</code>, <code>axis=0</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframesqueeze","title":"<code>squeeze</code><code>(</code><code>axis=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframerename_axis","title":"<code>rename_axis</code><code>(</code><code>mapper=&lt;no_default&gt;</code>, <code>index=&lt;no_default&gt;</code>, <code>columns=&lt;no_default&gt;</code>, <code>axis=0</code>, <code>copy=None</code>, <code>inplace=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeequals","title":"<code>equals</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframebool","title":"<code>bool</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeabs","title":"<code>abs</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeiter","title":"<code>__iter__</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframekeys","title":"<code>keys</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframecontains","title":"<code>__contains__</code><code>(</code><code>key</code><code>)</code> \u2192 bool","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_excel","title":"<code>to_excel</code><code>(</code><code>excel_writer</code>, <code>sheet_name='Sheet1'</code>, <code>na_rep=''</code>, <code>float_format=None</code>, <code>columns=None</code>, <code>header=True</code>, <code>index=True</code>, <code>index_label=None</code>, <code>startrow=0</code>, <code>startcol=0</code>, <code>engine=None</code>, <code>merge_cells=True</code>, <code>inf_rep='inf'</code>, <code>freeze_panes=None</code>, <code>storage_options=None</code>, <code>engine_kwargs=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_json","title":"<code>to_json</code><code>(</code><code>path_or_buf=None</code>, <code>orient=None</code>, <code>date_format=None</code>, <code>double_precision=10</code>, <code>force_ascii=True</code>, <code>date_unit='ms'</code>, <code>default_handler=None</code>, <code>lines=False</code>, <code>compression='infer'</code>, <code>index=None</code>, <code>indent=None</code>, <code>storage_options=None</code>, <code>mode='w'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_hdf","title":"<code>to_hdf</code><code>(</code><code>path_or_buf</code>, <code>key</code>, <code>mode='a'</code>, <code>complevel=None</code>, <code>complib=None</code>, <code>append=False</code>, <code>format=None</code>, <code>index=True</code>, <code>min_itemsize=None</code>, <code>nan_rep=None</code>, <code>dropna=None</code>, <code>data_columns=None</code>, <code>errors='strict'</code>, <code>encoding='UTF-8'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_sql","title":"<code>to_sql</code><code>(</code><code>name</code>, <code>con</code>, <code>schema=None</code>, <code>if_exists='fail'</code>, <code>index=True</code>, <code>index_label=None</code>, <code>chunksize=None</code>, <code>dtype=None</code>, <code>method=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_pickle","title":"<code>to_pickle</code><code>(</code><code>path</code>, <code>compression='infer'</code>, <code>protocol=5</code>, <code>storage_options=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_clipboard","title":"<code>to_clipboard</code><code>(</code><code>excel=True</code>, <code>sep=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_xarray","title":"<code>to_xarray</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_latex","title":"<code>to_latex</code><code>(</code><code>buf=None</code>, <code>columns=None</code>, <code>header=True</code>, <code>index=True</code>, <code>na_rep='NaN'</code>, <code>formatters=None</code>, <code>float_format=None</code>, <code>sparsify=None</code>, <code>index_names=True</code>, <code>bold_rows=False</code>, <code>column_format=None</code>, <code>longtable=None</code>, <code>escape=None</code>, <code>encoding=None</code>, <code>decimal='.'</code>, <code>multicolumn=None</code>, <code>multicolumn_format=None</code>, <code>multirow=None</code>, <code>caption=None</code>, <code>label=None</code>, <code>position=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeto_csv","title":"<code>to_csv</code><code>(</code><code>path_or_buf=None</code>, <code>sep=','</code>, <code>na_rep=''</code>, <code>float_format=None</code>, <code>columns=None</code>, <code>header=True</code>, <code>index=True</code>, <code>index_label=None</code>, <code>mode='w'</code>, <code>encoding=None</code>, <code>compression='infer'</code>, <code>quoting=None</code>, <code>quotechar='\"'</code>, <code>lineterminator=None</code>, <code>chunksize=None</code>, <code>date_format=None</code>, <code>doublequote=True</code>, <code>escapechar=None</code>, <code>decimal='.'</code>, <code>errors='strict'</code>, <code>storage_options=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframetake","title":"<code>take</code><code>(</code><code>indices</code>, <code>axis=0</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframexs","title":"<code>xs</code><code>(</code><code>key</code>, <code>axis=0</code>, <code>level=None</code>, <code>drop_level=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframedelitem","title":"<code>__delitem__</code><code>(</code><code>key</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeget","title":"<code>get</code><code>(</code><code>key</code>, <code>default=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframereindex_like","title":"<code>reindex_like</code><code>(</code><code>other</code>, <code>method=None</code>, <code>copy=None</code>, <code>limit=None</code>, <code>tolerance=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeadd_prefix","title":"<code>add_prefix</code><code>(</code><code>prefix</code>, <code>axis=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeadd_suffix","title":"<code>add_suffix</code><code>(</code><code>suffix</code>, <code>axis=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframefilter","title":"<code>filter</code><code>(</code><code>items=None</code>, <code>like=None</code>, <code>regex=None</code>, <code>axis=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframehead","title":"<code>head</code><code>(</code><code>n=5</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframetail","title":"<code>tail</code><code>(</code><code>n=5</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframesample","title":"<code>sample</code><code>(</code><code>n=None</code>, <code>frac=None</code>, <code>replace=False</code>, <code>weights=None</code>, <code>random_state=None</code>, <code>axis=None</code>, <code>ignore_index=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframepipe","title":"<code>pipe</code><code>(</code><code>func</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframefinalize","title":"<code>__finalize__</code><code>(</code><code>other</code>, <code>method=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframegetattr","title":"<code>__getattr__</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframesetattr","title":"<code>__setattr__</code><code>(</code><code>name</code>, <code>value</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeastype","title":"<code>astype</code><code>(</code><code>dtype</code>, <code>copy=None</code>, <code>errors='raise'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframecopy","title":"<code>copy</code><code>(</code><code>deep=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframedeepcopy","title":"<code>__deepcopy__</code><code>(</code><code>memo=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeinfer_objects","title":"<code>infer_objects</code><code>(</code><code>copy=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeconvert_dtypes","title":"<code>convert_dtypes</code><code>(</code><code>infer_objects=True</code>, <code>convert_string=True</code>, <code>convert_integer=True</code>, <code>convert_boolean=True</code>, <code>convert_floating=True</code>, <code>dtype_backend='numpy_nullable'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframefillna","title":"<code>fillna</code><code>(</code><code>value=None</code>, <code>method=None</code>, <code>axis=None</code>, <code>inplace=False</code>, <code>limit=None</code>, <code>downcast=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeffill","title":"<code>ffill</code><code>(</code><code>axis=None</code>, <code>inplace=False</code>, <code>limit=None</code>, <code>limit_area=None</code>, <code>downcast=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframepad","title":"<code>pad</code><code>(</code><code>axis=None</code>, <code>inplace=False</code>, <code>limit=None</code>, <code>downcast=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframebfill","title":"<code>bfill</code><code>(</code><code>axis=None</code>, <code>inplace=False</code>, <code>limit=None</code>, <code>limit_area=None</code>, <code>downcast=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframebackfill","title":"<code>backfill</code><code>(</code><code>axis=None</code>, <code>inplace=False</code>, <code>limit=None</code>, <code>downcast=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframereplace","title":"<code>replace</code><code>(</code><code>to_replace=None</code>, <code>value=&lt;no_default&gt;</code>, <code>inplace=False</code>, <code>limit=None</code>, <code>regex=False</code>, <code>method=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeinterpolate","title":"<code>interpolate</code><code>(</code><code>method='linear'</code>, <code>axis=0</code>, <code>limit=None</code>, <code>inplace=False</code>, <code>limit_direction=None</code>, <code>limit_area=None</code>, <code>downcast=&lt;no_default&gt;</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeasof","title":"<code>asof</code><code>(</code><code>where</code>, <code>subset=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeclip","title":"<code>clip</code><code>(</code><code>lower=None</code>, <code>upper=None</code>, <code>axis=None</code>, <code>inplace=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeasfreq","title":"<code>asfreq</code><code>(</code><code>freq</code>, <code>method=None</code>, <code>how=None</code>, <code>normalize=False</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeat_time","title":"<code>at_time</code><code>(</code><code>time</code>, <code>asof=False</code>, <code>axis=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframebetween_time","title":"<code>between_time</code><code>(</code><code>start_time</code>, <code>end_time</code>, <code>inclusive='both'</code>, <code>axis=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeresample","title":"<code>resample</code><code>(</code><code>rule</code>, <code>axis=&lt;no_default&gt;</code>, <code>closed=None</code>, <code>label=None</code>, <code>convention='start'</code>, <code>kind=&lt;no_default&gt;</code>, <code>on=None</code>, <code>level=None</code>, <code>origin='start_day'</code>, <code>offset=None</code>, <code>group_keys=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframefirst","title":"<code>first</code><code>(</code><code>offset</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframelast","title":"<code>last</code><code>(</code><code>offset</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframerank","title":"<code>rank</code><code>(</code><code>axis=0</code>, <code>method='average'</code>, <code>numeric_only=False</code>, <code>na_option='keep'</code>, <code>ascending=True</code>, <code>pct=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframealign","title":"<code>align</code><code>(</code><code>other</code>, <code>join='outer'</code>, <code>axis=None</code>, <code>level=None</code>, <code>copy=None</code>, <code>fill_value=None</code>, <code>method=&lt;no_default&gt;</code>, <code>limit=&lt;no_default&gt;</code>, <code>fill_axis=&lt;no_default&gt;</code>, <code>broadcast_axis=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframewhere","title":"<code>where</code><code>(</code><code>cond</code>, <code>other=nan</code>, <code>inplace=False</code>, <code>axis=None</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframemask","title":"<code>mask</code><code>(</code><code>cond</code>, <code>other=&lt;no_default&gt;</code>, <code>inplace=False</code>, <code>axis=None</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframetruncate","title":"<code>truncate</code><code>(</code><code>before=None</code>, <code>after=None</code>, <code>axis=None</code>, <code>copy=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframetz_convert","title":"<code>tz_convert</code><code>(</code><code>tz</code>, <code>axis=0</code>, <code>level=None</code>, <code>copy=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframetz_localize","title":"<code>tz_localize</code><code>(</code><code>tz</code>, <code>axis=0</code>, <code>level=None</code>, <code>copy=None</code>, <code>ambiguous='raise'</code>, <code>nonexistent='raise'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframedescribe","title":"<code>describe</code><code>(</code><code>percentiles=None</code>, <code>include=None</code>, <code>exclude=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframepct_change","title":"<code>pct_change</code><code>(</code><code>periods=1</code>, <code>fill_method=&lt;no_default&gt;</code>, <code>limit=&lt;no_default&gt;</code>, <code>freq=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframerolling","title":"<code>rolling</code><code>(</code><code>window</code>, <code>min_periods=None</code>, <code>center=False</code>, <code>win_type=None</code>, <code>on=None</code>, <code>axis=&lt;no_default&gt;</code>, <code>closed=None</code>, <code>step=None</code>, <code>method='single'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeexpanding","title":"<code>expanding</code><code>(</code><code>min_periods=1</code>, <code>axis=&lt;no_default&gt;</code>, <code>method='single'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframeewm","title":"<code>ewm</code><code>(</code><code>com=None</code>, <code>span=None</code>, <code>halflife=None</code>, <code>alpha=None</code>, <code>min_periods=0</code>, <code>adjust=True</code>, <code>ignore_na=False</code>, <code>axis=&lt;no_default&gt;</code>, <code>times=None</code>, <code>method='single'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframefirst_valid_index","title":"<code>first_valid_index</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoregenericndframelast_valid_index","title":"<code>last_valid_index</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframedataframe","title":"<code>__dataframe__</code><code>(</code><code>nan_as_null=False</code>, <code>allow_copy=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframedataframe_consortium_standard","title":"<code>__dataframe_consortium_standard__</code><code>(</code><code>api_version=None</code><code>)</code> \u2192 Any","text":""},{"location":"api/pipen.channel/#pandascoreframedataframearrow_c_stream","title":"<code>__arrow_c_stream__</code><code>(</code><code>requested_schema=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframerepr","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_string","title":"<code>to_string</code><code>(</code><code>buf=None</code>, <code>columns=None</code>, <code>col_space=None</code>, <code>header=True</code>, <code>index=True</code>, <code>na_rep='NaN'</code>, <code>formatters=None</code>, <code>float_format=None</code>, <code>sparsify=None</code>, <code>index_names=True</code>, <code>justify=None</code>, <code>max_rows=None</code>, <code>max_cols=None</code>, <code>show_dimensions=False</code>, <code>decimal='.'</code>, <code>line_width=None</code>, <code>min_rows=None</code>, <code>max_colwidth=None</code>, <code>encoding=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeitems","title":"<code>items</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeiterrows","title":"<code>iterrows</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeitertuples","title":"<code>itertuples</code><code>(</code><code>index=True</code>, <code>name='Pandas'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframelen","title":"<code>__len__</code><code>(</code><code>)</code> \u2192 int","text":""},{"location":"api/pipen.channel/#pandascoreframedataframedot","title":"<code>dot</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframematmul","title":"<code>__matmul__</code><code>(</code><code>other</code><code>)</code> \u2192 pandas.core.frame.dataframe | pandas.core.series.series","text":""},{"location":"api/pipen.channel/#pandascoreframedataframermatmul","title":"<code>__rmatmul__</code><code>(</code><code>other</code><code>)</code> \u2192 DataFrame","text":""},{"location":"api/pipen.channel/#pandascoreframedataframefrom_dict","title":"<code>from_dict</code><code>(</code><code>data</code>, <code>orient='columns'</code>, <code>dtype=None</code>, <code>columns=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_numpy","title":"<code>to_numpy</code><code>(</code><code>dtype=None</code>, <code>copy=False</code>, <code>na_value=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_dict","title":"<code>to_dict</code><code>(</code><code>orient='dict'</code>, <code>into=&lt;class 'dict'&gt;</code>, <code>index=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_gbq","title":"<code>to_gbq</code><code>(</code><code>destination_table</code>, <code>project_id=None</code>, <code>chunksize=None</code>, <code>reauth=False</code>, <code>if_exists='fail'</code>, <code>auth_local_webserver=True</code>, <code>table_schema=None</code>, <code>location=None</code>, <code>progress_bar=True</code>, <code>credentials=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframefrom_records","title":"<code>from_records</code><code>(</code><code>data</code>, <code>index=None</code>, <code>exclude=None</code>, <code>columns=None</code>, <code>coerce_float=False</code>, <code>nrows=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_records","title":"<code>to_records</code><code>(</code><code>index=True</code>, <code>column_dtypes=None</code>, <code>index_dtypes=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_stata","title":"<code>to_stata</code><code>(</code><code>path</code>, <code>convert_dates=None</code>, <code>write_index=True</code>, <code>byteorder=None</code>, <code>time_stamp=None</code>, <code>data_label=None</code>, <code>variable_labels=None</code>, <code>version=114</code>, <code>convert_strl=None</code>, <code>compression='infer'</code>, <code>storage_options=None</code>, <code>value_labels=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_feather","title":"<code>to_feather</code><code>(</code><code>path</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_markdown","title":"<code>to_markdown</code><code>(</code><code>buf=None</code>, <code>mode='wt'</code>, <code>index=True</code>, <code>storage_options=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_parquet","title":"<code>to_parquet</code><code>(</code><code>path=None</code>, <code>engine='auto'</code>, <code>compression='snappy'</code>, <code>index=None</code>, <code>partition_cols=None</code>, <code>storage_options=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_orc","title":"<code>to_orc</code><code>(</code><code>path=None</code>, <code>engine='pyarrow'</code>, <code>index=None</code>, <code>engine_kwargs=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_html","title":"<code>to_html</code><code>(</code><code>buf=None</code>, <code>columns=None</code>, <code>col_space=None</code>, <code>header=True</code>, <code>index=True</code>, <code>na_rep='NaN'</code>, <code>formatters=None</code>, <code>float_format=None</code>, <code>sparsify=None</code>, <code>index_names=True</code>, <code>justify=None</code>, <code>max_rows=None</code>, <code>max_cols=None</code>, <code>show_dimensions=False</code>, <code>decimal='.'</code>, <code>bold_rows=True</code>, <code>classes=None</code>, <code>escape=True</code>, <code>notebook=False</code>, <code>border=None</code>, <code>table_id=None</code>, <code>render_links=False</code>, <code>encoding=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_xml","title":"<code>to_xml</code><code>(</code><code>path_or_buffer=None</code>, <code>index=True</code>, <code>root_name='data'</code>, <code>row_name='row'</code>, <code>na_rep=None</code>, <code>attr_cols=None</code>, <code>elem_cols=None</code>, <code>namespaces=None</code>, <code>prefix=None</code>, <code>encoding='utf-8'</code>, <code>xml_declaration=True</code>, <code>pretty_print=True</code>, <code>parser='lxml'</code>, <code>stylesheet=None</code>, <code>compression='infer'</code>, <code>storage_options=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeinfo","title":"<code>info</code><code>(</code><code>verbose=None</code>, <code>buf=None</code>, <code>max_cols=None</code>, <code>memory_usage=None</code>, <code>show_counts=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframememory_usage","title":"<code>memory_usage</code><code>(</code><code>index=True</code>, <code>deep=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframetranspose","title":"<code>transpose</code><code>(</code><code>*args</code>, <code>copy=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeisetitem","title":"<code>isetitem</code><code>(</code><code>loc</code>, <code>value</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframequery","title":"<code>query</code><code>(</code><code>expr</code>, <code>inplace=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeeval","title":"<code>eval</code><code>(</code><code>expr</code>, <code>inplace=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeselect_dtypes","title":"<code>select_dtypes</code><code>(</code><code>include=None</code>, <code>exclude=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeinsert","title":"<code>insert</code><code>(</code><code>loc</code>, <code>column</code>, <code>value</code>, <code>allow_duplicates=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeassign","title":"<code>assign</code><code>(</code><code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeset_axis","title":"<code>set_axis</code><code>(</code><code>labels</code>, <code>axis=0</code>, <code>copy=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframereindex","title":"<code>reindex</code><code>(</code><code>labels=None</code>, <code>index=None</code>, <code>columns=None</code>, <code>axis=None</code>, <code>method=None</code>, <code>copy=None</code>, <code>level=None</code>, <code>fill_value=nan</code>, <code>limit=None</code>, <code>tolerance=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframedrop","title":"<code>drop</code><code>(</code><code>labels=None</code>, <code>axis=0</code>, <code>index=None</code>, <code>columns=None</code>, <code>level=None</code>, <code>inplace=False</code>, <code>errors='raise'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframerename","title":"<code>rename</code><code>(</code><code>mapper=None</code>, <code>index=None</code>, <code>columns=None</code>, <code>axis=None</code>, <code>copy=None</code>, <code>inplace=False</code>, <code>level=None</code>, <code>errors='ignore'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframepop","title":"<code>pop</code><code>(</code><code>item</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeshift","title":"<code>shift</code><code>(</code><code>periods=1</code>, <code>freq=None</code>, <code>axis=0</code>, <code>fill_value=&lt;no_default&gt;</code>, <code>suffix=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeset_index","title":"<code>set_index</code><code>(</code><code>keys</code>, <code>drop=True</code>, <code>append=False</code>, <code>inplace=False</code>, <code>verify_integrity=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframereset_index","title":"<code>reset_index</code><code>(</code><code>level=None</code>, <code>drop=False</code>, <code>inplace=False</code>, <code>col_level=0</code>, <code>col_fill=''</code>, <code>allow_duplicates=&lt;no_default&gt;</code>, <code>names=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeisna","title":"<code>isna</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeisnull","title":"<code>isnull</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframenotna","title":"<code>notna</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframenotnull","title":"<code>notnull</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframedropna","title":"<code>dropna</code><code>(</code><code>axis=0</code>, <code>how=&lt;no_default&gt;</code>, <code>thresh=&lt;no_default&gt;</code>, <code>subset=None</code>, <code>inplace=False</code>, <code>ignore_index=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframedrop_duplicates","title":"<code>drop_duplicates</code><code>(</code><code>subset=None</code>, <code>keep='first'</code>, <code>inplace=False</code>, <code>ignore_index=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeduplicated","title":"<code>duplicated</code><code>(</code><code>subset=None</code>, <code>keep='first'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframesort_values","title":"<code>sort_values</code><code>(</code><code>by</code>, <code>axis=0</code>, <code>ascending=True</code>, <code>inplace=False</code>, <code>kind='quicksort'</code>, <code>na_position='last'</code>, <code>ignore_index=False</code>, <code>key=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframesort_index","title":"<code>sort_index</code><code>(</code><code>axis=0</code>, <code>level=None</code>, <code>ascending=True</code>, <code>inplace=False</code>, <code>kind='quicksort'</code>, <code>na_position='last'</code>, <code>sort_remaining=True</code>, <code>ignore_index=False</code>, <code>key=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframevalue_counts","title":"<code>value_counts</code><code>(</code><code>subset=None</code>, <code>normalize=False</code>, <code>sort=True</code>, <code>ascending=False</code>, <code>dropna=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframenlargest","title":"<code>nlargest</code><code>(</code><code>n</code>, <code>columns</code>, <code>keep='first'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframensmallest","title":"<code>nsmallest</code><code>(</code><code>n</code>, <code>columns</code>, <code>keep='first'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeswaplevel","title":"<code>swaplevel</code><code>(</code><code>i=-2</code>, <code>j=-1</code>, <code>axis=0</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframereorder_levels","title":"<code>reorder_levels</code><code>(</code><code>order</code>, <code>axis=0</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeeq","title":"<code>eq</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframene","title":"<code>ne</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframele","title":"<code>le</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframelt","title":"<code>lt</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframege","title":"<code>ge</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframegt","title":"<code>gt</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeadd","title":"<code>add</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeradd","title":"<code>radd</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframesub","title":"<code>sub</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframersub","title":"<code>rsub</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemul","title":"<code>mul</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframermul","title":"<code>rmul</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframetruediv","title":"<code>truediv</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframertruediv","title":"<code>rtruediv</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframefloordiv","title":"<code>floordiv</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframerfloordiv","title":"<code>rfloordiv</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemod","title":"<code>mod</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframermod","title":"<code>rmod</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframepow","title":"<code>pow</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframerpow","title":"<code>rpow</code><code>(</code><code>other</code>, <code>axis='columns'</code>, <code>level=None</code>, <code>fill_value=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecompare","title":"<code>compare</code><code>(</code><code>other</code>, <code>align_axis=1</code>, <code>keep_shape=False</code>, <code>keep_equal=False</code>, <code>result_names=('self', 'other')</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecombine","title":"<code>combine</code><code>(</code><code>other</code>, <code>func</code>, <code>fill_value=None</code>, <code>overwrite=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecombine_first","title":"<code>combine_first</code><code>(</code><code>other</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeupdate","title":"<code>update</code><code>(</code><code>other</code>, <code>join='left'</code>, <code>overwrite=True</code>, <code>filter_func=None</code>, <code>errors='ignore'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframegroupby","title":"<code>groupby</code><code>(</code><code>by=None</code>, <code>axis=&lt;no_default&gt;</code>, <code>level=None</code>, <code>as_index=True</code>, <code>sort=True</code>, <code>group_keys=True</code>, <code>observed=&lt;no_default&gt;</code>, <code>dropna=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframepivot","title":"<code>pivot</code><code>(</code><code>columns</code>, <code>index=&lt;no_default&gt;</code>, <code>values=&lt;no_default&gt;</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframepivot_table","title":"<code>pivot_table</code><code>(</code><code>values=None</code>, <code>index=None</code>, <code>columns=None</code>, <code>aggfunc='mean'</code>, <code>fill_value=None</code>, <code>margins=False</code>, <code>dropna=True</code>, <code>margins_name='All'</code>, <code>observed=&lt;no_default&gt;</code>, <code>sort=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframestack","title":"<code>stack</code><code>(</code><code>level=-1</code>, <code>dropna=&lt;no_default&gt;</code>, <code>sort=&lt;no_default&gt;</code>, <code>future_stack=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeexplode","title":"<code>explode</code><code>(</code><code>column</code>, <code>ignore_index=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeunstack","title":"<code>unstack</code><code>(</code><code>level=-1</code>, <code>fill_value=None</code>, <code>sort=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemelt","title":"<code>melt</code><code>(</code><code>id_vars=None</code>, <code>value_vars=None</code>, <code>var_name=None</code>, <code>value_name='value'</code>, <code>col_level=None</code>, <code>ignore_index=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframediff","title":"<code>diff</code><code>(</code><code>periods=1</code>, <code>axis=0</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeaggregate","title":"<code>aggregate</code><code>(</code><code>func=None</code>, <code>axis=0</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframetransform","title":"<code>transform</code><code>(</code><code>func</code>, <code>axis=0</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeapply","title":"<code>apply</code><code>(</code><code>func</code>, <code>axis=0</code>, <code>raw=False</code>, <code>result_type=None</code>, <code>args=()</code>, <code>by_row='compat'</code>, <code>engine='python'</code>, <code>engine_kwargs=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemap","title":"<code>map</code><code>(</code><code>func</code>, <code>na_action=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeapplymap","title":"<code>applymap</code><code>(</code><code>func</code>, <code>na_action=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframejoin","title":"<code>join</code><code>(</code><code>other</code>, <code>on=None</code>, <code>how='left'</code>, <code>lsuffix=''</code>, <code>rsuffix=''</code>, <code>sort=False</code>, <code>validate=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemerge","title":"<code>merge</code><code>(</code><code>right</code>, <code>how='inner'</code>, <code>on=None</code>, <code>left_on=None</code>, <code>right_on=None</code>, <code>left_index=False</code>, <code>right_index=False</code>, <code>sort=False</code>, <code>suffixes=('_x', '_y')</code>, <code>copy=None</code>, <code>indicator=False</code>, <code>validate=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeround","title":"<code>round</code><code>(</code><code>decimals=0</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecorr","title":"<code>corr</code><code>(</code><code>method='pearson'</code>, <code>min_periods=1</code>, <code>numeric_only=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecov","title":"<code>cov</code><code>(</code><code>min_periods=None</code>, <code>ddof=1</code>, <code>numeric_only=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecorrwith","title":"<code>corrwith</code><code>(</code><code>other</code>, <code>axis=0</code>, <code>drop=False</code>, <code>method='pearson'</code>, <code>numeric_only=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecount","title":"<code>count</code><code>(</code><code>axis=0</code>, <code>numeric_only=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeany","title":"<code>any</code><code>(</code><code>axis=0</code>, <code>bool_only=False</code>, <code>skipna=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeall","title":"<code>all</code><code>(</code><code>axis=0</code>, <code>bool_only=False</code>, <code>skipna=True</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemin","title":"<code>min</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemax","title":"<code>max</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframesum","title":"<code>sum</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code>, <code>min_count=0</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeprod","title":"<code>prod</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code>, <code>min_count=0</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemean","title":"<code>mean</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#s","title":"s","text":"<p>) ) 0</p> <p>e</p> <p>) f b 2 3 ) 5 5 4</p> <p>1</p> <p>) 5 5 4</p> <p>d .</p> <p>, ) ) 5 4</p>"},{"location":"api/pipen.channel/#pandascoreframedataframemedian","title":"<code>median</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#s_1","title":"s","text":"<p>) ) 0</p> <p>e</p> <p>) f b 2 3 ) 5 5 4</p> <p>1</p> <p>) 5 5 4</p> <p>` .</p> <p>, ) ) 5 4</p>"},{"location":"api/pipen.channel/#pandascoreframedataframesem","title":"<code>sem</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>ddof=1</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#s_2","title":"s","text":"<p>) ) 5</p> <p>e</p> <p>) f b 2 3 ) 5 5 4</p> <p>1</p> <p>) 5 5 4</p> <p>` .</p> <p>, ) ) 5 4</p>"},{"location":"api/pipen.channel/#pandascoreframedataframevar","title":"<code>var</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>ddof=1</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframestd","title":"<code>std</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>ddof=1</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeskew","title":"<code>skew</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#s_3","title":"s","text":"<p>) ) 0</p> <p>e</p> <p>, ) f c 1 3 5 ) 0 0 0 4</p> <p>1</p> <p>) 1 1 0 4</p> <p>d .</p> <p>, ) ) 0 4</p>"},{"location":"api/pipen.channel/#pandascoreframedataframekurt","title":"<code>kurt</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#s_4","title":"s","text":"<p>) s 1 2 2 3 4 ) 5</p> <p>e</p> <p>, ) f b 3 4 4 4 ) 5 0 4</p> <p>e</p> <p>) 3</p> <p>1</p> <p>, ) ) 0 0 4</p>"},{"location":"api/pipen.channel/#pandascoreframedataframecummin","title":"<code>cummin</code><code>(</code><code>axis=None</code>, <code>skipna=True</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecummax","title":"<code>cummax</code><code>(</code><code>axis=None</code>, <code>skipna=True</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecumsum","title":"<code>cumsum</code><code>(</code><code>axis=None</code>, <code>skipna=True</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframecumprod","title":"<code>cumprod</code><code>(</code><code>axis=None</code>, <code>skipna=True</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframenunique","title":"<code>nunique</code><code>(</code><code>axis=0</code>, <code>dropna=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeidxmin","title":"<code>idxmin</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeidxmax","title":"<code>idxmax</code><code>(</code><code>axis=0</code>, <code>skipna=True</code>, <code>numeric_only=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframemode","title":"<code>mode</code><code>(</code><code>axis=0</code>, <code>numeric_only=False</code>, <code>dropna=True</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframequantile","title":"<code>quantile</code><code>(</code><code>q=0.5</code>, <code>axis=0</code>, <code>numeric_only=False</code>, <code>interpolation='linear'</code>, <code>method='single'</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_timestamp","title":"<code>to_timestamp</code><code>(</code><code>freq=None</code>, <code>how='start'</code>, <code>axis=0</code>, <code>copy=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeto_period","title":"<code>to_period</code><code>(</code><code>freq=None</code>, <code>axis=0</code>, <code>copy=None</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pandascoreframedataframeisin","title":"<code>isin</code><code>(</code><code>values</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pipenchannelchannelcreate","title":"<code>create</code><code>(</code><code>value</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pipenchannelchannelfrom_glob","title":"<code>from_glob</code><code>(</code><code>pattern</code>, <code>ftype='any'</code>, <code>sortby='name'</code>, <code>reverse=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pipenchannelchannelfrom_pairs","title":"<code>from_pairs</code><code>(</code><code>pattern</code>, <code>ftype='any'</code>, <code>sortby='name'</code>, <code>reverse=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pipenchannelchannelfrom_csv","title":"<code>from_csv</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pipenchannelchannelfrom_excel","title":"<code>from_excel</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pipenchannelchannelfrom_table","title":"<code>from_table</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pipenchannelexpand_dir","title":"<code>pipen.channel.</code><code>expand_dir</code><code>(</code><code>data</code>, <code>col=0</code>, <code>pattern='*'</code>, <code>ftype='any'</code>, <code>sortby='name'</code>, <code>reverse=False</code><code>)</code>","text":""},{"location":"api/pipen.channel/#pipenchannelcollapse_files","title":"<code>pipen.channel.</code><code>collapse_files</code><code>(</code><code>data</code>, <code>col=0</code><code>)</code>","text":""},{"location":"api/pipen.cli.help/","title":"pipen.cli.help","text":"module &lt;/&gt; <p>Print help for commands</p> Classes <ul> <li><code>CLIHelpPlugin</code> \u2014 Print help for commands&lt;/&gt;</li> </ul> class &lt;/&gt; Bases pipen.cli._hooks.CLIPlugin <p>Print help for commands</p> Methods <ul> <li><code>exec_command</code><code>(</code><code>args</code><code>)</code> \u2014 Run the command&lt;/&gt;</li> <li><code>parse_args</code><code>(</code><code>known_parsed</code>, <code>unparsed_argv</code><code>)</code> (Namespace) \u2014 Define arguments for the command&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Define arguments for the command</p> method &lt;/&gt; <p>Run the command</p>"},{"location":"api/pipen.cli.help/#pipenclihelp","title":"pipen.cli.help","text":""},{"location":"api/pipen.cli.help/#pipenclihelpclihelpplugin","title":"<code>pipen.cli.help.</code><code>CLIHelpPlugin</code><code>(</code><code>parser</code>, <code>subparser</code><code>)</code>","text":""},{"location":"api/pipen.cli.help/#pipencli_hooksclipluginparse_args","title":"<code>parse_args</code><code>(</code><code>known_parsed</code>, <code>unparsed_argv</code><code>)</code> \u2192 Namespace","text":""},{"location":"api/pipen.cli.help/#pipenclihelpclihelppluginexec_command","title":"<code>exec_command</code><code>(</code><code>args</code><code>)</code>","text":""},{"location":"api/pipen.cli/","title":"pipen.cli","text":"package &lt;/&gt; <p>Provide CLI for pipen</p> module &lt;/&gt; <p>List available profiles.</p> Classes <ul> <li><code>CLIProfilePlugin</code> \u2014 List available profiles.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Print help for commands</p> Classes <ul> <li><code>CLIVersionPlugin</code> \u2014 Print versions of pipen and its dependencies&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Print help for commands</p> Classes <ul> <li><code>CLIHelpPlugin</code> \u2014 Print help for commands&lt;/&gt;</li> </ul> module &lt;/&gt; <p>List plugins</p> Classes <ul> <li><code>CliPluginsPlugin</code> \u2014 List installed plugins&lt;/&gt;</li> </ul>"},{"location":"api/pipen.cli/#pipencli","title":"pipen.cli","text":""},{"location":"api/pipen.cli/#pipencliprofile","title":"pipen.cli.profile","text":""},{"location":"api/pipen.cli/#pipencliversion","title":"pipen.cli.version","text":""},{"location":"api/pipen.cli/#pipenclihelp","title":"pipen.cli.help","text":""},{"location":"api/pipen.cli/#pipencliplugins","title":"pipen.cli.plugins","text":""},{"location":"api/pipen.cli.plugins/","title":"pipen.cli.plugins","text":"module &lt;/&gt; <p>List plugins</p> Classes <ul> <li><code>CliPluginsPlugin</code> \u2014 List installed plugins&lt;/&gt;</li> </ul> class &lt;/&gt; Bases pipen.cli._hooks.CLIPlugin <p>List installed plugins</p> Methods <ul> <li><code>exec_command</code><code>(</code><code>args</code><code>)</code> \u2014 Execute the command&lt;/&gt;</li> <li><code>parse_args</code><code>(</code><code>known_parsed</code>, <code>unparsed_argv</code><code>)</code> (Namespace) \u2014 Define arguments for the command&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Define arguments for the command</p> method &lt;/&gt; <p>Execute the command</p>"},{"location":"api/pipen.cli.plugins/#pipencliplugins","title":"pipen.cli.plugins","text":""},{"location":"api/pipen.cli.plugins/#pipenclipluginsclipluginsplugin","title":"<code>pipen.cli.plugins.</code><code>CliPluginsPlugin</code><code>(</code><code>parser</code>, <code>subparser</code><code>)</code>","text":""},{"location":"api/pipen.cli.plugins/#pipencli_hooksclipluginparse_args","title":"<code>parse_args</code><code>(</code><code>known_parsed</code>, <code>unparsed_argv</code><code>)</code> \u2192 Namespace","text":""},{"location":"api/pipen.cli.plugins/#pipenclipluginsclipluginspluginexec_command","title":"<code>exec_command</code><code>(</code><code>args</code><code>)</code>","text":""},{"location":"api/pipen.cli.profile/","title":"pipen.cli.profile","text":"module &lt;/&gt; <p>List available profiles.</p> Classes <ul> <li><code>CLIProfilePlugin</code> \u2014 List available profiles.&lt;/&gt;</li> </ul> class &lt;/&gt; Bases pipen.cli._hooks.CLIPlugin <p>List available profiles.</p> Methods <ul> <li><code>exec_command</code><code>(</code><code>args</code><code>)</code> \u2014 Run the command&lt;/&gt;</li> <li><code>parse_args</code><code>(</code><code>known_parsed</code>, <code>unparsed_argv</code><code>)</code> (Namespace) \u2014 Define arguments for the command&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Define arguments for the command</p> method &lt;/&gt; <p>Run the command</p>"},{"location":"api/pipen.cli.profile/#pipencliprofile","title":"pipen.cli.profile","text":""},{"location":"api/pipen.cli.profile/#pipencliprofilecliprofileplugin","title":"<code>pipen.cli.profile.</code><code>CLIProfilePlugin</code><code>(</code><code>parser</code>, <code>subparser</code><code>)</code>","text":""},{"location":"api/pipen.cli.profile/#pipencli_hooksclipluginparse_args","title":"<code>parse_args</code><code>(</code><code>known_parsed</code>, <code>unparsed_argv</code><code>)</code> \u2192 Namespace","text":""},{"location":"api/pipen.cli.profile/#pipencliprofilecliprofilepluginexec_command","title":"<code>exec_command</code><code>(</code><code>args</code><code>)</code>","text":""},{"location":"api/pipen.cli.version/","title":"pipen.cli.version","text":"module &lt;/&gt; <p>Print help for commands</p> Classes <ul> <li><code>CLIVersionPlugin</code> \u2014 Print versions of pipen and its dependencies&lt;/&gt;</li> </ul> class &lt;/&gt; Bases pipen.cli._hooks.CLIPlugin <p>Print versions of pipen and its dependencies</p> Methods <ul> <li><code>exec_command</code><code>(</code><code>args</code><code>)</code> \u2014 Run the command&lt;/&gt;</li> <li><code>parse_args</code><code>(</code><code>known_parsed</code>, <code>unparsed_argv</code><code>)</code> (Namespace) \u2014 Define arguments for the command&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Define arguments for the command</p> method &lt;/&gt; <p>Run the command</p>"},{"location":"api/pipen.cli.version/#pipencliversion","title":"pipen.cli.version","text":""},{"location":"api/pipen.cli.version/#pipencliversioncliversionplugin","title":"<code>pipen.cli.version.</code><code>CLIVersionPlugin</code><code>(</code><code>parser</code>, <code>subparser</code><code>)</code>","text":""},{"location":"api/pipen.cli.version/#pipencli_hooksclipluginparse_args","title":"<code>parse_args</code><code>(</code><code>known_parsed</code>, <code>unparsed_argv</code><code>)</code> \u2192 Namespace","text":""},{"location":"api/pipen.cli.version/#pipencliversioncliversionpluginexec_command","title":"<code>exec_command</code><code>(</code><code>args</code><code>)</code>","text":""},{"location":"api/pipen.defaults/","title":"pipen.defaults","text":"module &lt;/&gt; <p>Provide some default values/objects</p> Classes <ul> <li><code>ProcInputType</code> \u2014 Types for process inputs&lt;/&gt;</li> <li><code>ProcOutputType</code> \u2014 Types for process outputs&lt;/&gt;</li> </ul> class &lt;/&gt; <p>Types for process inputs</p> class &lt;/&gt; <p>Types for process outputs</p>"},{"location":"api/pipen.defaults/#pipendefaults","title":"pipen.defaults","text":""},{"location":"api/pipen.defaults/#pipendefaultsprocinputtype","title":"<code>pipen.defaults.</code><code>ProcInputType</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.defaults/#pipendefaultsprocoutputtype","title":"<code>pipen.defaults.</code><code>ProcOutputType</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/","title":"pipen.exceptions","text":"module &lt;/&gt; <p>Provide exception classes</p> Classes <ul> <li><code>PipenException</code> \u2014 Base exception class for pipen&lt;/&gt;</li> <li><code>PipenSetDataError</code> \u2014 When trying to set input data to processes with input_data already setusing Pipen.set_data(). &lt;/&gt;</li> <li><code>ProcInputTypeError</code> \u2014 When an unsupported input type is provided&lt;/&gt;</li> <li><code>ProcInputKeyError</code> \u2014 When an unsupported input key is provided&lt;/&gt;</li> <li><code>ProcInputValueError</code> \u2014 When an unsupported input value is provided&lt;/&gt;</li> <li><code>ProcScriptFileNotFound</code> \u2014 When script file specified as 'file://' cannot be found&lt;/&gt;</li> <li><code>ProcOutputNameError</code> \u2014 When no name or malformatted output is provided&lt;/&gt;</li> <li><code>ProcOutputTypeError</code> \u2014 When an unsupported output type is provided&lt;/&gt;</li> <li><code>ProcOutputValueError</code> \u2014 When a malformatted output value is provided&lt;/&gt;</li> <li><code>ProcDependencyError</code> \u2014 When there is something wrong the process dependencies&lt;/&gt;</li> <li><code>NoSuchSchedulerError</code> \u2014 When specified scheduler cannot be found&lt;/&gt;</li> <li><code>WrongSchedulerTypeError</code> \u2014 When specified scheduler is not a subclass of Scheduler&lt;/&gt;</li> <li><code>NoSuchTemplateEngineError</code> \u2014 When specified template engine cannot be found&lt;/&gt;</li> <li><code>WrongTemplateEnginTypeError</code> \u2014 When specified tempalte engine is not a subclass of Scheduler&lt;/&gt;</li> <li><code>TemplateRenderingError</code> \u2014 Failed to render a template&lt;/&gt;</li> <li><code>ConfigurationError</code> \u2014 When something wrong set as configuration&lt;/&gt;</li> <li><code>PipenOrProcNameError</code> \u2014 \"When more than one processes are sharing the same workdir&lt;/&gt;</li> </ul> class &lt;/&gt; Bases Exception BaseException <p>Base exception class for pipen</p> class &lt;/&gt; Bases pipen.exceptions.PipenException ValueError Exception BaseException <p>When trying to set input data to processes with input_data already setusing Pipen.set_data().</p> class &lt;/&gt; Bases pipen.exceptions.PipenException TypeError Exception BaseException <p>When an unsupported input type is provided</p> class &lt;/&gt; Bases pipen.exceptions.PipenException KeyError LookupError Exception BaseException <p>When an unsupported input key is provided</p> class &lt;/&gt; Bases pipen.exceptions.PipenException ValueError Exception BaseException <p>When an unsupported input value is provided</p> class &lt;/&gt; Bases pipen.exceptions.PipenException FileNotFoundError OSError Exception BaseException <p>When script file specified as 'file://' cannot be found</p> class &lt;/&gt; Bases pipen.exceptions.PipenException NameError Exception BaseException <p>When no name or malformatted output is provided</p> class &lt;/&gt; Bases pipen.exceptions.PipenException TypeError Exception BaseException <p>When an unsupported output type is provided</p> class &lt;/&gt; Bases pipen.exceptions.PipenException ValueError Exception BaseException <p>When a malformatted output value is provided</p> class &lt;/&gt; Bases pipen.exceptions.PipenException Exception BaseException <p>When there is something wrong the process dependencies</p> class &lt;/&gt; Bases pipen.exceptions.PipenException Exception BaseException <p>When specified scheduler cannot be found</p> class &lt;/&gt; Bases pipen.exceptions.PipenException TypeError Exception BaseException <p>When specified scheduler is not a subclass of Scheduler</p> class &lt;/&gt; Bases pipen.exceptions.PipenException Exception BaseException <p>When specified template engine cannot be found</p> class &lt;/&gt; Bases pipen.exceptions.PipenException TypeError Exception BaseException <p>When specified tempalte engine is not a subclass of Scheduler</p> class &lt;/&gt; Bases pipen.exceptions.PipenException Exception BaseException <p>Failed to render a template</p> class &lt;/&gt; Bases pipen.exceptions.PipenException Exception BaseException <p>When something wrong set as configuration</p> class &lt;/&gt; Bases pipen.exceptions.PipenException Exception BaseException <p>\"When more than one processes are sharing the same workdir</p>"},{"location":"api/pipen.exceptions/#pipenexceptions","title":"pipen.exceptions","text":""},{"location":"api/pipen.exceptions/#pipenexceptionspipenexception","title":"<code>pipen.exceptions.</code><code>PipenException</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionspipensetdataerror","title":"<code>pipen.exceptions.</code><code>PipenSetDataError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsprocinputtypeerror","title":"<code>pipen.exceptions.</code><code>ProcInputTypeError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsprocinputkeyerror","title":"<code>pipen.exceptions.</code><code>ProcInputKeyError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsprocinputvalueerror","title":"<code>pipen.exceptions.</code><code>ProcInputValueError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsprocscriptfilenotfound","title":"<code>pipen.exceptions.</code><code>ProcScriptFileNotFound</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsprocoutputnameerror","title":"<code>pipen.exceptions.</code><code>ProcOutputNameError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsprocoutputtypeerror","title":"<code>pipen.exceptions.</code><code>ProcOutputTypeError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsprocoutputvalueerror","title":"<code>pipen.exceptions.</code><code>ProcOutputValueError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsprocdependencyerror","title":"<code>pipen.exceptions.</code><code>ProcDependencyError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsnosuchschedulererror","title":"<code>pipen.exceptions.</code><code>NoSuchSchedulerError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionswrongschedulertypeerror","title":"<code>pipen.exceptions.</code><code>WrongSchedulerTypeError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsnosuchtemplateengineerror","title":"<code>pipen.exceptions.</code><code>NoSuchTemplateEngineError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionswrongtemplateengintypeerror","title":"<code>pipen.exceptions.</code><code>WrongTemplateEnginTypeError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionstemplaterenderingerror","title":"<code>pipen.exceptions.</code><code>TemplateRenderingError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionsconfigurationerror","title":"<code>pipen.exceptions.</code><code>ConfigurationError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.exceptions/#pipenexceptionspipenorprocnameerror","title":"<code>pipen.exceptions.</code><code>PipenOrProcNameError</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.job/","title":"pipen.job","text":"module &lt;/&gt; <p>Provide the Job class</p> Classes <ul> <li><code>Job</code> \u2014 The job for pipen&lt;/&gt;</li> </ul> class &lt;/&gt; Bases xqute.job.Job pipen._job_caching.JobCaching <p>The job for pipen</p> Attributes <ul> <li><code>cached</code> \u2014 Check if a job is cached&lt;/&gt;</li> <li><code>jid</code> (int | str | none) \u2014 Get the jid of the job in scheduler system&lt;/&gt;</li> <li><code>jid_file</code> (SpecPath) \u2014 The jid file of the job&lt;/&gt;</li> <li><code>rc</code> (int) \u2014 The return code of the job&lt;/&gt;</li> <li><code>rc_file</code> (SpecPath) \u2014 The rc file of the job&lt;/&gt;</li> <li><code>retry_dir</code> (SpecPath) \u2014 The retry directory of the job&lt;/&gt;</li> <li><code>script_file</code> \u2014 Get the path to script file&lt;/&gt;</li> <li><code>signature_file</code> \u2014 Get the path to the signature file&lt;/&gt;</li> <li><code>status</code> (int) \u2014 Query the status of the jobIf the job is submitted, try to query it from the status file Make sure the status is updated by trap in wrapped script &lt;/&gt;</li> <li><code>status_file</code> (SpecPath) \u2014 The status file of the job&lt;/&gt;</li> <li><code>stderr_file</code> (SpecPath) \u2014 The stderr file of the job&lt;/&gt;</li> <li><code>stdout_file</code> (SpecPath) \u2014 The stdout file of the job&lt;/&gt;</li> </ul> Methods <ul> <li><code>__repr__</code><code>(</code><code>)</code> (str) \u2014 repr of the job&lt;/&gt;</li> <li><code>cache</code><code>(</code><code>)</code> \u2014 write signature to signature file&lt;/&gt;</li> <li><code>clean</code><code>(</code><code>retry</code><code>)</code> \u2014 Clean up the meta files&lt;/&gt;</li> <li><code>log</code><code>(</code><code>level</code>, <code>msg</code>, <code>*args</code>, <code>limit</code>, <code>limit_indicator</code>, <code>logger</code><code>)</code> \u2014 Log message for the jobs&lt;/&gt;</li> <li><code>prepare</code><code>(</code><code>proc</code><code>)</code> \u2014 Prepare the job by given process&lt;/&gt;</li> </ul> method &lt;/&gt; <p>write signature to signature file</p> method &lt;/&gt; <p>repr of the job</p> method &lt;/&gt; <p>Clean up the meta files</p> Parameters <ul> <li><code>retry</code> (optional) \u2014 Whether clean it for retrying</li> </ul> method &lt;/&gt; <p>Prepare the job by given process</p><p>Primarily prepare the script, and provide cmd to the job for xqute to wrap and run</p> Parameters <ul> <li><code>proc</code> (Proc) \u2014 the process object</li> </ul> method &lt;/&gt; <p>Log message for the jobs</p> Parameters <ul> <li><code>level</code> (int | str) \u2014 The log level of the record</li> <li><code>msg</code> (str) \u2014 The message to log</li> <li><code>*args</code> \u2014 The arguments to format the message</li> <li><code>limit</code> (int, optional) \u2014 limitation of the log (don't log for all jobs)</li> <li><code>limit_indicator</code> (bool, optional) \u2014 Whether to show an indicator saying the loghas been limited (the level of the indicator will be DEBUG) </li> <li><code>logger</code> (LoggerAdapter, optional) \u2014 The logger used to log</li> </ul>"},{"location":"api/pipen.job/#pipenjob","title":"pipen.job","text":""},{"location":"api/pipen.job/#pipenjobjob","title":"<code>pipen.job.</code><code>Job</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.job/#pipen_job_cachingjobcachingcache","title":"<code>cache</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.job/#xqutejobjobrepr","title":"<code>__repr__</code><code>(</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.job/#xqutejobjobclean","title":"<code>clean</code><code>(</code><code>retry=False</code><code>)</code>","text":""},{"location":"api/pipen.job/#pipenjobjobprepare","title":"<code>prepare</code><code>(</code><code>proc</code><code>)</code>","text":""},{"location":"api/pipen.job/#pipenjobjoblog","title":"<code>log</code><code>(</code><code>level</code>, <code>msg</code>, <code>*args</code>, <code>limit=3</code>, <code>limit_indicator=True</code>, <code>logger=&lt;LoggerAdapter pipen.core (WARNING)&gt;</code><code>)</code>","text":""},{"location":"api/pipen/","title":"pipen","text":"package &lt;/&gt; <p>A pipeline framework for python</p> module &lt;/&gt; <p>Define hooks specifications and provide plugin manager</p> Classes <ul> <li><code>PipenMainPlugin</code> \u2014 The builtin core plugin, used to update the progress bar andcache the job &lt;/&gt;</li> <li><code>XqutePipenPlugin</code> \u2014 The plugin for xqute working as proxy for pipen plugin hooks&lt;/&gt;</li> </ul> Functions <ul> <li><code>on_complete</code><code>(</code><code>pipen</code>, <code>succeeded</code><code>)</code> \u2014 The the pipeline is completed.&lt;/&gt;</li> <li><code>on_init</code><code>(</code><code>pipen</code><code>)</code> \u2014 When the pipeline is initialized, and default configs are loaded&lt;/&gt;</li> <li><code>on_job_cached</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is cached.&lt;/&gt;</li> <li><code>on_job_failed</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is done but failed.&lt;/&gt;</li> <li><code>on_job_init</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is initialized&lt;/&gt;</li> <li><code>on_job_killed</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is killed&lt;/&gt;</li> <li><code>on_job_killing</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 When a job is being killed.&lt;/&gt;</li> <li><code>on_job_polling</code><code>(</code><code>job</code>, <code>counter</code><code>)</code> \u2014 When status of a job is being polled.&lt;/&gt;</li> <li><code>on_job_queued</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is queued in xqute. Note it might not be queued yet inthe scheduler system. &lt;/&gt;</li> <li><code>on_job_started</code><code>(</code><code>job</code><code>)</code> \u2014 When a job starts to run in then scheduler system.&lt;/&gt;</li> <li><code>on_job_submitted</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is submitted in the scheduler system.&lt;/&gt;</li> <li><code>on_job_submitting</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 When a job is submitting.&lt;/&gt;</li> <li><code>on_job_succeeded</code><code>(</code><code>job</code><code>)</code> \u2014 When a job completes successfully.&lt;/&gt;</li> <li><code>on_jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 When the job command finishes and after the postscript is run&lt;/&gt;</li> <li><code>on_jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 When the job command wrapper script is initialized before the prescript is run&lt;/&gt;</li> <li><code>on_jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 When the job command right about to be run&lt;/&gt;</li> <li><code>on_proc_create</code><code>(</code><code>proc</code><code>)</code> \u2014 Called Proc constructor when a process is created.&lt;/&gt;</li> <li><code>on_proc_done</code><code>(</code><code>proc</code>, <code>succeeded</code><code>)</code> \u2014 When a process is done&lt;/&gt;</li> <li><code>on_proc_init</code><code>(</code><code>proc</code><code>)</code> \u2014 Called when a process is initialized.&lt;/&gt;</li> <li><code>on_proc_input_computed</code><code>(</code><code>proc</code><code>)</code> \u2014 Called after process input data is computed.&lt;/&gt;</li> <li><code>on_proc_script_computed</code><code>(</code><code>proc</code><code>)</code> \u2014 Called after process script is computed.&lt;/&gt;</li> <li><code>on_proc_shutdown</code><code>(</code><code>proc</code>, <code>sig</code><code>)</code> \u2014 When pipeline is shutting down, by Ctrl-c for example.&lt;/&gt;</li> <li><code>on_proc_start</code><code>(</code><code>proc</code><code>)</code> \u2014 When a process is starting&lt;/&gt;</li> <li><code>on_setup</code><code>(</code><code>pipen</code><code>)</code> \u2014 Setup for plugins, primarily used for the plugins tosetup some default configurations. &lt;/&gt;</li> <li><code>on_start</code><code>(</code><code>pipen</code><code>)</code> \u2014 Right before the pipeline starts running.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide some utilities</p> Classes <ul> <li><code>RichHandler</code> \u2014 Subclass of rich.logging.RichHandler, showing log levels as a singlecharacter &lt;/&gt;</li> <li><code>RichConsole</code> \u2014 A high level console interface.&lt;/&gt;</li> </ul> Functions <ul> <li><code>brief_list</code><code>(</code><code>blist</code><code>)</code> (str) \u2014 Briefly show an integer list, combine the continuous numbers.&lt;/&gt;</li> <li><code>copy_dict</code><code>(</code><code>dic</code>, <code>depth</code><code>)</code> (Mapping) \u2014 Deep copy a dict&lt;/&gt;</li> <li><code>desc_from_docstring</code><code>(</code><code>obj</code>, <code>base</code><code>)</code> (str) \u2014 Get the description from docstring&lt;/&gt;</li> <li><code>get_base</code><code>(</code><code>klass</code>, <code>abc_base</code>, <code>value</code>, <code>value_getter</code><code>)</code> (Type) \u2014 Get the base class where the value was first defined&lt;/&gt;</li> <li><code>get_logger</code><code>(</code><code>name</code>, <code>level</code><code>)</code> (LoggerAdapter) \u2014 Get the logger by given plugin name&lt;/&gt;</li> <li><code>get_logpanel_width</code><code>(</code><code>)</code> (int) \u2014 Get the width of the log content&lt;/&gt;</li> <li><code>get_marked</code><code>(</code><code>cls</code>, <code>mark_name</code>, <code>default</code><code>)</code> (Any) \u2014 Get the marked value from a proc&lt;/&gt;</li> <li><code>get_mtime</code><code>(</code><code>path</code>, <code>dir_depth</code><code>)</code> (float) \u2014 Get the modification time of a path.If path is a directory, try to get the last modification time of the contents in the directory at given dir_depth &lt;/&gt;</li> <li><code>get_shebang</code><code>(</code><code>script</code><code>)</code> (str) \u2014 Get the shebang of the script&lt;/&gt;</li> <li><code>ignore_firstline_dedent</code><code>(</code><code>text</code><code>)</code> (str) \u2014 Like textwrap.dedent(), but ignore first empty lines&lt;/&gt;</li> <li><code>is_loading_pipeline</code><code>(</code><code>*flags</code>, <code>argv</code><code>)</code> (bool) \u2014 Check if we are loading the pipeline. Works only when<code>argv0</code> is \"@pipen\" while loading the pipeline. &lt;/&gt;</li> <li><code>is_subclass</code><code>(</code><code>obj</code>, <code>cls</code><code>)</code> (bool) \u2014 Tell if obj is a subclass of clsDifferences with issubclass is that we don't raise Type error if obj is not a class &lt;/&gt;</li> <li><code>is_valid_name</code><code>(</code><code>name</code><code>)</code> (bool) \u2014 Check if a name is valid for a proc or pipen&lt;/&gt;</li> <li><code>load_entrypoints</code><code>(</code><code>group</code><code>)</code> (Iterable) \u2014 Load objects from setuptools entrypoints by given group name&lt;/&gt;</li> <li><code>load_pipeline</code><code>(</code><code>obj</code>, <code>argv0</code>, <code>argv1p</code>, <code>**kwargs</code><code>)</code> (Pipen) \u2014 Load a pipeline from a Pipen, Proc or ProcGroup object&lt;/&gt;</li> <li><code>log_rich_renderable</code><code>(</code><code>renderable</code>, <code>color</code>, <code>logfunc</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Log a rich renderable to logger&lt;/&gt;</li> <li><code>make_df_colnames_unique_inplace</code><code>(</code><code>thedf</code><code>)</code> \u2014 Make the columns of a data frame unique&lt;/&gt;</li> <li><code>mark</code><code>(</code><code>**kwargs</code><code>)</code> (Callable) \u2014 Mark a class (e.g. Proc) with given kwargs as metadata&lt;/&gt;</li> <li><code>path_is_symlink</code><code>(</code><code>path</code><code>)</code> (bool) \u2014 Check if a path is a symlink.&lt;/&gt;</li> <li><code>path_symlink_to</code><code>(</code><code>src</code>, <code>dst</code>, <code>target_is_directory</code><code>)</code> \u2014 Create a symbolic link pointing to src named dst.&lt;/&gt;</li> <li><code>pipen_banner</code><code>(</code><code>)</code> (RenderableType) \u2014 The banner for pipen&lt;/&gt;</li> <li><code>strsplit</code><code>(</code><code>string</code>, <code>sep</code>, <code>maxsplit</code>, <code>trim</code><code>)</code> (List) \u2014 Split the string, with the ability to trim each part.&lt;/&gt;</li> <li><code>truncate_text</code><code>(</code><code>text</code>, <code>width</code>, <code>end</code><code>)</code> (str) \u2014 Truncate a text not based on words/whitespacesOtherwise, we could use textwrap.shorten. &lt;/&gt;</li> <li><code>update_dict</code><code>(</code><code>parent</code>, <code>new</code>, <code>depth</code>, <code>try_list</code><code>)</code> (Mapping) \u2014 Update the new dict to the parent, but make sure parent does not change&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provides the process class: Proc</p> Classes <ul> <li><code>ProcMeta</code> \u2014 Meta class for Proc&lt;/&gt;</li> <li><code>Proc</code> (Proc) \u2014 The abstract class for processes.&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide version of pipen</p> module &lt;/&gt; <p>Provide the Job class</p> Classes <ul> <li><code>Job</code> \u2014 The job for pipen&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide builting schedulers</p> Classes <ul> <li><code>SchedulerPostInit</code> \u2014 Provides post init function for all schedulers&lt;/&gt;</li> <li><code>LocalScheduler</code> \u2014 Local scheduler&lt;/&gt;</li> <li><code>SgeScheduler</code> \u2014 SGE scheduler&lt;/&gt;</li> <li><code>SlurmScheduler</code> \u2014 Slurm scheduler&lt;/&gt;</li> <li><code>SshScheduler</code> \u2014 SSH scheduler&lt;/&gt;</li> <li><code>GbatchScheduler</code> \u2014 Google Cloud Batch scheduler&lt;/&gt;</li> <li><code>ContainerScheduler</code> \u2014 Scheduler to run jobs via containers (Docker/Podman/Apptainer)&lt;/&gt;</li> </ul> Functions <ul> <li><code>get_scheduler</code><code>(</code><code>scheduler</code><code>)</code> (Type) \u2014 Get the scheduler by name of the scheduler class itself&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide exception classes</p> Classes <ul> <li><code>PipenException</code> \u2014 Base exception class for pipen&lt;/&gt;</li> <li><code>PipenSetDataError</code> \u2014 When trying to set input data to processes with input_data already setusing Pipen.set_data(). &lt;/&gt;</li> <li><code>ProcInputTypeError</code> \u2014 When an unsupported input type is provided&lt;/&gt;</li> <li><code>ProcInputKeyError</code> \u2014 When an unsupported input key is provided&lt;/&gt;</li> <li><code>ProcInputValueError</code> \u2014 When an unsupported input value is provided&lt;/&gt;</li> <li><code>ProcScriptFileNotFound</code> \u2014 When script file specified as 'file://' cannot be found&lt;/&gt;</li> <li><code>ProcOutputNameError</code> \u2014 When no name or malformatted output is provided&lt;/&gt;</li> <li><code>ProcOutputTypeError</code> \u2014 When an unsupported output type is provided&lt;/&gt;</li> <li><code>ProcOutputValueError</code> \u2014 When a malformatted output value is provided&lt;/&gt;</li> <li><code>ProcDependencyError</code> \u2014 When there is something wrong the process dependencies&lt;/&gt;</li> <li><code>NoSuchSchedulerError</code> \u2014 When specified scheduler cannot be found&lt;/&gt;</li> <li><code>WrongSchedulerTypeError</code> \u2014 When specified scheduler is not a subclass of Scheduler&lt;/&gt;</li> <li><code>NoSuchTemplateEngineError</code> \u2014 When specified template engine cannot be found&lt;/&gt;</li> <li><code>WrongTemplateEnginTypeError</code> \u2014 When specified tempalte engine is not a subclass of Scheduler&lt;/&gt;</li> <li><code>TemplateRenderingError</code> \u2014 Failed to render a template&lt;/&gt;</li> <li><code>ConfigurationError</code> \u2014 When something wrong set as configuration&lt;/&gt;</li> <li><code>PipenOrProcNameError</code> \u2014 \"When more than one processes are sharing the same workdir&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Main entry module, provide the Pipen class</p> Classes <ul> <li><code>Pipen</code> \u2014 The Pipen class provides interface to assemble and run the pipeline&lt;/&gt;</li> </ul> Functions <ul> <li><code>run</code><code>(</code><code>name</code>, <code>starts</code>, <code>data</code>, <code>desc</code>, <code>outdir</code>, <code>profile</code>, <code>**kwargs</code><code>)</code> (bool) \u2014 Shortcut to run a pipeline&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide some function for creating and modifying channels (dataframes)</p> Classes <ul> <li><code>Channel</code> \u2014 A DataFrame wrapper with creators&lt;/&gt;</li> </ul> Functions <ul> <li><code>collapse_files</code><code>(</code><code>data</code>, <code>col</code><code>)</code> (DataFrame) \u2014 Collapse a Channel according to the files in ,other cols will use the values in row 0. &lt;/&gt;</li> <li><code>expand_dir</code><code>(</code><code>data</code>, <code>col</code>, <code>pattern</code>, <code>ftype</code>, <code>sortby</code>, <code>reverse</code><code>)</code> (DataFrame) \u2014 Expand a Channel according to the files in ,other cols will keep the same. &lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide the PipelinePBar and ProcPBar classes</p> Classes <ul> <li><code>ProcPBar</code> \u2014 The progress bar for processes&lt;/&gt;</li> <li><code>PipelinePBar</code> \u2014 Progress bar for the pipeline&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Template adaptor for pipen</p> Classes <ul> <li><code>Template</code><code>(</code><code>source</code>, <code>**kwargs</code><code>)</code> \u2014 Base class wrapper to wrap template for pipen&lt;/&gt;</li> <li><code>TemplateLiquid</code> \u2014 Liquidpy template wrapper.&lt;/&gt;</li> <li><code>TemplateJinja2</code> \u2014 Jinja2 template wrapper&lt;/&gt;</li> </ul> Functions <ul> <li><code>get_template_engine</code><code>(</code><code>template</code><code>)</code> (Type) \u2014 Get the template engine by name or the template engine itself&lt;/&gt;</li> </ul> module &lt;/&gt; <p>Process group that contains a set of processes.</p><p>It can be easily used to create a pipeline that runs independently or integrated into a larger pipeline.</p> <p>Runs directly: <pre><code>&gt;&gt;&gt; proc_group = ProcGroup(&lt;options&gt;)\n&gt;&gt;&gt; proc_group.as_pipen(&lt;pipeline options&gt;).set_data(&lt;data&gt;).run()\n</code></pre></p> <p>Integrated into a larger pipeline <pre><code>&gt;&gt;&gt; proc_group = ProcGroup(&lt;options&gt;)\n&gt;&gt;&gt; # proc could be a process within the larger pipeline\n&gt;&gt;&gt; proc.requires = prog_group.&lt;proc&gt;\n</code></pre></p> <p>To add a process to the proc group, use the <code>add_proc</code> method: <pre><code>&gt;&gt;&gt; class MyProcGroup(ProcGroup):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt;\n&gt;&gt;&gt; proc_group = MyProcGroup(...)\n&gt;&gt;&gt; @proc_group.add_proc\n&gt;&gt;&gt; class MyProc(Proc):\n&gt;&gt;&gt;     ...\n</code></pre></p> <p>Or add a process at runtime: <pre><code>&gt;&gt;&gt; class MyProcGroup(ProcGroup):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt;\n&gt;&gt;&gt;     @ProcGroup.add_proc\n&gt;&gt;&gt;     def my_proc(self):\n&gt;&gt;&gt;         class MyProc(Proc):\n&gt;&gt;&gt;             # You may use self.options here\n&gt;&gt;&gt;             ...\n&gt;&gt;&gt;         return MyProc\n&gt;&gt;&gt; proc_group = MyProcGroup(...)\n</code></pre></p> Classes <ul> <li><code>ProcGropuMeta</code> \u2014 Meta class for ProcGroup&lt;/&gt;</li> <li><code>ProcGroup</code> \u2014 A group of processes that can be run independently orintegrated into a larger pipeline. &lt;/&gt;</li> </ul> module &lt;/&gt; <p>Provide some default values/objects</p> Classes <ul> <li><code>ProcInputType</code> \u2014 Types for process inputs&lt;/&gt;</li> <li><code>ProcOutputType</code> \u2014 Types for process outputs&lt;/&gt;</li> </ul> package &lt;/&gt; <p>Provide CLI for pipen</p>"},{"location":"api/pipen/#pipen","title":"pipen","text":""},{"location":"api/pipen/#pipenpluginmgr","title":"pipen.pluginmgr","text":""},{"location":"api/pipen/#pipenutils","title":"pipen.utils","text":""},{"location":"api/pipen/#pipenproc","title":"pipen.proc","text":""},{"location":"api/pipen/#pipenversion","title":"pipen.version","text":""},{"location":"api/pipen/#pipenjob","title":"pipen.job","text":""},{"location":"api/pipen/#pipenscheduler","title":"pipen.scheduler","text":""},{"location":"api/pipen/#pipenexceptions","title":"pipen.exceptions","text":""},{"location":"api/pipen/#pipenpipen","title":"pipen.pipen","text":""},{"location":"api/pipen/#pipenchannel","title":"pipen.channel","text":""},{"location":"api/pipen/#pipenprogressbar","title":"pipen.progressbar","text":""},{"location":"api/pipen/#pipentemplate","title":"pipen.template","text":""},{"location":"api/pipen/#pipenprocgroup","title":"pipen.procgroup","text":""},{"location":"api/pipen/#pipendefaults","title":"pipen.defaults","text":""},{"location":"api/pipen/#pipencli","title":"pipen.cli","text":""},{"location":"api/pipen.pipen/","title":"pipen.pipen","text":"module &lt;/&gt; <p>Main entry module, provide the Pipen class</p> Classes <ul> <li><code>Pipen</code> \u2014 The Pipen class provides interface to assemble and run the pipeline&lt;/&gt;</li> </ul> Functions <ul> <li><code>run</code><code>(</code><code>name</code>, <code>starts</code>, <code>data</code>, <code>desc</code>, <code>outdir</code>, <code>profile</code>, <code>**kwargs</code><code>)</code> (bool) \u2014 Shortcut to run a pipeline&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The Pipen class provides interface to assemble and run the pipeline</p> Attributes <ul> <li><code>PIPELINE_COUNT</code> \u2014 How many pipelines are loaded</li> <li><code>SETUP</code> \u2014 Whether the one-time setup hook is called</li> <li><code>_kwargs</code> \u2014 The extra configrations passed to overwrite the default ones</li> <li><code>config</code> \u2014 The configurations</li> <li><code>desc</code> \u2014 The description of the pipeline</li> <li><code>name</code> \u2014 The name of the pipeline</li> <li><code>outdir</code> \u2014 The output directory of the results</li> <li><code>pbar</code> \u2014 The progress bar</li> <li><code>procs</code> \u2014 The processes</li> <li><code>profile</code> \u2014 The profile of the configurations to run the pipeline</li> <li><code>starts</code> \u2014 The start processes</li> <li><code>workdir</code> \u2014 The workdir for the pipeline</li> </ul> Parameters <ul> <li><code>name</code> (str | none, optional) \u2014 The name of the pipeline</li> <li><code>desc</code> (str | none, optional) \u2014 The description of the pipeline</li> <li><code>outdir</code> (str | os.pathlike, optional) \u2014 The output directory of the results</li> <li><code>**kwargs</code> \u2014 Other configurations</li> </ul> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 This method is called when a class is subclassed.&lt;/&gt;</li> <li><code>async_run</code><code>(</code><code>profile</code><code>)</code> (bool) \u2014 Run the processes one by one&lt;/&gt;</li> <li><code>build_proc_relationships</code><code>(</code><code>)</code> \u2014 Build the proc relationships for the pipeline&lt;/&gt;</li> <li><code>run</code><code>(</code><code>profile</code><code>)</code> (bool) \u2014 Run the pipeline with the given profileThis is just a sync wrapper for the async <code>async_run</code> function using <code>asyncio.run()</code> &lt;/&gt;</li> <li><code>set_data</code><code>(</code><code>*indata</code><code>)</code> (Pipen) \u2014 Set the input_data for start processes&lt;/&gt;</li> <li><code>set_starts</code><code>(</code><code>*procs</code>, <code>clear</code><code>)</code> \u2014 Set the starts&lt;/&gt;</li> </ul> classmethod &lt;/&gt; <p>This method is called when a class is subclassed.</p><p>The default implementation does nothing. It may be overridden to extend subclasses.</p> method &lt;/&gt; <p>Run the processes one by one</p> Parameters <ul> <li><code>profile</code> (str, optional) \u2014 The default profile to use for the run</li> </ul> Returns (bool) <p>True if the pipeline ends successfully else False</p> method &lt;/&gt; <p>Run the pipeline with the given profileThis is just a sync wrapper for the async <code>async_run</code> function using <code>asyncio.run()</code></p> Parameters <ul> <li><code>profile</code> (str, optional) \u2014 The default profile to use for the run</li> </ul> Returns (bool) <p>True if the pipeline ends successfully else False</p> method &lt;/&gt; <p>Set the input_data for start processes</p> Parameters <ul> <li><code>*indata</code> (Any) \u2014 The input data for the start processesThe data will set for the processes in the order determined by <code>set_starts()</code>. If a process has input_data set, an error will be raised. To use that input_data, set None here in the corresponding position for the process </li> </ul> Raises <ul> <li><code>ProcInputDataError</code> \u2014 When trying to set input data toprocesses with input_data already set </li> </ul> Returns (Pipen) <p><code>self</code> to chain the operations</p> method &lt;/&gt; <p>Set the starts</p> Parameters <ul> <li><code>*procs</code> (Union) \u2014 The processes to set as starts of the pipeline.</li> <li><code>clear</code> (bool, optional) \u2014 Wether to clear previous set starts</li> </ul> Raises <ul> <li><code>ProcDependencyError</code> \u2014 When processes set as starts repeatedly</li> </ul> Returns <p><code>self</code> to chain the operations</p> method &lt;/&gt; <p>Build the proc relationships for the pipeline</p> function &lt;/&gt; <p>Shortcut to run a pipeline</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name of the pipeline</li> <li><code>starts</code> (Union) \u2014 The start processes</li> <li><code>data</code> (Iterable, optional) \u2014 The input data for the start processes</li> <li><code>desc</code> (str, optional) \u2014 The description of the pipeline</li> <li><code>outdir</code> (PathType | None, optional) \u2014 The output directory of the results</li> <li><code>profile</code> (str, optional) \u2014 The profile to use</li> <li><code>**kwargs</code> \u2014 Other options pass to Pipen to create the pipeline</li> </ul> Returns (bool) <p>True if the pipeline ends successfully else False</p>"},{"location":"api/pipen.pipen/#pipenpipen","title":"pipen.pipen","text":""},{"location":"api/pipen.pipen/#pipenpipenpipen","title":"<code>pipen.pipen.</code><code>Pipen</code><code>(</code><code>name=None</code>, <code>desc=None</code>, <code>outdir=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.pipen/#pipenpipenpipeninit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.pipen/#pipenpipenpipenasync_run","title":"<code>async_run</code><code>(</code><code>profile='default'</code><code>)</code>","text":""},{"location":"api/pipen.pipen/#pipenpipenpipenrun","title":"<code>run</code><code>(</code><code>profile='default'</code><code>)</code>","text":""},{"location":"api/pipen.pipen/#pipenpipenpipenset_data","title":"<code>set_data</code><code>(</code><code>*indata</code><code>)</code>","text":""},{"location":"api/pipen.pipen/#pipenpipenpipenset_starts","title":"<code>set_starts</code><code>(</code><code>*procs</code>, <code>clear=True</code><code>)</code>","text":""},{"location":"api/pipen.pipen/#pipenpipenpipenbuild_proc_relationships","title":"<code>build_proc_relationships</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.pipen/#pipenpipenrun","title":"<code>pipen.pipen.</code><code>run</code><code>(</code><code>name</code>, <code>starts</code>, <code>data=None</code>, <code>desc=None</code>, <code>outdir=None</code>, <code>profile='default'</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/","title":"pipen.pluginmgr","text":"module &lt;/&gt; <p>Define hooks specifications and provide plugin manager</p> Classes <ul> <li><code>PipenMainPlugin</code> \u2014 The builtin core plugin, used to update the progress bar andcache the job &lt;/&gt;</li> <li><code>XqutePipenPlugin</code> \u2014 The plugin for xqute working as proxy for pipen plugin hooks&lt;/&gt;</li> </ul> Functions <ul> <li><code>on_complete</code><code>(</code><code>pipen</code>, <code>succeeded</code><code>)</code> \u2014 The the pipeline is completed.&lt;/&gt;</li> <li><code>on_init</code><code>(</code><code>pipen</code><code>)</code> \u2014 When the pipeline is initialized, and default configs are loaded&lt;/&gt;</li> <li><code>on_job_cached</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is cached.&lt;/&gt;</li> <li><code>on_job_failed</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is done but failed.&lt;/&gt;</li> <li><code>on_job_init</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is initialized&lt;/&gt;</li> <li><code>on_job_killed</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is killed&lt;/&gt;</li> <li><code>on_job_killing</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 When a job is being killed.&lt;/&gt;</li> <li><code>on_job_polling</code><code>(</code><code>job</code>, <code>counter</code><code>)</code> \u2014 When status of a job is being polled.&lt;/&gt;</li> <li><code>on_job_queued</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is queued in xqute. Note it might not be queued yet inthe scheduler system. &lt;/&gt;</li> <li><code>on_job_started</code><code>(</code><code>job</code><code>)</code> \u2014 When a job starts to run in then scheduler system.&lt;/&gt;</li> <li><code>on_job_submitted</code><code>(</code><code>job</code><code>)</code> \u2014 When a job is submitted in the scheduler system.&lt;/&gt;</li> <li><code>on_job_submitting</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 When a job is submitting.&lt;/&gt;</li> <li><code>on_job_succeeded</code><code>(</code><code>job</code><code>)</code> \u2014 When a job completes successfully.&lt;/&gt;</li> <li><code>on_jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 When the job command finishes and after the postscript is run&lt;/&gt;</li> <li><code>on_jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 When the job command wrapper script is initialized before the prescript is run&lt;/&gt;</li> <li><code>on_jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 When the job command right about to be run&lt;/&gt;</li> <li><code>on_proc_create</code><code>(</code><code>proc</code><code>)</code> \u2014 Called Proc constructor when a process is created.&lt;/&gt;</li> <li><code>on_proc_done</code><code>(</code><code>proc</code>, <code>succeeded</code><code>)</code> \u2014 When a process is done&lt;/&gt;</li> <li><code>on_proc_init</code><code>(</code><code>proc</code><code>)</code> \u2014 Called when a process is initialized.&lt;/&gt;</li> <li><code>on_proc_input_computed</code><code>(</code><code>proc</code><code>)</code> \u2014 Called after process input data is computed.&lt;/&gt;</li> <li><code>on_proc_script_computed</code><code>(</code><code>proc</code><code>)</code> \u2014 Called after process script is computed.&lt;/&gt;</li> <li><code>on_proc_shutdown</code><code>(</code><code>proc</code>, <code>sig</code><code>)</code> \u2014 When pipeline is shutting down, by Ctrl-c for example.&lt;/&gt;</li> <li><code>on_proc_start</code><code>(</code><code>proc</code><code>)</code> \u2014 When a process is starting&lt;/&gt;</li> <li><code>on_setup</code><code>(</code><code>pipen</code><code>)</code> \u2014 Setup for plugins, primarily used for the plugins tosetup some default configurations. &lt;/&gt;</li> <li><code>on_start</code><code>(</code><code>pipen</code><code>)</code> \u2014 Right before the pipeline starts running.&lt;/&gt;</li> </ul> function &lt;/&gt; <p>Setup for plugins, primarily used for the plugins tosetup some default configurations.</p> <p>This is only called once for all pipelines.</p> Parameters <ul> <li><code>pipen</code> (Pipen) \u2014 The Pipen object</li> </ul> function &lt;/&gt; <p>When the pipeline is initialized, and default configs are loaded</p> Parameters <ul> <li><code>pipen</code> (Pipen) \u2014 The Pipen object</li> </ul> function &lt;/&gt; <p>Right before the pipeline starts running.</p><p>Process relationships are inferred.</p> Parameters <ul> <li><code>pipen</code> (Pipen) \u2014 The Pipen object</li> </ul> function &lt;/&gt; <p>The the pipeline is completed.</p> Parameters <ul> <li><code>pipen</code> (Pipen) \u2014 The Pipen object</li> <li><code>succeeded</code> (bool) \u2014 Whether the pipeline has successfully completed.</li> </ul> function &lt;/&gt; <p>Called Proc constructor when a process is created.</p><p>Enables plugins to modify the default attributes of processes</p> Parameters <ul> <li><code>proc</code> (Proc) \u2014 The Proc object</li> </ul> function &lt;/&gt; <p>Called when a process is initialized.</p><p>Allows plugins to modify the process attributes after initialization, but before the jobs are initialized.</p> Parameters <ul> <li><code>proc</code> (Proc) \u2014 The Proc object</li> </ul> function &lt;/&gt; <p>Called after process input data is computed.</p> Parameters <ul> <li><code>proc</code> (Proc) \u2014 The Proc object</li> </ul> function &lt;/&gt; <p>Called after process script is computed.</p><p>The script is computed as a string that is about to compiled into a template.</p> Parameters <ul> <li><code>proc</code> (Proc) \u2014 The Proc object</li> </ul> function &lt;/&gt; <p>When a process is starting</p> Parameters <ul> <li><code>proc</code> (Proc) \u2014 The process</li> </ul> function &lt;/&gt; <p>When pipeline is shutting down, by Ctrl-c for example.</p><p>Return False to stop shutting down, but you have to shut it down by yourself, for example, <code>proc.xqute.task.cancel()</code></p> <p>Only the first return value will be used.</p> Parameters <ul> <li><code>sig</code> (signal.Signals) \u2014 The signal. <code>None</code> means a natural shutdown</li> <li><code>pipen</code> \u2014 The xqute object</li> </ul> function &lt;/&gt; <p>When a process is done</p> Parameters <ul> <li><code>proc</code> (Proc) \u2014 The process</li> <li><code>succeeded</code> (bool | str) \u2014 Whether the process succeeded or not. 'cached' if all jobsare cached. </li> </ul> function &lt;/&gt; <p>When a job is initialized</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When a job is queued in xqute. Note it might not be queued yet inthe scheduler system.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When a job is submitting.</p><p>The first plugin (based on priority) have this hook return False will cancel the submission</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>False to cancel submission</p> function &lt;/&gt; <p>When a job is submitted in the scheduler system.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When a job starts to run in then scheduler system.</p><p>Note that the job might not be running yet in the scheduler system.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When status of a job is being polled.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When a job is being killed.</p><p>The first plugin (based on priority) have this hook return False will cancel the killing</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>False to cancel killing</p> function &lt;/&gt; <p>When a job is killed</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When a job completes successfully.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When a job is cached.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When a job is done but failed.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> function &lt;/&gt; <p>When the job command wrapper script is initialized before the prescript is run</p><p>This should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance.</p> <p>For multiple plugins, the code will be inserted in the order of the plugin priority.</p> <p>The code will replace the <code>#![jobcmd_init]</code> placeholder in the wrapped job script. See also https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p> function &lt;/&gt; <p>When the job command right about to be run</p><p>This should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance.</p> <p>The bash variable <code>$cmd</code> is accessible in the context. It is also possible to modify the <code>cmd</code> variable. Just remember to assign the modified value to <code>cmd</code>.</p> <p>For multiple plugins, the code will be inserted in the order of the plugin priority. Keep in mind that the <code>$cmd</code> may be modified by other plugins.</p> <p>The code will replace the <code>#![jobcmd_prep]</code> placeholder in the wrapped job script. See also https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p> function &lt;/&gt; <p>When the job command finishes and after the postscript is run</p><p>This should return a piece of bash code to be inserted in the wrapped job script (template), which is a python template string, with the following variables available: <code>status</code> and <code>job</code>. <code>status</code> is the class <code>JobStatus</code> from <code>xqute.defaults.py</code> and <code>job</code> is the <code>Job</code> instance.</p> <p>The bash variable <code>$rc</code> is accessible in the context, which is the return code of the job command.</p> <p>For multiple plugins, the code will be inserted in the order of the plugin priority.</p> <p>The code will replace the <code>#![jobcmd_end]</code> placeholder in the wrapped job script. See also https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job object</li> </ul> Returns (str) <p>The bash code to be inserted</p> class &lt;/&gt; <p>The builtin core plugin, used to update the progress bar andcache the job</p> class &lt;/&gt; <p>The plugin for xqute working as proxy for pipen plugin hooks</p>"},{"location":"api/pipen.pluginmgr/#pipenpluginmgr","title":"pipen.pluginmgr","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_setup","title":"<code>pipen.pluginmgr.</code><code>on_setup</code><code>(</code><code>pipen</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_init","title":"<code>pipen.pluginmgr.</code><code>on_init</code><code>(</code><code>pipen</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_start","title":"<code>pipen.pluginmgr.</code><code>on_start</code><code>(</code><code>pipen</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_complete","title":"<code>pipen.pluginmgr.</code><code>on_complete</code><code>(</code><code>pipen</code>, <code>succeeded</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_proc_create","title":"<code>pipen.pluginmgr.</code><code>on_proc_create</code><code>(</code><code>proc</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_proc_init","title":"<code>pipen.pluginmgr.</code><code>on_proc_init</code><code>(</code><code>proc</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_proc_input_computed","title":"<code>pipen.pluginmgr.</code><code>on_proc_input_computed</code><code>(</code><code>proc</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_proc_script_computed","title":"<code>pipen.pluginmgr.</code><code>on_proc_script_computed</code><code>(</code><code>proc</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_proc_start","title":"<code>pipen.pluginmgr.</code><code>on_proc_start</code><code>(</code><code>proc</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_proc_shutdown","title":"<code>pipen.pluginmgr.</code><code>on_proc_shutdown</code><code>(</code><code>proc</code>, <code>sig</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_proc_done","title":"<code>pipen.pluginmgr.</code><code>on_proc_done</code><code>(</code><code>proc</code>, <code>succeeded</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_init","title":"<code>pipen.pluginmgr.</code><code>on_job_init</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_queued","title":"<code>pipen.pluginmgr.</code><code>on_job_queued</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_submitting","title":"<code>pipen.pluginmgr.</code><code>on_job_submitting</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_submitted","title":"<code>pipen.pluginmgr.</code><code>on_job_submitted</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_started","title":"<code>pipen.pluginmgr.</code><code>on_job_started</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_polling","title":"<code>pipen.pluginmgr.</code><code>on_job_polling</code><code>(</code><code>job</code>, <code>counter</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_killing","title":"<code>pipen.pluginmgr.</code><code>on_job_killing</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_killed","title":"<code>pipen.pluginmgr.</code><code>on_job_killed</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_succeeded","title":"<code>pipen.pluginmgr.</code><code>on_job_succeeded</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_cached","title":"<code>pipen.pluginmgr.</code><code>on_job_cached</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_job_failed","title":"<code>pipen.pluginmgr.</code><code>on_job_failed</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_jobcmd_init","title":"<code>pipen.pluginmgr.</code><code>on_jobcmd_init</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_jobcmd_prep","title":"<code>pipen.pluginmgr.</code><code>on_jobcmd_prep</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgron_jobcmd_end","title":"<code>pipen.pluginmgr.</code><code>on_jobcmd_end</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgrpipenmainplugin","title":"<code>pipen.pluginmgr.</code><code>PipenMainPlugin</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.pluginmgr/#pipenpluginmgrxqutepipenplugin","title":"<code>pipen.pluginmgr.</code><code>XqutePipenPlugin</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.proc/","title":"pipen.proc","text":"module &lt;/&gt; <p>Provides the process class: Proc</p> Classes <ul> <li><code>ProcMeta</code> \u2014 Meta class for Proc&lt;/&gt;</li> <li><code>Proc</code> (Proc) \u2014 The abstract class for processes.&lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Meta class for Proc</p> Methods <ul> <li><code>__call__</code><code>(</code><code>cls</code>, <code>*args</code>, <code>**kwds</code><code>)</code> (Proc) \u2014 Make sure Proc subclasses are singletons&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>cls</code><code>)</code> (str) \u2014 Representation for the Proc subclasses&lt;/&gt;</li> </ul> staticmethod &lt;/&gt; <p>Representation for the Proc subclasses</p> staticmethod &lt;/&gt; <p>Make sure Proc subclasses are singletons</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 and</li> <li><code>**kwds</code> (Any) \u2014 Arguments for the constructor</li> </ul> Returns (Proc) <p>The Proc instance</p> class &lt;/&gt; <p>The abstract class for processes.</p><p>It's an abstract class. You can't instantise a process using it directly. You have to subclass it. The subclass itself can be used as a process directly.</p> <p>Each subclass is a singleton, so to intantise a new process, each subclass an existing <code>Proc</code> subclass, or use <code>Proc.from_proc()</code>.</p> <p>Never use the constructor directly. The Proc is designed as a singleton class, and is instansiated internally.</p> Attributes <ul> <li><code>cache</code> \u2014 Should we detect whether the jobs are cached?</li> <li><code>desc</code> \u2014 The description of the process. Will use the summary fromthe docstring by default. </li> <li><code>dirsig</code> \u2014 When checking the signature for caching, whether should we walkthrough the content of the directory? This is sometimes time-consuming if the directory is big. </li> <li><code>envs</code> \u2014 The arguments that are job-independent, useful for common optionsacross jobs. </li> <li><code>envs_depth</code> \u2014 How deep to update the envs when subclassed.</li> <li><code>error_strategy</code> \u2014 How to deal with the errors<ul><li>- retry, ignore, halt</li><li>- halt to halt the whole pipeline, no submitting new jobs</li><li>- terminate to just terminate the job itself</li></ul></li> <li><code>export</code> \u2014 When True, the results will be exported to <code>&lt;pipeline.outdir&gt;</code>Defaults to None, meaning only end processes will export. You can set it to True/False to enable or disable exporting for processes </li> <li><code>forks</code> \u2014 How many jobs to run simultaneously?</li> <li><code>input</code> \u2014 The keys for the input channel</li> <li><code>input_data</code> \u2014 The input data (will be computed for dependent processes)</li> <li><code>lang</code> \u2014 The language for the script to run. Should be the path to theinterpreter if <code>lang</code> is not in <code>$PATH</code>. </li> <li><code>name</code> \u2014 The name of the process. Will use the class name by default.</li> <li><code>nexts</code> \u2014 Computed from <code>requires</code> to build the process relationships</li> <li><code>num_retries</code> \u2014 How many times to retry to jobs once error occurs</li> <li><code>order</code> \u2014 The execution order for this process. The bigger the numberis, the later the process will be executed. Default: 0. Note that the dependent processes will always be executed first. This doesn't work for start processes either, whose orders are determined by <code>Pipen.set_starts()</code> </li> <li><code>output</code> \u2014 The output keys for the output channel(the data will be computed) </li> <li><code>output_data</code> \u2014 The output data (to pass to the next processes)</li> <li><code>plugin_opts</code> \u2014 Options for process-level plugins</li> <li><code>requires</code> \u2014 The dependency processes</li> <li><code>scheduler</code> \u2014 The scheduler to run the jobs</li> <li><code>scheduler_opts</code> \u2014 The options for the scheduler</li> <li><code>script</code> \u2014 The script template for the process</li> <li><code>submission_batch</code> \u2014 How many jobs to be submited simultaneously</li> <li><code>template</code> \u2014 Define the template engine to use.This could be either a template engine or a dict with key <code>engine</code> indicating the template engine and the rest the arguments passed to the constructor of the <code>pipen.template.Template</code> object. The template engine could be either the name of the engine, currently jinja2 and liquidpy are supported, or a subclass of <code>pipen.template.Template</code>. You can subclass <code>pipen.template.Template</code> to use your own template engine. </li> </ul> Classes <ul> <li><code>ProcMeta</code> \u2014 Meta class for Proc&lt;/&gt;</li> </ul> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 Do the requirements inferring since we need them to build up theprocess relationship &lt;/&gt;</li> <li><code>from_proc</code><code>(</code><code>proc</code>, <code>name</code>, <code>desc</code>, <code>envs</code>, <code>envs_depth</code>, <code>cache</code>, <code>export</code>, <code>error_strategy</code>, <code>num_retries</code>, <code>forks</code>, <code>input_data</code>, <code>order</code>, <code>plugin_opts</code>, <code>requires</code>, <code>scheduler</code>, <code>scheduler_opts</code>, <code>submission_batch</code><code>)</code> (Type) \u2014 Create a subclass of Proc using another Proc subclass or Proc itself&lt;/&gt;</li> <li><code>gc</code><code>(</code><code>)</code> \u2014 GC process for the process to save memory after it's done&lt;/&gt;</li> <li><code>init</code><code>(</code><code>)</code> \u2014 Init all other properties and jobs&lt;/&gt;</li> <li><code>log</code><code>(</code><code>level</code>, <code>msg</code>, <code>*args</code>, <code>logger</code><code>)</code> \u2014 Log message for the process&lt;/&gt;</li> <li><code>run</code><code>(</code><code>)</code> \u2014 Run the process&lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Meta class for Proc</p> Methods <ul> <li><code>__call__</code><code>(</code><code>cls</code>, <code>*args</code>, <code>**kwds</code><code>)</code> (Proc) \u2014 Make sure Proc subclasses are singletons&lt;/&gt;</li> <li><code>__repr__</code><code>(</code><code>cls</code><code>)</code> (str) \u2014 Representation for the Proc subclasses&lt;/&gt;</li> </ul> staticmethod <code>__repr__</code><code>(</code><code>cls</code><code>)</code> \u2192 str &lt;/&gt; <p>Representation for the Proc subclasses</p> staticmethod <code>__call__</code><code>(</code><code>cls</code>, <code>*args</code>, <code>**kwds</code><code>)</code> &lt;/&gt; <p>Make sure Proc subclasses are singletons</p> Parameters <ul> <li><code>*args</code> (Any) \u2014 and</li> <li><code>**kwds</code> (Any) \u2014 Arguments for the constructor</li> </ul> Returns (Proc) <p>The Proc instance</p> classmethod &lt;/&gt; <p>Create a subclass of Proc using another Proc subclass or Proc itself</p> Parameters <ul> <li><code>proc</code> (Type) \u2014 The Proc subclass</li> <li><code>name</code> (str, optional) \u2014 The new name of the process</li> <li><code>desc</code> (str, optional) \u2014 The new description of the process</li> <li><code>envs</code> (Mapping, optional) \u2014 The arguments of the process, will overwrite parent oneThe items that are specified will be inherited </li> <li><code>envs_depth</code> (int, optional) \u2014 How deep to update the envs when subclassed.</li> <li><code>cache</code> (bool, optional) \u2014 Whether we should check the cache for the jobs</li> <li><code>export</code> (bool, optional) \u2014 When True, the results will be exported to<code>&lt;pipeline.outdir&gt;</code> Defaults to None, meaning only end processes will export. You can set it to True/False to enable or disable exporting for processes </li> <li><code>error_strategy</code> (str, optional) \u2014 How to deal with the errors<ul><li>- retry, ignore, halt</li><li>- halt to halt the whole pipeline, no submitting new jobs</li><li>- terminate to just terminate the job itself</li></ul></li> <li><code>num_retries</code> (int, optional) \u2014 How many times to retry to jobs once error occurs</li> <li><code>forks</code> (int, optional) \u2014 New forks for the new process</li> <li><code>input_data</code> (Any, optional) \u2014 The input data for the process. Only when this processis a start process </li> <li><code>order</code> (int, optional) \u2014 The order to execute the new process</li> <li><code>plugin_opts</code> (Mapping, optional) \u2014 The new plugin options, unspecified items will beinherited. </li> <li><code>requires</code> (Sequence, optional) \u2014 The required processes for the new process</li> <li><code>scheduler</code> (str, optional) \u2014 The new shedular to run the new process</li> <li><code>scheduler_opts</code> (Mapping, optional) \u2014 The new scheduler options, unspecified items willbe inherited. </li> <li><code>submission_batch</code> (int, optional) \u2014 How many jobs to be submited simultaneously</li> </ul> Returns (Type) <p>The new process class</p> classmethod &lt;/&gt; <p>Do the requirements inferring since we need them to build up theprocess relationship</p> method &lt;/&gt; <p>Init all other properties and jobs</p> method &lt;/&gt; <p>GC process for the process to save memory after it's done</p> method &lt;/&gt; <p>Log message for the process</p> Parameters <ul> <li><code>level</code> (int | str) \u2014 The log level of the record</li> <li><code>msg</code> (str) \u2014 The message to log</li> <li><code>*args</code> \u2014 The arguments to format the message</li> <li><code>logger</code> (LoggerAdapter, optional) \u2014 The logging logger</li> </ul> method &lt;/&gt; <p>Run the process</p>"},{"location":"api/pipen.proc/#pipenproc","title":"pipen.proc","text":""},{"location":"api/pipen.proc/#pipenprocprocmeta","title":"<code>pipen.proc.</code><code>ProcMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>namespace</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.proc/#pipenprocprocmetarepr","title":"<code>__repr__</code><code>(</code><code>cls</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.proc/#pipenprocprocmetacall","title":"<code>__call__</code><code>(</code><code>cls</code>, <code>*args</code>, <code>**kwds</code><code>)</code>","text":""},{"location":"api/pipen.proc/#pipenprocproc","title":"<code>pipen.proc.</code><code>Proc</code><code>(</code><code>*args</code>, <code>**kwds</code><code>)</code> \u2192 Proc","text":""},{"location":"api/pipen.proc/#pipenprocprocmeta_1","title":"<code>pipen.proc.</code><code>ProcMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>namespace</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.proc/#pipenprocprocfrom_proc","title":"<code>from_proc</code><code>(</code><code>proc</code>, <code>name=None</code>, <code>desc=None</code>, <code>envs=None</code>, <code>envs_depth=None</code>, <code>cache=None</code>, <code>export=None</code>, <code>error_strategy=None</code>, <code>num_retries=None</code>, <code>forks=None</code>, <code>input_data=None</code>, <code>order=None</code>, <code>plugin_opts=None</code>, <code>requires=None</code>, <code>scheduler=None</code>, <code>scheduler_opts=None</code>, <code>submission_batch=None</code><code>)</code>","text":""},{"location":"api/pipen.proc/#pipenprocprocinit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.proc/#pipenprocprocinit","title":"<code>init</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.proc/#pipenprocprocgc","title":"<code>gc</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.proc/#pipenprocproclog","title":"<code>log</code><code>(</code><code>level</code>, <code>msg</code>, <code>*args</code>, <code>logger=&lt;LoggerAdapter pipen.core (WARNING)&gt;</code><code>)</code>","text":""},{"location":"api/pipen.proc/#pipenprocprocrun","title":"<code>run</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.procgroup/","title":"pipen.procgroup","text":"module &lt;/&gt; <p>Process group that contains a set of processes.</p><p>It can be easily used to create a pipeline that runs independently or integrated into a larger pipeline.</p> <p>Runs directly: <pre><code>&gt;&gt;&gt; proc_group = ProcGroup(&lt;options&gt;)\n&gt;&gt;&gt; proc_group.as_pipen(&lt;pipeline options&gt;).set_data(&lt;data&gt;).run()\n</code></pre></p> <p>Integrated into a larger pipeline <pre><code>&gt;&gt;&gt; proc_group = ProcGroup(&lt;options&gt;)\n&gt;&gt;&gt; # proc could be a process within the larger pipeline\n&gt;&gt;&gt; proc.requires = prog_group.&lt;proc&gt;\n</code></pre></p> <p>To add a process to the proc group, use the <code>add_proc</code> method: <pre><code>&gt;&gt;&gt; class MyProcGroup(ProcGroup):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt;\n&gt;&gt;&gt; proc_group = MyProcGroup(...)\n&gt;&gt;&gt; @proc_group.add_proc\n&gt;&gt;&gt; class MyProc(Proc):\n&gt;&gt;&gt;     ...\n</code></pre></p> <p>Or add a process at runtime: <pre><code>&gt;&gt;&gt; class MyProcGroup(ProcGroup):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt;\n&gt;&gt;&gt;     @ProcGroup.add_proc\n&gt;&gt;&gt;     def my_proc(self):\n&gt;&gt;&gt;         class MyProc(Proc):\n&gt;&gt;&gt;             # You may use self.options here\n&gt;&gt;&gt;             ...\n&gt;&gt;&gt;         return MyProc\n&gt;&gt;&gt; proc_group = MyProcGroup(...)\n</code></pre></p> Classes <ul> <li><code>ProcGropuMeta</code> \u2014 Meta class for ProcGroup&lt;/&gt;</li> <li><code>ProcGroup</code> \u2014 A group of processes that can be run independently orintegrated into a larger pipeline. &lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Meta class for ProcGroup</p> Methods <ul> <li><code>__call__</code><code>(</code><code>cls</code>, <code>*args</code>, <code>**kwds</code><code>)</code> \u2014 Make sure Proc subclasses are singletons&lt;/&gt;</li> </ul> staticmethod &lt;/&gt; <p>Make sure Proc subclasses are singletons</p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>**kwds</code> \u2014 Arguments for the constructor</li> </ul> Returns <p>The Proc instance</p> class &lt;/&gt; <p>A group of processes that can be run independently orintegrated into a larger pipeline.</p> Classes <ul> <li><code>ProcGropuMeta</code> \u2014 Meta class for ProcGroup&lt;/&gt;</li> </ul> Methods <ul> <li><code>__init_subclass__</code><code>(</code><code>)</code> \u2014 This method is called when a class is subclassed.&lt;/&gt;</li> <li><code>add_proc</code><code>(</code><code>self_or_method</code>, <code>proc</code><code>)</code> (Union) \u2014 Add a process to the proc group&lt;/&gt;</li> <li><code>as_pipen</code><code>(</code><code>name</code>, <code>desc</code>, <code>outdir</code>, <code>**kwargs</code><code>)</code> (Pipen) \u2014 Convert the pipeline to a Pipen instance&lt;/&gt;</li> </ul> class &lt;/&gt; Bases abc.ABCMeta <p>Meta class for ProcGroup</p> Methods <ul> <li><code>__call__</code><code>(</code><code>cls</code>, <code>*args</code>, <code>**kwds</code><code>)</code> \u2014 Make sure Proc subclasses are singletons&lt;/&gt;</li> </ul> staticmethod <code>__call__</code><code>(</code><code>cls</code>, <code>*args</code>, <code>**kwds</code><code>)</code> &lt;/&gt; <p>Make sure Proc subclasses are singletons</p> Parameters <ul> <li><code>*args</code> \u2014 and</li> <li><code>**kwds</code> \u2014 Arguments for the constructor</li> </ul> Returns <p>The Proc instance</p> classmethod &lt;/&gt; <p>This method is called when a class is subclassed.</p><p>The default implementation does nothing. It may be overridden to extend subclasses.</p> staticmethod &lt;/&gt; <p>Add a process to the proc group</p><p>It works either as a decorator to the process directly or as a decorator to a method that returns the process.</p> Parameters <ul> <li><code>self_or_method</code> (Union) \u2014 The proc group instance or a method thatreturns the process </li> <li><code>proc</code> (Optional, optional) \u2014 The process class if <code>self_or_method</code> is the proc group</li> </ul> Returns (Union) <p>The process class if <code>self_or_method</code> is the proc group, ora cached property that returns the process class</p> method &lt;/&gt; <p>Convert the pipeline to a Pipen instance</p> Parameters <ul> <li><code>name</code> (str | none, optional) \u2014 The name of the pipeline</li> <li><code>desc</code> (str | none, optional) \u2014 The description of the pipeline</li> <li><code>outdir</code> (str | os.pathlike | none, optional) \u2014 The output directory of the pipeline</li> <li><code>**kwargs</code> \u2014 The keyword arguments to pass to Pipen</li> </ul> Returns (Pipen) <p>The Pipen instance</p>"},{"location":"api/pipen.procgroup/#pipenprocgroup","title":"pipen.procgroup","text":""},{"location":"api/pipen.procgroup/#pipenprocgroupprocgropumeta","title":"<code>pipen.procgroup.</code><code>ProcGropuMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>namespace</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.procgroup/#pipenprocgroupprocgropumetacall","title":"<code>__call__</code><code>(</code><code>cls</code>, <code>*args</code>, <code>**kwds</code><code>)</code>","text":""},{"location":"api/pipen.procgroup/#pipenprocgroupprocgroup","title":"<code>pipen.procgroup.</code><code>ProcGroup</code><code>(</code><code>*args</code>, <code>**kwds</code><code>)</code>","text":""},{"location":"api/pipen.procgroup/#pipenprocgroupprocgropumeta_1","title":"<code>pipen.procgroup.</code><code>ProcGropuMeta</code><code>(</code><code>name</code>, <code>bases</code>, <code>namespace</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.procgroup/#pipenprocgroupprocgroupinit_subclass","title":"<code>__init_subclass__</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.procgroup/#pipenprocgroupprocgroupadd_proc","title":"<code>add_proc</code><code>(</code><code>self_or_method</code>, <code>proc=None</code><code>)</code>","text":""},{"location":"api/pipen.procgroup/#pipenprocgroupprocgroupas_pipen","title":"<code>as_pipen</code><code>(</code><code>name=None</code>, <code>desc=None</code>, <code>outdir=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/","title":"pipen.progressbar","text":"module &lt;/&gt; <p>Provide the PipelinePBar and ProcPBar classes</p> Classes <ul> <li><code>ProcPBar</code> \u2014 The progress bar for processes&lt;/&gt;</li> <li><code>PipelinePBar</code> \u2014 Progress bar for the pipeline&lt;/&gt;</li> </ul> class &lt;/&gt; <p>The progress bar for processes</p> Methods <ul> <li><code>done</code><code>(</code><code>)</code> \u2014 The process is done&lt;/&gt;</li> <li><code>update_job_failed</code><code>(</code><code>)</code> \u2014 Update the progress bar when a job is failed&lt;/&gt;</li> <li><code>update_job_retrying</code><code>(</code><code>)</code> \u2014 Update the progress bar when a job is retrying&lt;/&gt;</li> <li><code>update_job_running</code><code>(</code><code>)</code> \u2014 Update the progress bar when a job is running&lt;/&gt;</li> <li><code>update_job_submitted</code><code>(</code><code>)</code> \u2014 Update the progress bar when a job is submitted&lt;/&gt;</li> <li><code>update_job_succeeded</code><code>(</code><code>)</code> \u2014 Update the progress bar when a job is succeeded&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Update the progress bar when a job is submitted</p> method &lt;/&gt; <p>Update the progress bar when a job is retrying</p> method &lt;/&gt; <p>Update the progress bar when a job is running</p> method &lt;/&gt; <p>Update the progress bar when a job is succeeded</p> method &lt;/&gt; <p>Update the progress bar when a job is failed</p> method &lt;/&gt; <p>The process is done</p> class &lt;/&gt; <p>Progress bar for the pipeline</p> Methods <ul> <li><code>done</code><code>(</code><code>)</code> \u2014 When the pipeline is done&lt;/&gt;</li> <li><code>proc_bar</code><code>(</code><code>proc_size</code>, <code>proc_name</code><code>)</code> (ProcPBar) \u2014 Get the progress bar for a process&lt;/&gt;</li> <li><code>update_proc_done</code><code>(</code><code>)</code> \u2014 Update the progress bar when a process is done&lt;/&gt;</li> <li><code>update_proc_error</code><code>(</code><code>)</code> \u2014 Update the progress bar when a process is errored&lt;/&gt;</li> <li><code>update_proc_running</code><code>(</code><code>)</code> \u2014 Update the progress bar when a process is running&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Get the progress bar for a process</p> Parameters <ul> <li><code>proc_size</code> (int) \u2014 The size of the process</li> <li><code>proc_name</code> (str) \u2014 The name of the process</li> </ul> Returns (ProcPBar) <p>The progress bar for the given process</p> method &lt;/&gt; <p>Update the progress bar when a process is running</p> method &lt;/&gt; <p>Update the progress bar when a process is done</p> method &lt;/&gt; <p>Update the progress bar when a process is errored</p> method &lt;/&gt; <p>When the pipeline is done</p>"},{"location":"api/pipen.progressbar/#pipenprogressbar","title":"pipen.progressbar","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarprocpbar","title":"<code>pipen.progressbar.</code><code>ProcPBar</code><code>(</code><code>manager</code>, <code>proc_size</code>, <code>proc_name</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarprocpbarupdate_job_submitted","title":"<code>update_job_submitted</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarprocpbarupdate_job_retrying","title":"<code>update_job_retrying</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarprocpbarupdate_job_running","title":"<code>update_job_running</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarprocpbarupdate_job_succeeded","title":"<code>update_job_succeeded</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarprocpbarupdate_job_failed","title":"<code>update_job_failed</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarprocpbardone","title":"<code>done</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarpipelinepbar","title":"<code>pipen.progressbar.</code><code>PipelinePBar</code><code>(</code><code>n_procs</code>, <code>ppln_name</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarpipelinepbarproc_bar","title":"<code>proc_bar</code><code>(</code><code>proc_size</code>, <code>proc_name</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarpipelinepbarupdate_proc_running","title":"<code>update_proc_running</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarpipelinepbarupdate_proc_done","title":"<code>update_proc_done</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarpipelinepbarupdate_proc_error","title":"<code>update_proc_error</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.progressbar/#pipenprogressbarpipelinepbardone","title":"<code>done</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/","title":"pipen.scheduler","text":"module &lt;/&gt; <p>Provide builting schedulers</p> Classes <ul> <li><code>SchedulerPostInit</code> \u2014 Provides post init function for all schedulers&lt;/&gt;</li> <li><code>LocalScheduler</code> \u2014 Local scheduler&lt;/&gt;</li> <li><code>SgeScheduler</code> \u2014 SGE scheduler&lt;/&gt;</li> <li><code>SlurmScheduler</code> \u2014 Slurm scheduler&lt;/&gt;</li> <li><code>SshScheduler</code> \u2014 SSH scheduler&lt;/&gt;</li> <li><code>GbatchScheduler</code> \u2014 Google Cloud Batch scheduler&lt;/&gt;</li> <li><code>ContainerScheduler</code> \u2014 Scheduler to run jobs via containers (Docker/Podman/Apptainer)&lt;/&gt;</li> </ul> Functions <ul> <li><code>get_scheduler</code><code>(</code><code>scheduler</code><code>)</code> (Type) \u2014 Get the scheduler by name of the scheduler class itself&lt;/&gt;</li> </ul> class &lt;/&gt; <p>Provides post init function for all schedulers</p> class &lt;/&gt; Bases pipen.scheduler.SchedulerPostInit xqute.schedulers.local_scheduler.LocalScheduler xqute.scheduler.Scheduler <p>Local scheduler</p> Parameters <ul> <li><code>workdir</code> (str | Path | CloudPath) \u2014 The working directory</li> <li><code>forks</code> (int, optional) \u2014 Max number of job forks</li> <li><code>error_strategy</code> (str, optional) \u2014 The strategy when there is error happened</li> <li><code>num_retries</code> (int, optional) \u2014 Max number of retries when error_strategy is retry</li> <li><code>prescript</code> (str, optional) \u2014 The prescript to run before the job commandIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>postscript</code> (str, optional) \u2014 The postscript to run when job finishedIt is a piece of script that inserted into the wrapper script, running on the scheduler system. </li> <li><code>jobname_prefix</code> (str | none, optional) \u2014 The prefix for the job name</li> <li><code>recheck_interval</code> (int, optional) \u2014 The interval to recheck the job status.Default is every 600 polls (each takes about 0.1 seconds). </li> <li><code>cwd</code> (str | Path, optional) \u2014 The working directory for the job command wrapper</li> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job asynchronously&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code>, <code>_mounted</code><code>)</code> (int) \u2014 Submit a job locally&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>Submit a job locally</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> <li><code>_mounted</code> (bool, optional) \u2014 Whether to use the mounted path of the wrapped job scriptUsed internally for container scheduler </li> </ul> Returns (int) <p>The process id</p> method &lt;/&gt; <p>Kill a job asynchronously</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p> class &lt;/&gt; Bases pipen.scheduler.SchedulerPostInit xqute.schedulers.sge_scheduler.SgeScheduler xqute.scheduler.Scheduler <p>SGE scheduler</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on SGE&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to SGE&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job to SGE</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on SGE</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p> class &lt;/&gt; Bases pipen.scheduler.SchedulerPostInit xqute.schedulers.slurm_scheduler.SlurmScheduler xqute.scheduler.Scheduler <p>Slurm scheduler</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on Slurm&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to Slurm&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job to Slurm</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on Slurm</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> \u2014 The job to check</li> </ul> Returns <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p> class &lt;/&gt; Bases pipen.scheduler.SchedulerPostInit xqute.schedulers.ssh_scheduler.scheduler.SshScheduler xqute.scheduler.Scheduler <p>SSH scheduler</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Other arguments for the scheduler</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job on SSH&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job to SSH&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command init</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>Submit a job to SSH</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The job id</p> method &lt;/&gt; <p>Kill a job on SSH</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p> class &lt;/&gt; Bases pipen.scheduler.SchedulerPostInit xqute.schedulers.gbatch_scheduler.GbatchScheduler xqute.scheduler.Scheduler <p>Google Cloud Batch scheduler</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Keyword arguments for the configuration of a job (e.g. taskGroups).See more details at https://cloud.google.com/batch/docs/get-started. </li> <li><code>*args</code> \u2014 Positional arguments for the base class</li> <li><code>project</code> (str) \u2014 Google Cloud project ID</li> <li><code>location</code> (str) \u2014 Google Cloud region or zone</li> <li><code>mount</code> (str | Sequence[str] | None, optional) \u2014 GCS path to mount (e.g. gs://my-bucket:/mnt/my-bucket)You can pass a list of mounts. </li> <li><code>service_account</code> (str | none, optional) \u2014 GCP service account email (e.g. test-account@example.com)</li> <li><code>network</code> (str | none, optional) \u2014 GCP network (e.g. default-network)</li> <li><code>subnetwork</code> (str | none, optional) \u2014 GCP subnetwork (e.g. regions/us-central1/subnetworks/default)</li> <li><code>no_external_ip_address</code> (bool | none, optional) \u2014 Whether to disable external IP address</li> <li><code>machine_type</code> (str | none, optional) \u2014 GCP machine type (e.g. e2-standard-4)</li> <li><code>provisioning_model</code> (str | none, optional) \u2014 GCP provisioning model (e.g. SPOT)</li> <li><code>image_uri</code> (str | none, optional) \u2014 Container image URI (e.g. ubuntu-2004-lts)</li> <li><code>entrypoint</code> (str, optional) \u2014 Container entrypoint (e.g. /bin/bash)</li> <li><code>commands</code> (str | Sequence[str] | None, optional) \u2014 The command list to run in the container.There are three ways to specify the commands: 1. If no entrypoint is specified, the final command will be [commands, wrapped_script], where the entrypoint is the wrapper script interpreter that is determined by <code>JOBCMD_WRAPPER_LANG</code> (e.g. /bin/bash), commands is the list you provided, and wrapped_script is the path to the wrapped job script. 2. You can specify something like \"-c\", then the final command will be [\"-c\", \"wrapper_script_interpreter, wrapper_script\"] 3. You can use the placeholders <code>{lang}</code> and <code>{script}</code> in the commands list, where <code>{lang}</code> will be replaced with the interpreter (e.g. /bin/bash) and <code>{script}</code> will be replaced with the path to the wrapped job script. For example, you can specify [\"{lang} {script}\"] and the final command will be [\"wrapper_interpreter, wrapper_script\"] </li> <li><code>runnables</code> (Sequence[dict] | None, optional) \u2014 Additional runnables to run before or after the main job.Each runnable should be a dictionary that follows the GCP Batch API specification. You can also specify an \"order\" key in the dictionary to control the execution order of the runnables. Runnables with negative order will be executed before the main job, and those with non-negative order will be executed after the main job. The main job runnable will always be executed in the order it is defined in the list. </li> </ul> Attributes <ul> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is really running&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Submit a job&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>Submit a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The unique id in the scheduler system</p> method &lt;/&gt; <p>Kill a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>Check if a job is really running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>The job command init</p> class &lt;/&gt; Bases pipen.scheduler.SchedulerPostInit xqute.schedulers.container_scheduler.ContainerScheduler xqute.schedulers.local_scheduler.LocalScheduler xqute.scheduler.Scheduler <p>Scheduler to run jobs via containers (Docker/Podman/Apptainer)</p> Parameters <ul> <li><code>**kwargs</code> \u2014 Additional arguments passed to parent Scheduler</li> <li><code>image</code> (str) \u2014 Container image to use for running jobs</li> <li><code>entrypoint</code> (str | List[str], optional) \u2014 Entrypoint command for the container</li> <li><code>bin</code> (str, optional) \u2014 Path to container runtime binary (e.g. /path/to/docker)</li> <li><code>volumes</code> (str | Sequence[str] | None, optional) \u2014 host:container volume mapping string or stringsor named volume mapping like <code>MOUNTED=/path/on/host</code> then it will be mounted to <code>/mnt/disks/MOUNTED</code> in the container. You can use environment variable <code>MOUNTED</code> in your job scripts to refer to the mounted path. </li> <li><code>remove</code> (bool, optional) \u2014 Whether to remove the container after execution.Only applies to Docker/Podman. </li> <li><code>user</code> (str | none, optional) \u2014 User to run the container as (only for Docker/Podman)By default, it runs as the current user (os.getuid() and os.getgid()) </li> <li><code>bin_args</code> (List[str] | None, optional) \u2014 Additional arguments to pass to the container runtime</li> </ul> Attributes <ul> <li><code>job_class</code> \u2014 The job class</li> <li><code>jobcmd_wrapper_init</code> \u2014 The init script for the job command wrapper</li> <li><code>jobcmd_wrapper_init</code> (str) \u2014 The init script for the job command wrapper&lt;/&gt;</li> <li><code>name</code> \u2014 The name of the scheduler</li> </ul> Methods <ul> <li><code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs</code><code>)</code> (Job) \u2014 Create a job&lt;/&gt;</li> <li><code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job fails before running.&lt;/&gt;</li> <li><code>job_is_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Tell if a job is really running, not only the job.jid_file&lt;/&gt;</li> <li><code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code> (bool) \u2014 Check if a job is already submitted or running&lt;/&gt;</li> <li><code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command end&lt;/&gt;</li> <li><code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command init&lt;/&gt;</li> <li><code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The job command preparation&lt;/&gt;</li> <li><code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> (str) \u2014 The shebang of the wrapper script&lt;/&gt;</li> <li><code>kill_job</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job asynchronously&lt;/&gt;</li> <li><code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Kill a job and update its status&lt;/&gt;</li> <li><code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code> \u2014 Try to kill all running jobs&lt;/&gt;</li> <li><code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code> (bool) \u2014 Check if all jobs are done or new jobs can submit&lt;/&gt;</li> <li><code>retry_job</code><code>(</code><code>job</code><code>)</code> \u2014 Retry a job&lt;/&gt;</li> <li><code>submit_job</code><code>(</code><code>job</code><code>)</code> (int) \u2014 Submit a job locally&lt;/&gt;</li> <li><code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code> \u2014 Submit and update the status&lt;/&gt;</li> <li><code>wrap_job_script</code><code>(</code><code>job</code><code>)</code> (str) \u2014 Wrap the job script&lt;/&gt;</li> <li><code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code> (SpecPath) \u2014 Get the wrapped job script&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Create a job</p> Parameters <ul> <li><code>index</code> (int) \u2014 The index of the job</li> <li><code>cmd</code> (Union) \u2014 The command of the job</li> </ul> Returns (Job) <p>The job</p> method &lt;/&gt; <p>Submit and update the status</p><ol> <li>Check if the job is already submitted or running</li> <li>If not, run the hook</li> <li>If the hook is not cancelled, clean the job</li> <li>Submit the job, raising an exception if it fails</li> <li>If the job is submitted successfully, update the status</li> <li>If the job fails to submit, update the status and write stderr to     the job file</li> </ol> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Retry a job</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Kill a job and update its status</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Check if all jobs are done or new jobs can submit</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> <li><code>on</code> (str) \u2014 query on status: <code>submittable</code> or <code>all_done</code></li> <li><code>polling_counter</code> (int) \u2014 The polling counter, used to limit the number of polls orskip some polls if the scheduler is busy. </li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Try to kill all running jobs</p> Parameters <ul> <li><code>jobs</code> (List) \u2014 The list of jobs</li> </ul> method &lt;/&gt; <p>Check if a job is already submitted or running</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if yes otherwise False.</p> method &lt;/&gt; <p>Check if a job fails before running.</p><p>For some schedulers, the job might fail before running (after submission). For example, the job might fail to allocate resources. In such a case, the wrapped script might not be executed, and the job status will not be updated (stays in SUBMITTED). We need to check such jobs and mark them as FAILED.</p> <p>For the instant scheduler, for example, the local scheduler, the failure will be immediately reported when submitting the job, so we don't need to check such jobs.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job to check</li> </ul> Returns (bool) <p>True if the job fails before running, otherwise False.</p> method &lt;/&gt; <p>The job command preparation</p> method &lt;/&gt; <p>The job command end</p> method &lt;/&gt; <p>Wrap the job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (str) <p>The wrapped script</p> method &lt;/&gt; <p>Kill a job asynchronously</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> method &lt;/&gt; <p>Tell if a job is really running, not only the job.jid_file</p><p>In case where the jid file is not cleaned when job is done.</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (bool) <p>True if it is, otherwise False</p> method &lt;/&gt; <p>Get the wrapped job script</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (SpecPath) <p>The path of the wrapped job script</p> method &lt;/&gt; <p>The shebang of the wrapper script</p> method &lt;/&gt; <p>Submit a job locally</p> Parameters <ul> <li><code>job</code> (Job) \u2014 The job</li> </ul> Returns (int) <p>The process id</p> method &lt;/&gt; <p>The job command init</p> function &lt;/&gt; <p>Get the scheduler by name of the scheduler class itself</p> Parameters <ul> <li><code>scheduler</code> (Union) \u2014 The scheduler class or name</li> </ul> Returns (Type) <p>The scheduler class</p>"},{"location":"api/pipen.scheduler/#pipenscheduler","title":"pipen.scheduler","text":""},{"location":"api/pipen.scheduler/#pipenschedulerschedulerpostinit","title":"<code>pipen.scheduler.</code><code>SchedulerPostInit</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#pipenschedulerlocalscheduler","title":"<code>pipen.scheduler.</code><code>LocalScheduler</code><code>(</code><code>workdir</code>, <code>forks=1</code>, <code>error_strategy='ignore'</code>, <code>num_retries=3</code>, <code>prescript=''</code>, <code>postscript=''</code>, <code>jobname_prefix=None</code>, <code>recheck_interval=600</code>, <code>cwd=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulercreate_job","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulersubmit_job_and_update_status","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerretry_job","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_job_and_update_status","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerpolling_jobs","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_running_jobs","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_prep","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_end","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrap_job_script","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerslocal_schedulerlocalschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code>, <code>_mounted=False</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerslocal_schedulerlocalschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerslocal_schedulerlocalschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#pipenschedulersgescheduler","title":"<code>pipen.scheduler.</code><code>SgeScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulercreate_job_1","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulersubmit_job_and_update_status_1","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerretry_job_1","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_job_and_update_status_1","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerpolling_jobs_1","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_running_jobs_1","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running_1","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_fails_before_running_1","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_init_1","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_prep_1","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_end_1","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrap_job_script_1","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrapped_job_script_1","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerssge_schedulersgeschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerssge_schedulersgeschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerssge_schedulersgeschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerssge_schedulersgeschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#pipenschedulerslurmscheduler","title":"<code>pipen.scheduler.</code><code>SlurmScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulercreate_job_2","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulersubmit_job_and_update_status_2","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerretry_job_2","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_job_and_update_status_2","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerpolling_jobs_2","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_running_jobs_2","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running_2","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_init_2","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_prep_2","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_end_2","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrap_job_script_2","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrapped_job_script_2","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersslurm_schedulerslurmschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulersslurm_schedulerslurmschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersslurm_schedulerslurmschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersslurm_schedulerslurmschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersslurm_schedulerslurmschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#pipenschedulersshscheduler","title":"<code>pipen.scheduler.</code><code>SshScheduler</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulercreate_job_3","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulersubmit_job_and_update_status_3","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerretry_job_3","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_job_and_update_status_3","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerpolling_jobs_3","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_running_jobs_3","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running_3","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_fails_before_running_2","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_shebang_1","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_init_3","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_prep_3","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_end_3","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrap_job_script_3","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrapped_job_script_3","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersssh_schedulerschedulersshschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersssh_schedulerschedulersshschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersssh_schedulerschedulersshschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#pipenschedulergbatchscheduler","title":"<code>pipen.scheduler.</code><code>GbatchScheduler</code><code>(</code><code>*args</code>, <code>project</code>, <code>location</code>, <code>mount=None</code>, <code>service_account=None</code>, <code>network=None</code>, <code>subnetwork=None</code>, <code>no_external_ip_address=None</code>, <code>machine_type=None</code>, <code>provisioning_model=None</code>, <code>image_uri=None</code>, <code>entrypoint=None</code>, <code>commands=None</code>, <code>runnables=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulercreate_job_4","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulersubmit_job_and_update_status_4","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerretry_job_4","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_job_and_update_status_4","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerpolling_jobs_4","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_running_jobs_4","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running_4","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_shebang_2","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_prep_4","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_end_4","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrap_job_script_4","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrapped_job_script_4","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersgbatch_schedulergbatchschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersgbatch_schedulergbatchschedulerkill_job","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjob_fails_before_running","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjob_is_running","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulersgbatch_schedulergbatchschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#pipenschedulercontainerscheduler","title":"<code>pipen.scheduler.</code><code>ContainerScheduler</code><code>(</code><code>image</code>, <code>entrypoint='/bin/bash'</code>, <code>bin='docker'</code>, <code>volumes=None</code>, <code>remove=True</code>, <code>user=None</code>, <code>bin_args=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulercreate_job_5","title":"<code>create_job</code><code>(</code><code>index</code>, <code>cmd</code>, <code>envs=None</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulersubmit_job_and_update_status_5","title":"<code>submit_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerretry_job_5","title":"<code>retry_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_job_and_update_status_5","title":"<code>kill_job_and_update_status</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerpolling_jobs_5","title":"<code>polling_jobs</code><code>(</code><code>jobs</code>, <code>on</code>, <code>polling_counter</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerkill_running_jobs_5","title":"<code>kill_running_jobs</code><code>(</code><code>jobs</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_is_submitted_or_running_5","title":"<code>job_is_submitted_or_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjob_fails_before_running_3","title":"<code>job_fails_before_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_prep_5","title":"<code>jobcmd_prep</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerjobcmd_end_5","title":"<code>jobcmd_end</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerschedulerwrap_job_script_5","title":"<code>wrap_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerslocal_schedulerlocalschedulerkill_job_1","title":"<code>kill_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerslocal_schedulerlocalschedulerjob_is_running_1","title":"<code>job_is_running</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerscontainer_schedulercontainerschedulerwrapped_job_script","title":"<code>wrapped_job_script</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerscontainer_schedulercontainerschedulerjobcmd_shebang","title":"<code>jobcmd_shebang</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#xquteschedulerscontainer_schedulercontainerschedulersubmit_job","title":"<code>submit_job</code><code>(</code><code>job</code><code>)</code>","text":""},{"location":"api/pipen.scheduler/#xquteschedulerscontainer_schedulercontainerschedulerjobcmd_init","title":"<code>jobcmd_init</code><code>(</code><code>job</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.scheduler/#pipenschedulerget_scheduler","title":"<code>pipen.scheduler.</code><code>get_scheduler</code><code>(</code><code>scheduler</code><code>)</code>","text":""},{"location":"api/pipen.template/","title":"pipen.template","text":"module &lt;/&gt; <p>Template adaptor for pipen</p> Classes <ul> <li><code>Template</code><code>(</code><code>source</code>, <code>**kwargs</code><code>)</code> \u2014 Base class wrapper to wrap template for pipen&lt;/&gt;</li> <li><code>TemplateLiquid</code> \u2014 Liquidpy template wrapper.&lt;/&gt;</li> <li><code>TemplateJinja2</code> \u2014 Jinja2 template wrapper&lt;/&gt;</li> </ul> Functions <ul> <li><code>get_template_engine</code><code>(</code><code>template</code><code>)</code> (Type) \u2014 Get the template engine by name or the template engine itself&lt;/&gt;</li> </ul> abstract class &lt;/&gt; <p>Base class wrapper to wrap template for pipen</p> Methods <ul> <li><code>render</code><code>(</code><code>data</code><code>)</code> (str) \u2014 Render the template@parmas:     data (dict): The data used to render &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Render the template@parmas:     data (dict): The data used to render</p> class &lt;/&gt; Bases pipen.template.Template <p>Liquidpy template wrapper.</p> Methods <ul> <li><code>render</code><code>(</code><code>data</code><code>)</code> (str) \u2014 Render the template@parmas:     data (dict): The data used to render &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Render the template@parmas:     data (dict): The data used to render</p> class &lt;/&gt; Bases pipen.template.Template <p>Jinja2 template wrapper</p> Methods <ul> <li><code>render</code><code>(</code><code>data</code><code>)</code> (str) \u2014 Render the template@parmas:     data (dict): The data used to render &lt;/&gt;</li> </ul> method &lt;/&gt; <p>Render the template@parmas:     data (dict): The data used to render</p> function &lt;/&gt; <p>Get the template engine by name or the template engine itself</p> Parameters <ul> <li><code>template</code> (Union) \u2014 The name of the template engine or the template engine itself</li> </ul> Returns (Type) <p>The template engine</p>"},{"location":"api/pipen.template/#pipentemplate","title":"pipen.template","text":""},{"location":"api/pipen.template/#pipentemplatetemplate","title":"<code>pipen.template.</code><code>Template</code><code>(</code><code>source</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.template/#pipentemplatetemplaterender","title":"<code>render</code><code>(</code><code>data=None</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.template/#pipentemplatetemplateliquid","title":"<code>pipen.template.</code><code>TemplateLiquid</code><code>(</code><code>source</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.template/#pipentemplatetemplaterender_1","title":"<code>render</code><code>(</code><code>data=None</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.template/#pipentemplatetemplatejinja2","title":"<code>pipen.template.</code><code>TemplateJinja2</code><code>(</code><code>source</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.template/#pipentemplatetemplaterender_2","title":"<code>render</code><code>(</code><code>data=None</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.template/#pipentemplateget_template_engine","title":"<code>pipen.template.</code><code>get_template_engine</code><code>(</code><code>template</code><code>)</code>","text":""},{"location":"api/pipen.utils/","title":"pipen.utils","text":"module &lt;/&gt; <p>Provide some utilities</p> Classes <ul> <li><code>RichHandler</code> \u2014 Subclass of rich.logging.RichHandler, showing log levels as a singlecharacter &lt;/&gt;</li> <li><code>RichConsole</code> \u2014 A high level console interface.&lt;/&gt;</li> </ul> Functions <ul> <li><code>brief_list</code><code>(</code><code>blist</code><code>)</code> (str) \u2014 Briefly show an integer list, combine the continuous numbers.&lt;/&gt;</li> <li><code>copy_dict</code><code>(</code><code>dic</code>, <code>depth</code><code>)</code> (Mapping) \u2014 Deep copy a dict&lt;/&gt;</li> <li><code>desc_from_docstring</code><code>(</code><code>obj</code>, <code>base</code><code>)</code> (str) \u2014 Get the description from docstring&lt;/&gt;</li> <li><code>get_base</code><code>(</code><code>klass</code>, <code>abc_base</code>, <code>value</code>, <code>value_getter</code><code>)</code> (Type) \u2014 Get the base class where the value was first defined&lt;/&gt;</li> <li><code>get_logger</code><code>(</code><code>name</code>, <code>level</code><code>)</code> (LoggerAdapter) \u2014 Get the logger by given plugin name&lt;/&gt;</li> <li><code>get_logpanel_width</code><code>(</code><code>)</code> (int) \u2014 Get the width of the log content&lt;/&gt;</li> <li><code>get_marked</code><code>(</code><code>cls</code>, <code>mark_name</code>, <code>default</code><code>)</code> (Any) \u2014 Get the marked value from a proc&lt;/&gt;</li> <li><code>get_mtime</code><code>(</code><code>path</code>, <code>dir_depth</code><code>)</code> (float) \u2014 Get the modification time of a path.If path is a directory, try to get the last modification time of the contents in the directory at given dir_depth &lt;/&gt;</li> <li><code>get_shebang</code><code>(</code><code>script</code><code>)</code> (str) \u2014 Get the shebang of the script&lt;/&gt;</li> <li><code>ignore_firstline_dedent</code><code>(</code><code>text</code><code>)</code> (str) \u2014 Like textwrap.dedent(), but ignore first empty lines&lt;/&gt;</li> <li><code>is_loading_pipeline</code><code>(</code><code>*flags</code>, <code>argv</code><code>)</code> (bool) \u2014 Check if we are loading the pipeline. Works only when<code>argv0</code> is \"@pipen\" while loading the pipeline. &lt;/&gt;</li> <li><code>is_subclass</code><code>(</code><code>obj</code>, <code>cls</code><code>)</code> (bool) \u2014 Tell if obj is a subclass of clsDifferences with issubclass is that we don't raise Type error if obj is not a class &lt;/&gt;</li> <li><code>is_valid_name</code><code>(</code><code>name</code><code>)</code> (bool) \u2014 Check if a name is valid for a proc or pipen&lt;/&gt;</li> <li><code>load_entrypoints</code><code>(</code><code>group</code><code>)</code> (Iterable) \u2014 Load objects from setuptools entrypoints by given group name&lt;/&gt;</li> <li><code>load_pipeline</code><code>(</code><code>obj</code>, <code>argv0</code>, <code>argv1p</code>, <code>**kwargs</code><code>)</code> (Pipen) \u2014 Load a pipeline from a Pipen, Proc or ProcGroup object&lt;/&gt;</li> <li><code>log_rich_renderable</code><code>(</code><code>renderable</code>, <code>color</code>, <code>logfunc</code>, <code>*args</code>, <code>**kwargs</code><code>)</code> \u2014 Log a rich renderable to logger&lt;/&gt;</li> <li><code>make_df_colnames_unique_inplace</code><code>(</code><code>thedf</code><code>)</code> \u2014 Make the columns of a data frame unique&lt;/&gt;</li> <li><code>mark</code><code>(</code><code>**kwargs</code><code>)</code> (Callable) \u2014 Mark a class (e.g. Proc) with given kwargs as metadata&lt;/&gt;</li> <li><code>path_is_symlink</code><code>(</code><code>path</code><code>)</code> (bool) \u2014 Check if a path is a symlink.&lt;/&gt;</li> <li><code>path_symlink_to</code><code>(</code><code>src</code>, <code>dst</code>, <code>target_is_directory</code><code>)</code> \u2014 Create a symbolic link pointing to src named dst.&lt;/&gt;</li> <li><code>pipen_banner</code><code>(</code><code>)</code> (RenderableType) \u2014 The banner for pipen&lt;/&gt;</li> <li><code>strsplit</code><code>(</code><code>string</code>, <code>sep</code>, <code>maxsplit</code>, <code>trim</code><code>)</code> (List) \u2014 Split the string, with the ability to trim each part.&lt;/&gt;</li> <li><code>truncate_text</code><code>(</code><code>text</code>, <code>width</code>, <code>end</code><code>)</code> (str) \u2014 Truncate a text not based on words/whitespacesOtherwise, we could use textwrap.shorten. &lt;/&gt;</li> <li><code>update_dict</code><code>(</code><code>parent</code>, <code>new</code>, <code>depth</code>, <code>try_list</code><code>)</code> (Mapping) \u2014 Update the new dict to the parent, but make sure parent does not change&lt;/&gt;</li> </ul> class &lt;/&gt; Bases rich.logging.RichHandler logging.Handler logging.Filterer <p>Subclass of rich.logging.RichHandler, showing log levels as a singlecharacter</p> Parameters <ul> <li><code>level</code> (Union, optional) \u2014 Log level. Defaults to logging.NOTSET.</li> <li><code>show_time</code> (bool, optional) \u2014 Show a column for the time. Defaults to True.</li> <li><code>omit_repeated_times</code> (bool, optional) \u2014 Omit repetition of the same time. Defaults to True.</li> <li><code>show_level</code> (bool, optional) \u2014 Show a column for the level. Defaults to True.</li> <li><code>show_path</code> (bool, optional) \u2014 Show the path to the original log call. Defaults to True.</li> <li><code>enable_link_path</code> (bool, optional) \u2014 Enable terminal link of path column to file. Defaults to True.</li> <li><code>highlighter</code> (Optional, optional) \u2014 Highlighter to style log messages, or None to use ReprHighlighter. Defaults to None.</li> <li><code>markup</code> (bool, optional) \u2014 Enable console markup in log messages. Defaults to False.</li> <li><code>rich_tracebacks</code> (bool, optional) \u2014 Enable rich tracebacks with syntax highlighting and formatting. Defaults to False.</li> <li><code>tracebacks_width</code> (Optional, optional) \u2014 Number of characters used to render tracebacks, or None for full width. Defaults to None.</li> <li><code>tracebacks_code_width</code> (Optional, optional) \u2014 Number of code characters used to render tracebacks, or None for full width. Defaults to 88.</li> <li><code>tracebacks_extra_lines</code> (int, optional) \u2014 Additional lines of code to render tracebacks, or None for full width. Defaults to None.</li> <li><code>tracebacks_theme</code> (Optional, optional) \u2014 Override pygments theme used in traceback.</li> <li><code>tracebacks_word_wrap</code> (bool, optional) \u2014 Enable word wrapping of long tracebacks lines. Defaults to True.</li> <li><code>tracebacks_show_locals</code> (bool, optional) \u2014 Enable display of locals in tracebacks. Defaults to False.</li> <li><code>tracebacks_suppress</code> (Iterable, optional) \u2014 Optional sequence of modules or paths to exclude from traceback.</li> <li><code>tracebacks_max_frames</code> (int, optional) \u2014 Optional maximum number of frames returned by traceback.</li> <li><code>locals_max_length</code> (int, optional) \u2014 Maximum length of containers before abbreviating, or None for no abbreviation.Defaults to 10. </li> <li><code>locals_max_string</code> (int, optional) \u2014 Maximum length of string before truncating, or None to disable. Defaults to 80.</li> <li><code>log_time_format</code> (Union, optional) \u2014 If <code>log_time</code> is enabled, either string for strftime or callable that formats the time. Defaults to \"[%x %X] \".</li> <li><code>keywords</code> (Optional, optional) \u2014 List of words to highlight instead of <code>RichHandler.KEYWORDS</code>.</li> </ul> Methods <ul> <li><code>acquire</code><code>(</code><code>)</code> \u2014 Acquire the I/O thread lock.&lt;/&gt;</li> <li><code>addFilter</code><code>(</code><code>filter</code><code>)</code> \u2014 Add the specified filter to this handler.&lt;/&gt;</li> <li><code>close</code><code>(</code><code>)</code> \u2014 Tidy up any resources used by the handler.&lt;/&gt;</li> <li><code>createLock</code><code>(</code><code>)</code> \u2014 Acquire a thread lock for serializing access to the underlying I/O.&lt;/&gt;</li> <li><code>emit</code><code>(</code><code>record</code><code>)</code> \u2014 Invoked by logging.&lt;/&gt;</li> <li><code>filter</code><code>(</code><code>record</code><code>)</code> \u2014 Determine if a record is loggable by consulting all the filters.&lt;/&gt;</li> <li><code>flush</code><code>(</code><code>)</code> \u2014 Ensure all logging output has been flushed.&lt;/&gt;</li> <li><code>format</code><code>(</code><code>record</code><code>)</code> \u2014 Format the specified record.&lt;/&gt;</li> <li><code>get_level_text</code><code>(</code><code>record</code><code>)</code> (Text) \u2014 Get the level name from the record.&lt;/&gt;</li> <li><code>handle</code><code>(</code><code>record</code><code>)</code> \u2014 Conditionally emit the specified logging record.&lt;/&gt;</li> <li><code>handleError</code><code>(</code><code>record</code><code>)</code> \u2014 Handle errors which occur during an emit() call.&lt;/&gt;</li> <li><code>release</code><code>(</code><code>)</code> \u2014 Release the I/O thread lock.&lt;/&gt;</li> <li><code>removeFilter</code><code>(</code><code>filter</code><code>)</code> \u2014 Remove the specified filter from this handler.&lt;/&gt;</li> <li><code>render</code><code>(</code><code>record</code>, <code>traceback</code>, <code>message_renderable</code><code>)</code> (ConsoleRenderable) \u2014 Render log for display.&lt;/&gt;</li> <li><code>render_message</code><code>(</code><code>record</code>, <code>message</code><code>)</code> (ConsoleRenderable) \u2014 Render message text in to Text.&lt;/&gt;</li> <li><code>setFormatter</code><code>(</code><code>fmt</code><code>)</code> \u2014 Set the formatter for this handler.&lt;/&gt;</li> <li><code>setLevel</code><code>(</code><code>level</code><code>)</code> \u2014 Set the logging level of this handler.  level must be an int or a str.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Add the specified filter to this handler.</p> method &lt;/&gt; <p>Remove the specified filter from this handler.</p> method &lt;/&gt; <p>Determine if a record is loggable by consulting all the filters.</p><p>The default is to allow the record to be logged; any filter can veto this by returning a false value. If a filter attached to a handler returns a log record instance, then that instance is used in place of the original log record in any further processing of the event by that handler. If a filter returns any other true value, the original log record is used in any further processing of the event by that handler.</p> <p>If none of the filters return false values, this method returns a log record. If any of the filters return a false value, this method returns a false value.</p> <p>.. versionchanged:: 3.2</p> <p>Allow filters to be just callables.</p> <p>.. versionchanged:: 3.12    Allow filters to return a LogRecord instead of    modifying it in place.</p> method &lt;/&gt; <p>Acquire a thread lock for serializing access to the underlying I/O.</p> method &lt;/&gt; <p>Acquire the I/O thread lock.</p> method &lt;/&gt; <p>Release the I/O thread lock.</p> method &lt;/&gt; <p>Set the logging level of this handler.  level must be an int or a str.</p> method &lt;/&gt; <p>Format the specified record.</p><p>If a formatter is set, use it. Otherwise, use the default formatter for the module.</p> method &lt;/&gt; <p>Conditionally emit the specified logging record.</p><p>Emission depends on filters which may have been added to the handler. Wrap the actual emission of the record with acquisition/release of the I/O thread lock.</p> <p>Returns an instance of the log record that was emitted if it passed all filters, otherwise a false value is returned.</p> method &lt;/&gt; <p>Set the formatter for this handler.</p> method &lt;/&gt; <p>Ensure all logging output has been flushed.</p><p>This version does nothing and is intended to be implemented by subclasses.</p> method &lt;/&gt; <p>Tidy up any resources used by the handler.</p><p>This version removes the handler from an internal map of handlers, _handlers, which is used for handler lookup by name. Subclasses should ensure that this gets called from overridden close() methods.</p> method &lt;/&gt; <p>Handle errors which occur during an emit() call.</p><p>This method should be called from handlers when an exception is encountered during an emit() call. If raiseExceptions is false, exceptions get silently ignored. This is what is mostly wanted for a logging system - most users will not care about errors in the logging system, they are more interested in application errors. You could, however, replace this with a custom handler if you wish. The record which was being processed is passed in to this method.</p> method &lt;/&gt; <p>Invoked by logging.</p> method &lt;/&gt; <p>Render message text in to Text.</p> Parameters <ul> <li><code>record</code> (LogRecord) \u2014 logging Record.</li> <li><code>message</code> (str) \u2014 String containing log message.</li> </ul> Returns (ConsoleRenderable) <p>Renderable to display log message.</p> method &lt;/&gt; <p>Render log for display.</p> Parameters <ul> <li><code>record</code> (LogRecord) \u2014 logging Record.</li> <li><code>traceback</code> (Optional[Traceback]) \u2014 Traceback instance or None for no Traceback.</li> <li><code>message_renderable</code> (ConsoleRenderable) \u2014 Renderable (typically Text) containing log message contents.</li> </ul> Returns (ConsoleRenderable) <p>Renderable to display log.</p> method &lt;/&gt; <p>Get the level name from the record.</p> Parameters <ul> <li><code>record</code> (LogRecord) \u2014 LogRecord instance.</li> </ul> Returns (Text) <p>A tuple of the style and level name.</p> class &lt;/&gt; Bases rich.console.Console <p>A high level console interface.</p> Attributes <ul> <li><code>color_system</code> \u2014 Get color system string.&lt;/&gt;</li> <li><code>encoding</code> \u2014 Get the encoding of the console file, e.g. <code>\"utf-8\"</code>.&lt;/&gt;</li> <li><code>file</code> (IO) \u2014 Get the file object to write to.&lt;/&gt;</li> <li><code>height</code> \u2014 Get the height of the console.&lt;/&gt;</li> <li><code>is_alt_screen</code> \u2014 Check if the alt screen was enabled.&lt;/&gt;</li> <li><code>is_dumb_terminal</code> \u2014 Detect dumb terminal.&lt;/&gt;</li> <li><code>is_terminal</code> \u2014 Check if the console is writing to a terminal.&lt;/&gt;</li> <li><code>options</code> (ConsoleOptions) \u2014 Get default console options.&lt;/&gt;</li> <li><code>size</code> \u2014 Get the size of the console.&lt;/&gt;</li> <li><code>width</code> \u2014 Get the width of the console.&lt;/&gt;</li> </ul> Methods <ul> <li><code>__enter__</code><code>(</code><code>)</code> (Console) \u2014 Own context manager to enter buffer context.&lt;/&gt;</li> <li><code>__exit__</code><code>(</code><code>exc_type</code>, <code>exc_value</code>, <code>traceback</code><code>)</code> \u2014 Exit buffer context.&lt;/&gt;</li> <li><code>begin_capture</code><code>(</code><code>)</code> \u2014 Begin capturing console output. Call :meth:<code>end_capture</code> to exit capture mode and return output.&lt;/&gt;</li> <li><code>bell</code><code>(</code><code>)</code> \u2014 Play a 'bell' sound (if supported by the terminal).&lt;/&gt;</li> <li><code>capture</code><code>(</code><code>)</code> (Capture) \u2014 A context manager to capture the result of print() or log() in a string,rather than writing it to the console. &lt;/&gt;</li> <li><code>clear</code><code>(</code><code>home</code><code>)</code> \u2014 Clear the screen.&lt;/&gt;</li> <li><code>clear_live</code><code>(</code><code>)</code> \u2014 Clear the Live instance. Used by the Live context manager (no need to call directly).&lt;/&gt;</li> <li><code>control</code><code>(</code><code>*control</code><code>)</code> \u2014 Insert non-printing control codes.&lt;/&gt;</li> <li><code>end_capture</code><code>(</code><code>)</code> (str) \u2014 End capture mode and return captured string.&lt;/&gt;</li> <li><code>export_html</code><code>(</code><code>theme</code>, <code>clear</code>, <code>code_format</code>, <code>inline_styles</code><code>)</code> (str) \u2014 Generate HTML from console contents (requires record=True argument in constructor).&lt;/&gt;</li> <li><code>export_svg</code><code>(</code><code>title</code>, <code>theme</code>, <code>clear</code>, <code>code_format</code>, <code>font_aspect_ratio</code>, <code>unique_id</code><code>)</code> (str) \u2014 Generate an SVG from the console contents (requires record=True in Console constructor).&lt;/&gt;</li> <li><code>export_text</code><code>(</code><code>clear</code>, <code>styles</code><code>)</code> (str) \u2014 Generate text from console contents (requires record=True argument in constructor).&lt;/&gt;</li> <li><code>get_style</code><code>(</code><code>name</code>, <code>default</code><code>)</code> (Style) \u2014 Get a Style instance by its theme name or parse a definition.&lt;/&gt;</li> <li><code>input</code><code>(</code><code>prompt</code>, <code>markup</code>, <code>emoji</code>, <code>password</code>, <code>stream</code><code>)</code> (str) \u2014 Displays a prompt and waits for input from the user. The prompt may contain color / style.&lt;/&gt;</li> <li><code>line</code><code>(</code><code>count</code><code>)</code> \u2014 Write new line(s).&lt;/&gt;</li> <li><code>log</code><code>(</code><code>*objects</code>, <code>sep</code>, <code>end</code>, <code>style</code>, <code>justify</code>, <code>emoji</code>, <code>markup</code>, <code>highlight</code>, <code>log_locals</code>, <code>_stack_offset</code><code>)</code> \u2014 Log rich content to the terminal.&lt;/&gt;</li> <li><code>measure</code><code>(</code><code>renderable</code>, <code>options</code><code>)</code> (Measurement) \u2014 Measure a renderable. Returns a :class:<code>~rich.measure.Measurement</code> object which containsinformation regarding the number of characters required to print the renderable. &lt;/&gt;</li> <li><code>on_broken_pipe</code><code>(</code><code>)</code> \u2014 This function is called when a <code>BrokenPipeError</code> is raised.&lt;/&gt;</li> <li><code>out</code><code>(</code><code>*objects</code>, <code>sep</code>, <code>end</code>, <code>style</code>, <code>highlight</code><code>)</code> \u2014 Output to the terminal. This is a low-level way of writing to the terminal which unlike:meth:<code>~rich.console.Console.print</code> won't pretty print, wrap text, or apply markup, but will optionally apply highlighting and a basic style. &lt;/&gt;</li> <li><code>pager</code><code>(</code><code>pager</code>, <code>styles</code>, <code>links</code><code>)</code> (PagerContext) \u2014 A context manager to display anything printed within a \"pager\". The pager applicationis defined by the system and will typically support at least pressing a key to scroll. &lt;/&gt;</li> <li><code>pop_render_hook</code><code>(</code><code>)</code> \u2014 Pop the last renderhook from the stack.&lt;/&gt;</li> <li><code>pop_theme</code><code>(</code><code>)</code> \u2014 Remove theme from top of stack, restoring previous theme.&lt;/&gt;</li> <li><code>print</code><code>(</code><code>*objects</code>, <code>sep</code>, <code>end</code>, <code>style</code>, <code>justify</code>, <code>overflow</code>, <code>no_wrap</code>, <code>emoji</code>, <code>markup</code>, <code>highlight</code>, <code>width</code>, <code>height</code>, <code>crop</code>, <code>soft_wrap</code>, <code>new_line_start</code><code>)</code> \u2014 Print to the console.&lt;/&gt;</li> <li><code>print_exception</code><code>(</code><code>width</code>, <code>extra_lines</code>, <code>theme</code>, <code>word_wrap</code>, <code>show_locals</code>, <code>suppress</code>, <code>max_frames</code><code>)</code> \u2014 Prints a rich render of the last exception and traceback.&lt;/&gt;</li> <li><code>print_json</code><code>(</code><code>json</code>, <code>data</code>, <code>indent</code>, <code>highlight</code>, <code>skip_keys</code>, <code>ensure_ascii</code>, <code>check_circular</code>, <code>allow_nan</code>, <code>default</code>, <code>sort_keys</code><code>)</code> \u2014 Pretty prints JSON. Output will be valid JSON.&lt;/&gt;</li> <li><code>push_render_hook</code><code>(</code><code>hook</code><code>)</code> \u2014 Add a new render hook to the stack.&lt;/&gt;</li> <li><code>push_theme</code><code>(</code><code>theme</code>, <code>inherit</code><code>)</code> \u2014 Push a new theme on to the top of the stack, replacing the styles from the previous theme.Generally speaking, you should call :meth:<code>~rich.console.Console.use_theme</code> to get a context manager, rather than calling this method directly. &lt;/&gt;</li> <li><code>render</code><code>(</code><code>renderable</code>, <code>options</code><code>)</code> (Iterable[Segment]) \u2014 Render an object in to an iterable of <code>Segment</code> instances.&lt;/&gt;</li> <li><code>render_lines</code><code>(</code><code>renderable</code>, <code>options</code>, <code>style</code>, <code>pad</code>, <code>new_lines</code><code>)</code> (List) \u2014 Render objects in to a list of lines.&lt;/&gt;</li> <li><code>render_str</code><code>(</code><code>text</code>, <code>style</code>, <code>justify</code>, <code>overflow</code>, <code>emoji</code>, <code>markup</code>, <code>highlight</code>, <code>highlighter</code><code>)</code> (ConsoleRenderable) \u2014 Convert a string to a Text instance. This is called automatically ifyou print or log a string. &lt;/&gt;</li> <li><code>rule</code><code>(</code><code>title</code>, <code>characters</code>, <code>style</code>, <code>align</code><code>)</code> \u2014 Draw a line with optional centered title.&lt;/&gt;</li> <li><code>save_html</code><code>(</code><code>path</code>, <code>theme</code>, <code>clear</code>, <code>code_format</code>, <code>inline_styles</code><code>)</code> \u2014 Generate HTML from console contents and write to a file (requires record=True argument in constructor).&lt;/&gt;</li> <li><code>save_svg</code><code>(</code><code>path</code>, <code>title</code>, <code>theme</code>, <code>clear</code>, <code>code_format</code>, <code>font_aspect_ratio</code>, <code>unique_id</code><code>)</code> \u2014 Generate an SVG file from the console contents (requires record=True in Console constructor).&lt;/&gt;</li> <li><code>save_text</code><code>(</code><code>path</code>, <code>clear</code>, <code>styles</code><code>)</code> \u2014 Generate text from console and save to a given location (requires record=True argument in constructor).&lt;/&gt;</li> <li><code>screen</code><code>(</code><code>hide_cursor</code>, <code>style</code><code>)</code> (~ScreenContext) \u2014 Context manager to enable and disable 'alternative screen' mode.&lt;/&gt;</li> <li><code>set_alt_screen</code><code>(</code><code>enable</code><code>)</code> (bool) \u2014 Enables alternative screen mode.&lt;/&gt;</li> <li><code>set_live</code><code>(</code><code>live</code><code>)</code> (bool) \u2014 Set Live instance. Used by Live context manager (no need to call directly).&lt;/&gt;</li> <li><code>set_window_title</code><code>(</code><code>title</code><code>)</code> (bool) \u2014 Set the title of the console terminal window.&lt;/&gt;</li> <li><code>show_cursor</code><code>(</code><code>show</code><code>)</code> (bool) \u2014 Show or hide the cursor.&lt;/&gt;</li> <li><code>status</code><code>(</code><code>status</code>, <code>spinner</code>, <code>spinner_style</code>, <code>speed</code>, <code>refresh_per_second</code><code>)</code> (Status) \u2014 Display a status and spinner.&lt;/&gt;</li> <li><code>update_screen</code><code>(</code><code>renderable</code>, <code>region</code>, <code>options</code><code>)</code> \u2014 Update the screen at a given offset.&lt;/&gt;</li> <li><code>update_screen_lines</code><code>(</code><code>lines</code>, <code>x</code>, <code>y</code><code>)</code> \u2014 Update lines of the screen at a given offset.&lt;/&gt;</li> <li><code>use_theme</code><code>(</code><code>theme</code>, <code>inherit</code><code>)</code> (ThemeContext) \u2014 Use a different theme for the duration of the context manager.&lt;/&gt;</li> </ul> method &lt;/&gt; <p>Set Live instance. Used by Live context manager (no need to call directly).</p> Parameters <ul> <li><code>live</code> (Live) \u2014 Live instance using this Console.</li> </ul> Returns (bool) <p>Boolean that indicates if the live is the topmost of the stack.</p> Raises <ul> <li><code>errors.LiveError</code> \u2014 If this Console has a Live context currently active.</li> </ul> method &lt;/&gt; <p>Clear the Live instance. Used by the Live context manager (no need to call directly).</p> method &lt;/&gt; <p>Add a new render hook to the stack.</p> Parameters <ul> <li><code>hook</code> (RenderHook) \u2014 Render hook instance.</li> </ul> method &lt;/&gt; <p>Pop the last renderhook from the stack.</p> method &lt;/&gt; <p>Own context manager to enter buffer context.</p> method &lt;/&gt; <p>Exit buffer context.</p> method &lt;/&gt; <p>Begin capturing console output. Call :meth:<code>end_capture</code> to exit capture mode and return output.</p> method &lt;/&gt; <p>End capture mode and return captured string.</p> Returns (str) <p>Console output.</p> method &lt;/&gt; <p>Push a new theme on to the top of the stack, replacing the styles from the previous theme.Generally speaking, you should call :meth:<code>~rich.console.Console.use_theme</code> to get a context manager, rather than calling this method directly.</p> Parameters <ul> <li><code>theme</code> (Theme) \u2014 A theme instance.</li> <li><code>inherit</code> (bool, optional) \u2014 Inherit existing styles. Defaults to True.</li> </ul> method &lt;/&gt; <p>Remove theme from top of stack, restoring previous theme.</p> method &lt;/&gt; <p>Use a different theme for the duration of the context manager.</p> Parameters <ul> <li><code>theme</code> (Theme) \u2014 Theme instance to user.</li> <li><code>inherit</code> (bool, optional) \u2014 Inherit existing console styles. Defaults to True.</li> </ul> Returns (ThemeContext) <p>[description]</p> method &lt;/&gt; <p>Play a 'bell' sound (if supported by the terminal).</p> method &lt;/&gt; <p>A context manager to capture the result of print() or log() in a string,rather than writing it to the console.</p> Example <pre><code>&gt;&gt;&gt; from rich.console import Console&gt;&gt;&gt; console = Console()\n&gt;&gt;&gt; with console.capture() as capture:\n...     console.print(\"[bold magenta]Hello World[/]\")\n&gt;&gt;&gt; print(capture.get())\n</code></pre> Returns (Capture) <p>Context manager with disables writing to the terminal.</p> method &lt;/&gt; <p>A context manager to display anything printed within a \"pager\". The pager applicationis defined by the system and will typically support at least pressing a key to scroll.</p> Parameters <ul> <li><code>pager</code> (Pager, optional) \u2014 A pager object, or None to use :class:<code>~rich.pager.SystemPager</code>. Defaults to None.</li> <li><code>styles</code> (bool, optional) \u2014 Show styles in pager. Defaults to False.</li> <li><code>links</code> (bool, optional) \u2014 Show links in pager. Defaults to False.</li> </ul> Example <pre><code>&gt;&gt;&gt; from rich.console import Console&gt;&gt;&gt; from rich.__main__ import make_test_card\n&gt;&gt;&gt; console = Console()\n&gt;&gt;&gt; with console.pager():\n        console.print(make_test_card())\n</code></pre> Returns (PagerContext) <p>A context manager.</p> method &lt;/&gt; <p>Write new line(s).</p> Parameters <ul> <li><code>count</code> (int, optional) \u2014 Number of new lines. Defaults to 1.</li> </ul> method &lt;/&gt; <p>Clear the screen.</p> Parameters <ul> <li><code>home</code> (bool, optional) \u2014 Also move the cursor to 'home' position. Defaults to True.</li> </ul> method &lt;/&gt; <p>Display a status and spinner.</p> Parameters <ul> <li><code>status</code> (RenderableType) \u2014 A status renderable (str or Text typically).</li> <li><code>spinner</code> (str, optional) \u2014 Name of spinner animation (see python -m rich.spinner). Defaults to \"dots\".</li> <li><code>spinner_style</code> (StyleType, optional) \u2014 Style of spinner. Defaults to \"status.spinner\".</li> <li><code>speed</code> (float, optional) \u2014 Speed factor for spinner animation. Defaults to 1.0.</li> <li><code>refresh_per_second</code> (float, optional) \u2014 Number of refreshes per second. Defaults to 12.5.</li> </ul> Returns (Status) <p>A Status object that may be used as a context manager.</p> method &lt;/&gt; <p>Show or hide the cursor.</p> Parameters <ul> <li><code>show</code> (bool, optional) \u2014 Set visibility of the cursor.</li> </ul> method &lt;/&gt; <p>Enables alternative screen mode.</p><p>Note, if you enable this mode, you should ensure that is disabled before the application exits. See :meth:<code>~rich.Console.screen</code> for a context manager that handles this for you.</p> Parameters <ul> <li><code>enable</code> (bool, optional) \u2014 Enable (True) or disable (False) alternate screen. Defaults to True.</li> </ul> Returns (bool) <p>True if the control codes were written.</p> method &lt;/&gt; <p>Set the title of the console terminal window.</p><p>Warning: There is no means within Rich of \"resetting\" the window title to its previous value, meaning the title you set will persist even after your application exits.</p> <p><code>fish</code> shell resets the window title before and after each command by default, negating this issue. Windows Terminal and command prompt will also reset the title for you. Most other shells and terminals, however, do not do this.</p> <p>Some terminals may require configuration changes before you can set the title. Some terminals may not support setting the title at all.</p> <p>Other software (including the terminal itself, the shell, custom prompts, plugins, etc.) may also set the terminal window title. This could result in whatever value you write using this method being overwritten.</p> Parameters <ul> <li><code>title</code> (str) \u2014 The new title of the terminal window.</li> </ul> Returns (bool) <p>True if the control code to change the terminal title was    written, otherwise False. Note that a return value of True     does not guarantee that the window title has actually changed,     since the feature may be unsupported/disabled in some terminals.</p> method &lt;/&gt; <p>Context manager to enable and disable 'alternative screen' mode.</p> Parameters <ul> <li><code>hide_cursor</code> (bool, optional) \u2014 Also hide the cursor. Defaults to False.</li> <li><code>style</code> (Style, optional) \u2014 Optional style for screen. Defaults to None.</li> </ul> Returns (~ScreenContext) <p>Context which enables alternate screen on enter, and disables it on exit.</p> method &lt;/&gt; <p>Measure a renderable. Returns a :class:<code>~rich.measure.Measurement</code> object which containsinformation regarding the number of characters required to print the renderable.</p> Parameters <ul> <li><code>renderable</code> (RenderableType) \u2014 Any renderable or string.</li> <li><code>options</code> (Optional[ConsoleOptions], optional) \u2014 Options to use when measuring, or Noneto use default options. Defaults to None. </li> </ul> Returns (Measurement) <p>A measurement of the renderable.</p> generator &lt;/&gt; <p>Render an object in to an iterable of <code>Segment</code> instances.</p><p>This method contains the logic for rendering objects with the console protocol. You are unlikely to need to use it directly, unless you are extending the library.</p> Parameters <ul> <li><code>renderable</code> (RenderableType) \u2014 An object supporting the console protocol, oran object that may be converted to a string. </li> <li><code>options</code> (ConsoleOptions, optional) \u2014 An options object, or None to use self.options. Defaults to None.</li> </ul> Returns (Iterable[Segment]) <p>An iterable of segments that may be rendered.</p> method &lt;/&gt; <p>Render objects in to a list of lines.</p><pre><code>    The output of render_lines is useful when further formatting of rendered console text\n    is required, such as the Panel class which draws a border around any renderable object.\n\n    Args:\n        renderable (RenderableType): Any object renderable in the console.\n        options (Optional[ConsoleOptions], optional): Console options, or None to use self.options. Default to ``None``.\n        style (Style, optional): Optional style to apply to renderables. Defaults to ``None``.\n        pad (bool, optional): Pad lines shorter than render width. Defaults to ``True``.\n        new_lines (bool, optional): Include \"\n</code></pre> <p>\" characters at end of lines.</p> <pre><code>    Returns:\n        List[List[Segment]]: A list of lines, where a line is a list of Segment objects.\n</code></pre> method &lt;/&gt; <p>Convert a string to a Text instance. This is called automatically ifyou print or log a string.</p> Parameters <ul> <li><code>text</code> (str) \u2014 Text to render.</li> <li><code>style</code> (Union[str, Style], optional) \u2014 Style to apply to rendered text.</li> <li><code>justify</code> (str, optional) \u2014 Justify method: \"default\", \"left\", \"center\", \"full\", or \"right\". Defaults to <code>None</code>.</li> <li><code>overflow</code> (str, optional) \u2014 Overflow method: \"crop\", \"fold\", or \"ellipsis\". Defaults to <code>None</code>.</li> <li><code>emoji</code> (Optional[bool], optional) \u2014 Enable emoji, or <code>None</code> to use Console default.</li> <li><code>markup</code> (Optional[bool], optional) \u2014 Enable markup, or <code>None</code> to use Console default.</li> <li><code>highlight</code> (Optional[bool], optional) \u2014 Enable highlighting, or <code>None</code> to use Console default.</li> <li><code>highlighter</code> (HighlighterType, optional) \u2014 Optional highlighter to apply.</li> </ul> Returns (ConsoleRenderable) <p>Renderable object.</p> method &lt;/&gt; <p>Get a Style instance by its theme name or parse a definition.</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name of a style or a style definition.</li> </ul> Returns (Style) <p>A Style object.</p> Raises <ul> <li><code>MissingStyle</code> \u2014 If no style could be parsed from name.</li> </ul> method &lt;/&gt; <p>Draw a line with optional centered title.</p> Parameters <ul> <li><code>title</code> (str, optional) \u2014 Text to render over the rule. Defaults to \"\".</li> <li><code>characters</code> (str, optional) \u2014 Character(s) to form the line. Defaults to \"\u2500\".</li> <li><code>style</code> (str, optional) \u2014 Style of line. Defaults to \"rule.line\".</li> <li><code>align</code> (str, optional) \u2014 How to align the title, one of \"left\", \"center\", or \"right\". Defaults to \"center\".</li> </ul> method &lt;/&gt; <p>Insert non-printing control codes.</p> method &lt;/&gt; <p>Output to the terminal. This is a low-level way of writing to the terminal which unlike:meth:<code>~rich.console.Console.print</code> won't pretty print, wrap text, or apply markup, but will optionally apply highlighting and a basic style.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 String to write between print data. Defaults to \" \".</li> <li><code>end</code> (str, optional) \u2014 String to write at end of print data. Defaults to \"\\n\".</li> <li><code>style</code> (Union[str, Style], optional) \u2014 A style to apply to output. Defaults to None.</li> <li><code>highlight</code> (Optional[bool], optional) \u2014 Enable automatic highlighting, or <code>None</code> to useconsole default. Defaults to <code>None</code>. </li> </ul> method &lt;/&gt; <p>Print to the console.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 String to write between print data. Defaults to \" \".</li> <li><code>end</code> (str, optional) \u2014 String to write at end of print data. Defaults to \"\\n\".</li> <li><code>style</code> (Union[str, Style], optional) \u2014 A style to apply to output. Defaults to None.</li> <li><code>justify</code> (str, optional) \u2014 Justify method: \"default\", \"left\", \"right\", \"center\", or \"full\". Defaults to <code>None</code>.</li> <li><code>overflow</code> (str, optional) \u2014 Overflow method: \"ignore\", \"crop\", \"fold\", or \"ellipsis\". Defaults to None.</li> <li><code>no_wrap</code> (Optional[bool], optional) \u2014 Disable word wrapping. Defaults to None.</li> <li><code>emoji</code> (Optional[bool], optional) \u2014 Enable emoji code, or <code>None</code> to use console default. Defaults to <code>None</code>.</li> <li><code>markup</code> (Optional[bool], optional) \u2014 Enable markup, or <code>None</code> to use console default. Defaults to <code>None</code>.</li> <li><code>highlight</code> (Optional[bool], optional) \u2014 Enable automatic highlighting, or <code>None</code> to use console default. Defaults to <code>None</code>.</li> <li><code>width</code> (Optional[int], optional) \u2014 Width of output, or <code>None</code> to auto-detect. Defaults to <code>None</code>.</li> <li><code>crop</code> (Optional[bool], optional) \u2014 Crop output to width of terminal. Defaults to True.</li> <li><code>soft_wrap</code> (bool, optional) \u2014 Enable soft wrap mode which disables word wrapping and cropping of text or <code>None</code> forConsole default. Defaults to <code>None</code>. </li> <li><code>new_line_start</code> (bool, False) \u2014 Insert a new line at the start if the output contains more than one line. Defaults to <code>False</code>.</li> </ul> method &lt;/&gt; <p>Pretty prints JSON. Output will be valid JSON.</p> Parameters <ul> <li><code>json</code> (Optional[str]) \u2014 A string containing JSON.</li> <li><code>data</code> (Any) \u2014 If json is not supplied, then encode this data.</li> <li><code>indent</code> (Union[None, int, str], optional) \u2014 Number of spaces to indent. Defaults to 2.</li> <li><code>highlight</code> (bool, optional) \u2014 Enable highlighting of output: Defaults to True.</li> <li><code>skip_keys</code> (bool, optional) \u2014 Skip keys not of a basic type. Defaults to False.</li> <li><code>ensure_ascii</code> (bool, optional) \u2014 Escape all non-ascii characters. Defaults to False.</li> <li><code>check_circular</code> (bool, optional) \u2014 Check for circular references. Defaults to True.</li> <li><code>allow_nan</code> (bool, optional) \u2014 Allow NaN and Infinity values. Defaults to True.</li> <li><code>default</code> (Callable, optional) \u2014 A callable that converts values that can not be encodedin to something that can be JSON encoded. Defaults to None. </li> <li><code>sort_keys</code> (bool, optional) \u2014 Sort dictionary keys. Defaults to False.</li> </ul> method &lt;/&gt; <p>Update the screen at a given offset.</p> Parameters <ul> <li><code>renderable</code> (RenderableType) \u2014 A Rich renderable.</li> <li><code>region</code> (Region, optional) \u2014 Region of screen to update, or None for entire screen. Defaults to None.</li> </ul> Raises <ul> <li><code>errors.NoAltScreen</code> \u2014 If the Console isn't in alt screen mode.</li> </ul> method &lt;/&gt; <p>Update lines of the screen at a given offset.</p> Parameters <ul> <li><code>lines</code> (List[List[Segment]]) \u2014 Rendered lines (as produced by :meth:<code>~rich.Console.render_lines</code>).</li> <li><code>x</code> (int, optional) \u2014 x offset (column no). Defaults to 0.</li> <li><code>y</code> (int, optional) \u2014 y offset (column no). Defaults to 0.</li> </ul> Raises <ul> <li><code>errors.NoAltScreen</code> \u2014 If the Console isn't in alt screen mode.</li> </ul> method &lt;/&gt; <p>Prints a rich render of the last exception and traceback.</p> Parameters <ul> <li><code>width</code> (Optional[int], optional) \u2014 Number of characters used to render code. Defaults to 100.</li> <li><code>extra_lines</code> (int, optional) \u2014 Additional lines of code to render. Defaults to 3.</li> <li><code>theme</code> (str, optional) \u2014 Override pygments theme used in traceback</li> <li><code>word_wrap</code> (bool, optional) \u2014 Enable word wrapping of long lines. Defaults to False.</li> <li><code>show_locals</code> (bool, optional) \u2014 Enable display of local variables. Defaults to False.</li> <li><code>suppress</code> (Iterable[Union[str, ModuleType]]) \u2014 Optional sequence of modules or paths to exclude from traceback.</li> <li><code>max_frames</code> (int) \u2014 Maximum number of frames to show in a traceback, 0 for no maximum. Defaults to 100.</li> </ul> method &lt;/&gt; <p>Log rich content to the terminal.</p> Parameters <ul> <li><code>sep</code> (str, optional) \u2014 String to write between print data. Defaults to \" \".</li> <li><code>end</code> (str, optional) \u2014 String to write at end of print data. Defaults to \"\\n\".</li> <li><code>style</code> (Union[str, Style], optional) \u2014 A style to apply to output. Defaults to None.</li> <li><code>justify</code> (str, optional) \u2014 One of \"left\", \"right\", \"center\", or \"full\". Defaults to <code>None</code>.</li> <li><code>emoji</code> (Optional[bool], optional) \u2014 Enable emoji code, or <code>None</code> to use console default. Defaults to None.</li> <li><code>markup</code> (Optional[bool], optional) \u2014 Enable markup, or <code>None</code> to use console default. Defaults to None.</li> <li><code>highlight</code> (Optional[bool], optional) \u2014 Enable automatic highlighting, or <code>None</code> to use console default. Defaults to None.</li> <li><code>log_locals</code> (bool, optional) \u2014 Boolean to enable logging of locals where <code>log()</code>was called. Defaults to False. </li> <li><code>_stack_offset</code> (int, optional) \u2014 Offset of caller from end of call stack. Defaults to 1.</li> </ul> method &lt;/&gt; <p>This function is called when a <code>BrokenPipeError</code> is raised.</p><p>This can occur when piping Textual output in Linux and macOS. The default implementation is to exit the app, but you could implement this method in a subclass to change the behavior.</p> <p>See https://docs.python.org/3/library/signal.html#note-on-sigpipe for details.</p> method &lt;/&gt; <p>Displays a prompt and waits for input from the user. The prompt may contain color / style.</p><p>It works in the same way as Python's builtin :func:<code>input</code> function and provides elaborate line editing and history features if Python's builtin :mod:<code>readline</code> module is previously loaded.</p> Parameters <ul> <li><code>prompt</code> (Union[str, Text]) \u2014 Text to render in the prompt.</li> <li><code>markup</code> (bool, optional) \u2014 Enable console markup (requires a str prompt). Defaults to True.</li> <li><code>emoji</code> (bool, optional) \u2014 Enable emoji (requires a str prompt). Defaults to True.</li> <li><code>password</code> (bool, optional) \u2014 (bool, optional): Hide typed text. Defaults to False.</li> <li><code>stream</code> (Optional, optional) \u2014 (TextIO, optional): Optional file to read input from (rather than stdin). Defaults to None.</li> </ul> Returns (str) <p>Text read from stdin.</p> method &lt;/&gt; <p>Generate text from console contents (requires record=True argument in constructor).</p> Parameters <ul> <li><code>clear</code> (bool, optional) \u2014 Clear record buffer after exporting. Defaults to <code>True</code>.</li> <li><code>styles</code> (bool, optional) \u2014 If <code>True</code>, ansi escape codes will be included. <code>False</code> for plain text.Defaults to <code>False</code>. </li> </ul> Returns (str) <p>String containing console contents.</p> method &lt;/&gt; <p>Generate text from console and save to a given location (requires record=True argument in constructor).</p> Parameters <ul> <li><code>path</code> (str) \u2014 Path to write text files.</li> <li><code>clear</code> (bool, optional) \u2014 Clear record buffer after exporting. Defaults to <code>True</code>.</li> <li><code>styles</code> (bool, optional) \u2014 If <code>True</code>, ansi style codes will be included. <code>False</code> for plain text.Defaults to <code>False</code>. </li> </ul> method &lt;/&gt; <p>Generate HTML from console contents (requires record=True argument in constructor).</p> Parameters <ul> <li><code>theme</code> (TerminalTheme, optional) \u2014 TerminalTheme object containing console colors.</li> <li><code>clear</code> (bool, optional) \u2014 Clear record buffer after exporting. Defaults to <code>True</code>.</li> <li><code>code_format</code> (str, optional) \u2014 Format string to render HTML. In addition to '{foreground}','{background}', and '{code}', should contain '{stylesheet}' if inline_styles is <code>False</code>. </li> <li><code>inline_styles</code> (bool, optional) \u2014 If <code>True</code> styles will be inlined in to spans, which makes fileslarger but easier to cut and paste markup. If <code>False</code>, styles will be embedded in a style tag. Defaults to False. </li> </ul> Returns (str) <p>String containing console contents as HTML.</p> method &lt;/&gt; <p>Generate HTML from console contents and write to a file (requires record=True argument in constructor).</p> Parameters <ul> <li><code>path</code> (str) \u2014 Path to write html file.</li> <li><code>theme</code> (TerminalTheme, optional) \u2014 TerminalTheme object containing console colors.</li> <li><code>clear</code> (bool, optional) \u2014 Clear record buffer after exporting. Defaults to <code>True</code>.</li> <li><code>code_format</code> (str, optional) \u2014 Format string to render HTML. In addition to '{foreground}','{background}', and '{code}', should contain '{stylesheet}' if inline_styles is <code>False</code>. </li> <li><code>inline_styles</code> (bool, optional) \u2014 If <code>True</code> styles will be inlined in to spans, which makes fileslarger but easier to cut and paste markup. If <code>False</code>, styles will be embedded in a style tag. Defaults to False. </li> </ul> method &lt;/&gt; <p>Generate an SVG from the console contents (requires record=True in Console constructor).</p> Parameters <ul> <li><code>title</code> (str, optional) \u2014 The title of the tab in the output image</li> <li><code>theme</code> (TerminalTheme, optional) \u2014 The <code>TerminalTheme</code> object to use to style the terminal</li> <li><code>clear</code> (bool, optional) \u2014 Clear record buffer after exporting. Defaults to <code>True</code></li> <li><code>code_format</code> (str, optional) \u2014 Format string used to generate the SVG. Rich will inject a number of variablesinto the string in order to form the final SVG output. The default template used and the variables injected by Rich can be found by inspecting the <code>console.CONSOLE_SVG_FORMAT</code> variable. </li> <li><code>font_aspect_ratio</code> (float, optional) \u2014 The width to height ratio of the font used in the <code>code_format</code>string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font). If you aren't specifying a different font inside <code>code_format</code>, you probably don't need this. </li> <li><code>unique_id</code> (str, optional) \u2014 unique id that is used as the prefix for various elements (CSS styles, nodeids). If not set, this defaults to a computed value based on the recorded content. </li> </ul> method &lt;/&gt; <p>Generate an SVG file from the console contents (requires record=True in Console constructor).</p> Parameters <ul> <li><code>path</code> (str) \u2014 The path to write the SVG to.</li> <li><code>title</code> (str, optional) \u2014 The title of the tab in the output image</li> <li><code>theme</code> (TerminalTheme, optional) \u2014 The <code>TerminalTheme</code> object to use to style the terminal</li> <li><code>clear</code> (bool, optional) \u2014 Clear record buffer after exporting. Defaults to <code>True</code></li> <li><code>code_format</code> (str, optional) \u2014 Format string used to generate the SVG. Rich will inject a number of variablesinto the string in order to form the final SVG output. The default template used and the variables injected by Rich can be found by inspecting the <code>console.CONSOLE_SVG_FORMAT</code> variable. </li> <li><code>font_aspect_ratio</code> (float, optional) \u2014 The width to height ratio of the font used in the <code>code_format</code>string. Defaults to 0.61, which is the width to height ratio of Fira Code (the default font). If you aren't specifying a different font inside <code>code_format</code>, you probably don't need this. </li> <li><code>unique_id</code> (str, optional) \u2014 unique id that is used as the prefix for various elements (CSS styles, nodeids). If not set, this defaults to a computed value based on the recorded content. </li> </ul> function &lt;/&gt; <p>Get the logger by given plugin name</p> Parameters <ul> <li><code>level</code> (str | int, optional) \u2014 The initial level of the logger</li> </ul> Returns (LoggerAdapter) <p>The logger</p> function &lt;/&gt; <p>Get the description from docstring</p><p>Only extract the summary.</p> Parameters <ul> <li><code>obj</code> (Type[Pipen | Proc]) \u2014 The object with docstring</li> </ul> Returns (str) <p>The summary as desc</p> function &lt;/&gt; <p>Update the new dict to the parent, but make sure parent does not change</p> Parameters <ul> <li><code>parent</code> (Mapping) \u2014 The parent dictionary</li> <li><code>new</code> (Mapping) \u2014 The new dictionary</li> <li><code>depth</code> (int, optional) \u2014 The depth to be copied. 0 for updating to the deepest level.</li> <li><code>try_list</code> (bool, optional) \u2014 If True, try to also update the dict in the list</li> </ul> Examples <pre><code>&gt;&gt;&gt; parent = {\"a\": {\"b\": 1}}&gt;&gt;&gt; new = {\"a\": {\"c\": 2}}\n&gt;&gt;&gt; update_dict(parent, new)\n&gt;&gt;&gt; # {\"a\": {\"b\": 1, \"c\": 2}}\n&gt;&gt;&gt; parent = {\"a\": [{\"b\": 1}]}\n&gt;&gt;&gt; new = {\"a\": [{\"c\": 2}]}\n&gt;&gt;&gt; update_dict(parent, new, try_list=True)\n&gt;&gt;&gt; # {\"a\": [{\"b\": 1, \"c\": 2}]}\n</code></pre> Returns (Mapping) <p>The updated dictionary or None if both parent and new are None.</p> function &lt;/&gt; <p>Deep copy a dict</p> Parameters <ul> <li><code>dic</code> (Mapping) \u2014 The dict to be copied</li> <li><code>depth</code> (int, optional) \u2014 The depth to be deep copied</li> </ul> Returns (Mapping) <p>The deep-copied dict</p> function &lt;/&gt; <p>Split the string, with the ability to trim each part.</p> function &lt;/&gt; <p>Get the shebang of the script</p> Parameters <ul> <li><code>script</code> (str) \u2014 The script string</li> </ul> Returns (str) <p>None if the script does not contain a shebang, otherwise the shebangwithout <code>#!</code> prefix</p> function &lt;/&gt; <p>Like textwrap.dedent(), but ignore first empty lines</p> Parameters <ul> <li><code>text</code> (str) \u2014 The text the be dedented</li> </ul> Returns (str) <p>The dedented text</p> function &lt;/&gt; <p>Get the width of the log content</p> Parameters <ul> <li><code>max_width</code> \u2014 The maximum width to returnNote that it's not the console width. With console width, you have to subtract the width of the log meta info (CONSOLE_WIDTH_SHIFT). </li> </ul> Returns (int) <p>The width of the log content</p> function &lt;/&gt; <p>Log a rich renderable to logger</p> Parameters <ul> <li><code>renderable</code> (RenderableType) \u2014 The rich renderable</li> <li><code>logfunc</code> (Callable) \u2014 The log function, if message is not the first argument,use functools.partial to wrap it </li> <li><code>*args</code> (Any) \u2014 The arguments to the log function</li> <li><code>**kwargs</code> (Any) \u2014 The keyword arguments to the log function</li> <li><code>splitline</code> \u2014 Whether split the lines or log the entire message</li> </ul> function &lt;/&gt; <p>Briefly show an integer list, combine the continuous numbers.</p> Parameters <ul> <li><code>blist</code> (List) \u2014 The list</li> </ul> Returns (str) <p>The string to show for the briefed list.</p> function &lt;/&gt; <p>The banner for pipen</p> Returns (RenderableType) <p>The banner renderable</p> function &lt;/&gt; <p>Get the modification time of a path.If path is a directory, try to get the last modification time of the contents in the directory at given dir_depth</p> Parameters <ul> <li><code>dir_depth</code> (int, optional) \u2014 The depth of the directory to check thelast modification time </li> </ul> Returns (float) <p>The last modification time of path</p> function &lt;/&gt; <p>Tell if obj is a subclass of clsDifferences with issubclass is that we don't raise Type error if obj is not a class</p> Parameters <ul> <li><code>obj</code> (Any) \u2014 The object to check</li> <li><code>cls</code> (type) \u2014 The class to check</li> </ul> Returns (bool) <p>True if obj is a subclass of cls otherwise False</p> generator &lt;/&gt; <p>Load objects from setuptools entrypoints by given group name</p> Parameters <ul> <li><code>group</code> (str) \u2014 The group name of the entrypoints</li> </ul> Returns (Iterable) <p>An iterable of tuples with name and the loaded object</p> function &lt;/&gt; <p>Truncate a text not based on words/whitespacesOtherwise, we could use textwrap.shorten.</p> Parameters <ul> <li><code>text</code> (str) \u2014 The text to be truncated</li> <li><code>width</code> (int) \u2014 The max width of the the truncated text</li> <li><code>end</code> (str, optional) \u2014 The end string of the truncated text</li> </ul> Returns (str) <p>The truncated text with end appended.</p> function &lt;/&gt; <p>Make the columns of a data frame unique</p> Parameters <ul> <li><code>thedf</code> (pandas.DataFrame) \u2014 The data frame</li> </ul> function &lt;/&gt; <p>Get the base class where the value was first defined</p> Parameters <ul> <li><code>klass</code> (Type) \u2014 The class</li> <li><code>abc_base</code> (Type) \u2014 The very base class to check in bases</li> <li><code>value</code> (Any) \u2014 The value to check</li> <li><code>value_getter</code> (Callable) \u2014 How to get the value from the class</li> </ul> Returns (Type) <p>The base class</p> function &lt;/&gt; <p>Mark a class (e.g. Proc) with given kwargs as metadata</p><p>These marks will not be inherited by the subclasses if the class is a subclass of <code>Proc</code> or <code>ProcGroup</code>.</p> Parameters <ul> <li><code>**kwargs</code> \u2014 The kwargs to mark the proc</li> </ul> Returns (Callable) <p>The decorator</p> function &lt;/&gt; <p>Get the marked value from a proc</p> Parameters <ul> <li><code>cls</code> (type) \u2014 The proc</li> <li><code>mark_name</code> (str) \u2014 The mark name</li> <li><code>default</code> (Any, optional) \u2014 The default value if the mark is not found</li> </ul> Returns (Any) <p>The marked value</p> function &lt;/&gt; <p>Check if a name is valid for a proc or pipen</p> Parameters <ul> <li><code>name</code> (str) \u2014 The name to check</li> </ul> Returns (bool) <p>True if valid, otherwise False</p> function &lt;/&gt; <p>Load a pipeline from a Pipen, Proc or ProcGroup object</p><p>It does not only load the Pipen object or convert the Proc/ProcGroup object to Pipen, but also build the process relationships. So that we can access <code>pipeline.procs</code> and <code>requires/nexts</code> of each proc.</p> <p>To avoid running the pipeline and notify the plugins that this is just for loading the pipeline, <code>sys.argv[0]</code> is set to <code>@pipen</code>.</p> Parameters <ul> <li><code>obj</code> (str | Type[Proc] | Type[ProcGroup] | Type[Pipen] | Pipen) \u2014 The Pipen, Proc or ProcGroup object. It can also be a string inthe format of <code>part1:part2</code> to load the pipeline, where part1 is a path to a python file or package directory, and part2 is the name of the proc, procgroup or pipeline to load. It should be able to be loaded by <code>getattr(module, part2)</code>, where module is loaded from <code>part1</code>. </li> <li><code>argv0</code> (str | none, optional) \u2014 The value to replace sys.argv[0]. \"@pipen\" will be usedby default. </li> <li><code>argv1p</code> (Optional, optional) \u2014 The values to replace sys.argv[1:]. Do not replace by default.</li> <li><code>kwargs</code> \u2014 The kwargs to pass to the Pipen constructor</li> </ul> Returns (Pipen) <p>The loaded Pipen object</p> Raises <ul> <li><code>TypeError</code> \u2014 If obj or loaded obj is not a Pipen, Proc or ProcGroup</li> </ul> function &lt;/&gt; <p>Check if we are loading the pipeline. Works only when<code>argv0</code> is \"@pipen\" while loading the pipeline.</p> <p>Note if you are using this function at compile time, make sure you load your pipeline using the string form (<code>part1:part2</code>) See more with <code>load_pipline()</code>.</p> Parameters <ul> <li><code>*flags</code> (str) \u2014 Additional flags to check in sys.argv (e.g. \"-h\", \"--help\")to determine if we are loading the pipeline </li> <li><code>argv</code> (Optional, optional) \u2014 The arguments to check. sys.argv is used by default.Note that the first argument should be included in the check. You could typically pass <code>[sys.argv[0], *your_args]</code> to this if you want to check if <code>sys.argv[0]</code> is \"@pipen\" or <code>your_args</code> contains some flags. </li> </ul> Returns (bool) <p>True if we are loading the pipeline (argv[0] == \"@pipen\"),otherwise False</p> function &lt;/&gt; <p>Check if a path is a symlink.</p><p>CloudPath.is_symlink() is not implemented yet, so we need to check it manually.</p> Parameters <ul> <li><code>path</code> (pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The path to check</li> </ul> Returns (bool) <p>True if the path is a symlink, otherwise False</p> function &lt;/&gt; <p>Create a symbolic link pointing to src named dst.</p> Parameters <ul> <li><code>src</code> (pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The source path</li> <li><code>dst</code> (pathlib.path | cloudpathlib.cloudpath.cloudpath) \u2014 The destination path</li> <li><code>target_is_directory</code> (bool, optional) \u2014 If True, the symbolic link will be to a directory.</li> </ul>"},{"location":"api/pipen.utils/#pipenutils","title":"pipen.utils","text":""},{"location":"api/pipen.utils/#pipenutilsrichhandler","title":"<code>pipen.utils.</code><code>RichHandler</code><code>(</code><code>level=0</code>, <code>console=None</code>, <code>show_time=True</code>, <code>omit_repeated_times=True</code>, <code>show_level=True</code>, <code>show_path=True</code>, <code>enable_link_path=True</code>, <code>highlighter=None</code>, <code>markup=False</code>, <code>rich_tracebacks=False</code>, <code>tracebacks_width=None</code>, <code>tracebacks_code_width=88</code>, <code>tracebacks_extra_lines=3</code>, <code>tracebacks_theme=None</code>, <code>tracebacks_word_wrap=True</code>, <code>tracebacks_show_locals=False</code>, <code>tracebacks_suppress=()</code>, <code>tracebacks_max_frames=100</code>, <code>locals_max_length=10</code>, <code>locals_max_string=80</code>, <code>log_time_format='[%x %X]'</code>, <code>keywords=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#loggingfiltereraddfilter","title":"<code>addFilter</code><code>(</code><code>filter</code><code>)</code>","text":""},{"location":"api/pipen.utils/#loggingfiltererremovefilter","title":"<code>removeFilter</code><code>(</code><code>filter</code><code>)</code>","text":""},{"location":"api/pipen.utils/#loggingfiltererfilter","title":"<code>filter</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlercreatelock","title":"<code>createLock</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandleracquire","title":"<code>acquire</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlerrelease","title":"<code>release</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlersetlevel","title":"<code>setLevel</code><code>(</code><code>level</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlerformat","title":"<code>format</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlerhandle","title":"<code>handle</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlersetformatter","title":"<code>setFormatter</code><code>(</code><code>fmt</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlerflush","title":"<code>flush</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlerclose","title":"<code>close</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#logginghandlerhandleerror","title":"<code>handleError</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richloggingrichhandleremit","title":"<code>emit</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richloggingrichhandlerrender_message","title":"<code>render_message</code><code>(</code><code>record</code>, <code>message</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richloggingrichhandlerrender","title":"<code>render</code><code>(</code><code>record</code>, <code>traceback</code>, <code>message_renderable</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsrichhandlerget_level_text","title":"<code>get_level_text</code><code>(</code><code>record</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsrichconsole","title":"<code>pipen.utils.</code><code>RichConsole</code><code>(</code><code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleset_live","title":"<code>set_live</code><code>(</code><code>live</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleclear_live","title":"<code>clear_live</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolepush_render_hook","title":"<code>push_render_hook</code><code>(</code><code>hook</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolepop_render_hook","title":"<code>pop_render_hook</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleenter","title":"<code>__enter__</code><code>(</code><code>)</code> \u2192 Console","text":""},{"location":"api/pipen.utils/#richconsoleconsoleexit","title":"<code>__exit__</code><code>(</code><code>exc_type</code>, <code>exc_value</code>, <code>traceback</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolebegin_capture","title":"<code>begin_capture</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleend_capture","title":"<code>end_capture</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolepush_theme","title":"<code>push_theme</code><code>(</code><code>theme</code>, <code>inherit=True</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolepop_theme","title":"<code>pop_theme</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleuse_theme","title":"<code>use_theme</code><code>(</code><code>theme</code>, <code>inherit=True</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolebell","title":"<code>bell</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolecapture","title":"<code>capture</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolepager","title":"<code>pager</code><code>(</code><code>pager=None</code>, <code>styles=False</code>, <code>links=False</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleline","title":"<code>line</code><code>(</code><code>count=1</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleclear","title":"<code>clear</code><code>(</code><code>home=True</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolestatus","title":"<code>status</code><code>(</code><code>status</code>, <code>spinner='dots'</code>, <code>spinner_style='status.spinner'</code>, <code>speed=1.0</code>, <code>refresh_per_second=12.5</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleshow_cursor","title":"<code>show_cursor</code><code>(</code><code>show=True</code><code>)</code> \u2192 bool","text":""},{"location":"api/pipen.utils/#richconsoleconsoleset_alt_screen","title":"<code>set_alt_screen</code><code>(</code><code>enable=True</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleset_window_title","title":"<code>set_window_title</code><code>(</code><code>title</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolescreen","title":"<code>screen</code><code>(</code><code>hide_cursor=True</code>, <code>style=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolemeasure","title":"<code>measure</code><code>(</code><code>renderable</code>, <code>options=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolerender","title":"<code>render</code><code>(</code><code>renderable</code>, <code>options=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolerender_lines","title":"<code>render_lines</code><code>(</code><code>renderable</code>, <code>options=None</code>, <code>style=None</code>, <code>pad=True</code>, <code>new_lines=False</code><code>)</code> \u2192 List","text":""},{"location":"api/pipen.utils/#richconsoleconsolerender_str","title":"<code>render_str</code><code>(</code><code>text</code>, <code>style=''</code>, <code>justify=None</code>, <code>overflow=None</code>, <code>emoji=None</code>, <code>markup=None</code>, <code>highlight=None</code>, <code>highlighter=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleget_style","title":"<code>get_style</code><code>(</code><code>name</code>, <code>default=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolerule","title":"<code>rule</code><code>(</code><code>title=''</code>, <code>characters='\u2500'</code>, <code>style='rule.line'</code>, <code>align='center'</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolecontrol","title":"<code>control</code><code>(</code><code>*control</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleout","title":"<code>out</code><code>(</code><code>*objects</code>, <code>sep=' '</code>, <code>end='\\n'</code>, <code>style=None</code>, <code>highlight=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleprint","title":"<code>print</code><code>(</code><code>*objects</code>, <code>sep=' '</code>, <code>end='\\n'</code>, <code>style=None</code>, <code>justify=None</code>, <code>overflow=None</code>, <code>no_wrap=None</code>, <code>emoji=None</code>, <code>markup=None</code>, <code>highlight=None</code>, <code>width=None</code>, <code>height=None</code>, <code>crop=True</code>, <code>soft_wrap=None</code>, <code>new_line_start=False</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleprint_json","title":"<code>print_json</code><code>(</code><code>json=None</code>, <code>data=None</code>, <code>indent=2</code>, <code>highlight=True</code>, <code>skip_keys=False</code>, <code>ensure_ascii=False</code>, <code>check_circular=True</code>, <code>allow_nan=True</code>, <code>default=None</code>, <code>sort_keys=False</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleupdate_screen","title":"<code>update_screen</code><code>(</code><code>renderable</code>, <code>region=None</code>, <code>options=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleupdate_screen_lines","title":"<code>update_screen_lines</code><code>(</code><code>lines</code>, <code>x=0</code>, <code>y=0</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleprint_exception","title":"<code>print_exception</code><code>(</code><code>width=100</code>, <code>extra_lines=3</code>, <code>theme=None</code>, <code>word_wrap=False</code>, <code>show_locals=False</code>, <code>suppress=()</code>, <code>max_frames=100</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolelog","title":"<code>log</code><code>(</code><code>*objects</code>, <code>sep=' '</code>, <code>end='\\n'</code>, <code>style=None</code>, <code>justify=None</code>, <code>emoji=None</code>, <code>markup=None</code>, <code>highlight=None</code>, <code>log_locals=False</code>, <code>_stack_offset=1</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleon_broken_pipe","title":"<code>on_broken_pipe</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleinput","title":"<code>input</code><code>(</code><code>prompt=''</code>, <code>markup=True</code>, <code>emoji=True</code>, <code>password=False</code>, <code>stream=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleexport_text","title":"<code>export_text</code><code>(</code><code>clear=True</code>, <code>styles=False</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolesave_text","title":"<code>save_text</code><code>(</code><code>path</code>, <code>clear=True</code>, <code>styles=False</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleexport_html","title":"<code>export_html</code><code>(</code><code>theme=None</code>, <code>clear=True</code>, <code>code_format=None</code>, <code>inline_styles=False</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsolesave_html","title":"<code>save_html</code><code>(</code><code>path</code>, <code>theme=None</code>, <code>clear=True</code>, <code>code_format='&lt;!DOCTYPE html&gt;\\n&lt;html&gt;\\n&lt;head&gt;\\n&lt;meta charset=\"UTF-8\"&gt;\\n&lt;style&gt;\\n{stylesheet}\\nbody {{\\n    color: {foreground};\\n    background-color: {background};\\n}}\\n&lt;/style&gt;\\n&lt;/head&gt;\\n&lt;body&gt;\\n    &lt;pre style=\"font-family:Menlo,\\'DejaVu Sans Mono\\',consolas,\\'Courier New\\',monospace\"&gt;&lt;code style=\"font-family:inherit\"&gt;{code}&lt;/code&gt;&lt;/pre&gt;\\n&lt;/body&gt;\\n&lt;/html&gt;\\n'</code>, <code>inline_styles=False</code><code>)</code>","text":""},{"location":"api/pipen.utils/#richconsoleconsoleexport_svg","title":"<code>export_svg</code><code>(</code><code>title='Rich'</code>, <code>theme=None</code>, <code>clear=True</code>, <code>code_format='&lt;svg class=\"rich-terminal\" viewBox=\"0 0 {width} {height}\" xmlns=\"http://www.w3.org/2000/svg\"&gt;\\n    &lt;!-- Generated with Rich https://www.textualize.io --&gt;\\n    &lt;style&gt;\\n\\n    @font-face {{\\n        font-family: \"Fira Code\";\\n        src: local(\"FiraCode-Regular\"),\\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Regular.woff2\") format(\"woff2\"),\\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Regular.woff\") format(\"woff\");\\n        font-style: normal;\\n        font-weight: 400;\\n    }}\\n    @font-face {{\\n        font-family: \"Fira Code\";\\n        src: local(\"FiraCode-Bold\"),\\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Bold.woff2\") format(\"woff2\"),\\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Bold.woff\") format(\"woff\");\\n        font-style: bold;\\n        font-weight: 700;\\n    }}\\n\\n    .{unique_id}-matrix {{\\n        font-family: Fira Code, monospace;\\n        font-size: {char_height}px;\\n        line-height: {line_height}px;\\n        font-variant-east-asian: full-width;\\n    }}\\n\\n    .{unique_id}-title {{\\n        font-size: 18px;\\n        font-weight: bold;\\n        font-family: arial;\\n    }}\\n\\n    {styles}\\n    &lt;/style&gt;\\n\\n    &lt;defs&gt;\\n    &lt;clipPath id=\"{unique_id}-clip-terminal\"&gt;\\n      &lt;rect x=\"0\" y=\"0\" width=\"{terminal_width}\" height=\"{terminal_height}\" /&gt;\\n    &lt;/clipPath&gt;\\n    {lines}\\n    &lt;/defs&gt;\\n\\n    {chrome}\\n    &lt;g transform=\"translate({terminal_x}, {terminal_y})\" clip-path=\"url(#{unique_id}-clip-terminal)\"&gt;\\n    {backgrounds}\\n    &lt;g class=\"{unique_id}-matrix\"&gt;\\n    {matrix}\\n    &lt;/g&gt;\\n    &lt;/g&gt;\\n&lt;/svg&gt;\\n'</code>, <code>font_aspect_ratio=0.61</code>, <code>unique_id=None</code><code>)</code> \u2192 str","text":""},{"location":"api/pipen.utils/#richconsoleconsolesave_svg","title":"<code>save_svg</code><code>(</code><code>path</code>, <code>title='Rich'</code>, <code>theme=None</code>, <code>clear=True</code>, <code>code_format='&lt;svg class=\"rich-terminal\" viewBox=\"0 0 {width} {height}\" xmlns=\"http://www.w3.org/2000/svg\"&gt;\\n    &lt;!-- Generated with Rich https://www.textualize.io --&gt;\\n    &lt;style&gt;\\n\\n    @font-face {{\\n        font-family: \"Fira Code\";\\n        src: local(\"FiraCode-Regular\"),\\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Regular.woff2\") format(\"woff2\"),\\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Regular.woff\") format(\"woff\");\\n        font-style: normal;\\n        font-weight: 400;\\n    }}\\n    @font-face {{\\n        font-family: \"Fira Code\";\\n        src: local(\"FiraCode-Bold\"),\\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Bold.woff2\") format(\"woff2\"),\\n                url(\"https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Bold.woff\") format(\"woff\");\\n        font-style: bold;\\n        font-weight: 700;\\n    }}\\n\\n    .{unique_id}-matrix {{\\n        font-family: Fira Code, monospace;\\n        font-size: {char_height}px;\\n        line-height: {line_height}px;\\n        font-variant-east-asian: full-width;\\n    }}\\n\\n    .{unique_id}-title {{\\n        font-size: 18px;\\n        font-weight: bold;\\n        font-family: arial;\\n    }}\\n\\n    {styles}\\n    &lt;/style&gt;\\n\\n    &lt;defs&gt;\\n    &lt;clipPath id=\"{unique_id}-clip-terminal\"&gt;\\n      &lt;rect x=\"0\" y=\"0\" width=\"{terminal_width}\" height=\"{terminal_height}\" /&gt;\\n    &lt;/clipPath&gt;\\n    {lines}\\n    &lt;/defs&gt;\\n\\n    {chrome}\\n    &lt;g transform=\"translate({terminal_x}, {terminal_y})\" clip-path=\"url(#{unique_id}-clip-terminal)\"&gt;\\n    {backgrounds}\\n    &lt;g class=\"{unique_id}-matrix\"&gt;\\n    {matrix}\\n    &lt;/g&gt;\\n    &lt;/g&gt;\\n&lt;/svg&gt;\\n'</code>, <code>font_aspect_ratio=0.61</code>, <code>unique_id=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsget_logger","title":"<code>pipen.utils.</code><code>get_logger</code><code>(</code><code>name='core'</code>, <code>level=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsdesc_from_docstring","title":"<code>pipen.utils.</code><code>desc_from_docstring</code><code>(</code><code>obj</code>, <code>base</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsupdate_dict","title":"<code>pipen.utils.</code><code>update_dict</code><code>(</code><code>parent</code>, <code>new</code>, <code>depth=0</code>, <code>try_list=False</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilscopy_dict","title":"<code>pipen.utils.</code><code>copy_dict</code><code>(</code><code>dic</code>, <code>depth=1</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsstrsplit","title":"<code>pipen.utils.</code><code>strsplit</code><code>(</code><code>string</code>, <code>sep</code>, <code>maxsplit=-1</code>, <code>trim='both'</code><code>)</code> \u2192 List","text":""},{"location":"api/pipen.utils/#pipenutilsget_shebang","title":"<code>pipen.utils.</code><code>get_shebang</code><code>(</code><code>script</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsignore_firstline_dedent","title":"<code>pipen.utils.</code><code>ignore_firstline_dedent</code><code>(</code><code>text</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsget_logpanel_width","title":"<code>pipen.utils.</code><code>get_logpanel_width</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilslog_rich_renderable","title":"<code>pipen.utils.</code><code>log_rich_renderable</code><code>(</code><code>renderable</code>, <code>color</code>, <code>logfunc</code>, <code>*args</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsbrief_list","title":"<code>pipen.utils.</code><code>brief_list</code><code>(</code><code>blist</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilspipen_banner","title":"<code>pipen.utils.</code><code>pipen_banner</code><code>(</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsget_mtime","title":"<code>pipen.utils.</code><code>get_mtime</code><code>(</code><code>path</code>, <code>dir_depth=1</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsis_subclass","title":"<code>pipen.utils.</code><code>is_subclass</code><code>(</code><code>obj</code>, <code>cls</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsload_entrypoints","title":"<code>pipen.utils.</code><code>load_entrypoints</code><code>(</code><code>group</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilstruncate_text","title":"<code>pipen.utils.</code><code>truncate_text</code><code>(</code><code>text</code>, <code>width</code>, <code>end='\u2026'</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsmake_df_colnames_unique_inplace","title":"<code>pipen.utils.</code><code>make_df_colnames_unique_inplace</code><code>(</code><code>thedf</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsget_base","title":"<code>pipen.utils.</code><code>get_base</code><code>(</code><code>klass</code>, <code>abc_base</code>, <code>value</code>, <code>value_getter</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsmark","title":"<code>pipen.utils.</code><code>mark</code><code>(</code><code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsget_marked","title":"<code>pipen.utils.</code><code>get_marked</code><code>(</code><code>cls</code>, <code>mark_name</code>, <code>default=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsis_valid_name","title":"<code>pipen.utils.</code><code>is_valid_name</code><code>(</code><code>name</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsload_pipeline","title":"<code>pipen.utils.</code><code>load_pipeline</code><code>(</code><code>obj</code>, <code>argv0=None</code>, <code>argv1p=None</code>, <code>**kwargs</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilsis_loading_pipeline","title":"<code>pipen.utils.</code><code>is_loading_pipeline</code><code>(</code><code>*flags</code>, <code>argv=None</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilspath_is_symlink","title":"<code>pipen.utils.</code><code>path_is_symlink</code><code>(</code><code>path</code><code>)</code>","text":""},{"location":"api/pipen.utils/#pipenutilspath_symlink_to","title":"<code>pipen.utils.</code><code>path_symlink_to</code><code>(</code><code>src</code>, <code>dst</code>, <code>target_is_directory=False</code><code>)</code>","text":""},{"location":"api/pipen.version/","title":"pipen.version","text":"module &lt;/&gt; <p>Provide version of pipen</p>"},{"location":"api/pipen.version/#pipenversion","title":"pipen.version","text":""},{"location":"api/source/pipen.channel/","title":"pipen.channel","text":""},{"location":"api/source/pipen.channel/","title":"SOURCE CODE pipen.channel DOCS","text":"<pre><code>\"\"\"Provide some function for creating and modifying channels (dataframes)\"\"\"\n\nfrom __future__ import annotations\n\nfrom glob import glob\nfrom os import path\nfrom itertools import chain\nfrom pathlib import Path\nfrom typing import Any, List\n\nimport pandas\nfrom yunpath import AnyPath, CloudPath\nfrom pandas import DataFrame\nfrom pipda import register_verb\n\nfrom .utils import path_is_symlink\n\n\n# ----------------------------------------------------------------\n# Creators\nclass Channel(DataFrame):DOCS\n    \"\"\"A DataFrame wrapper with creators\"\"\"\n\n    @classmethodDOCS\n    def create(cls, value: DataFrame | List[Any]) -&gt; DataFrame:\n        \"\"\"Create a channel from a list.\n\n        The second dimension is identified by tuple. if all elements are tuple,\n        then a channel is created directly. Otherwise, elements are converted\n        to tuples first and channels are created then.\n\n        Examples:\n            &gt;&gt;&gt; Channel.create([1, 2, 3]) # 3 rows, 1 column\n            &gt;&gt;&gt; Channel.create([(1,2,3)]) # 1 row, 3 columns\n\n        Args:\n            value: The value to create a channel\n\n        Returns:\n            A channel (dataframe)\n        \"\"\"\n        if isinstance(value, DataFrame):\n            return value\n        if all(isinstance(elem, tuple) for elem in value):\n            return cls(value)\n        return cls((val,) for val in value)\n\n    @classmethodDOCS\n    def from_glob(\n        cls,\n        pattern: str,\n        ftype: str = \"any\",\n        sortby: str = \"name\",\n        reverse: bool = False,\n    ) -&gt; DataFrame:\n        \"\"\"Create a channel with a glob pattern\n\n        Args:\n            ftype: The file type, one of any, link, dir and file\n            sortby: How the files should be sorted. One of name, mtime and size\n            reverse: Whether sort them in a reversed way.\n\n        Returns:\n            The channel\n        \"\"\"\n\n        def sort_key(file: Path | CloudPath) -&gt; Any:\n            if sortby == \"mtime\":\n                return file.stat().st_mtime\n            if sortby == \"size\":\n                return file.stat().st_size\n\n            return str(file)  # sort by name\n\n        def file_filter(file: Path | CloudPath) -&gt; bool:\n            if ftype == \"link\":\n                return path_is_symlink(file)\n            if ftype == \"dir\":\n                return file.is_dir()\n            if ftype == \"file\":\n                return file.is_file()\n            return True\n\n        pattern: Path | CloudPath = AnyPath(pattern)\n        if isinstance(pattern, CloudPath):\n            parts = pattern.parts\n            bucket = CloudPath(\"\".join(parts[:2]))  # gs://bucket\n            # CloudPath.glob() does not support a/b/*.txt\n            # we have to do it part by part\n            parts = parts[2:]\n            files = [bucket]\n            for i, part in enumerate(parts):\n                tmp = chain(*[base.glob(part) for base in files])\n                tmp = list(tmp)\n                files = [\n                    base for base in tmp\n                    if (i &lt; len(parts) - 1 and base.is_dir())\n                    or (i == len(parts) - 1 and file_filter(base))\n                ]\n        else:  # local path\n            files = (\n                Path(file) for file in glob(str(pattern)) if file_filter(Path(file))\n            )\n\n        return cls.create(\n            [\n                str(file)\n                for file in sorted(\n                    files,\n                    key=sort_key if sortby in (\"name\", \"mtime\", \"size\") else None,\n                    reverse=reverse,\n                )  # type: ignore\n            ]\n        )\n\n    @classmethodDOCS\n    def from_pairs(\n        cls,\n        pattern: str,\n        ftype: str = \"any\",\n        sortby: str = \"name\",\n        reverse: bool = False,\n    ) -&gt; DataFrame:\n        \"\"\"Create a width=2 channel with a glob pattern\n\n        Args:\n            ftype: The file type, one of any, link, dir and file\n            sortby: How the files should be sorted. One of name, mtime and size\n            reverse: Whether sort them in a reversed way.\n\n        Returns:\n            The channel\n        \"\"\"\n        mates = cls.from_glob(pattern, ftype, sortby, reverse)\n        return pandas.concat(\n            (\n                mates.iloc[::2].reset_index(drop=True),\n                mates.iloc[1::2].reset_index(drop=True),\n            ),\n            axis=1,\n        )\n\n    @classmethodDOCS\n    def from_csv(cls, *args, **kwargs):\n        \"\"\"Create a channel from a csv file\n\n        Uses pandas.read_csv() to create a channel\n\n        Args:\n            *args: and\n            **kwargs: Arguments passing to pandas.read_csv()\n        \"\"\"\n        return pandas.read_csv(*args, **kwargs)\n\n    @classmethodDOCS\n    def from_excel(cls, *args, **kwargs):\n        \"\"\"Create a channel from an excel file.\n\n        Uses pandas.read_excel() to create a channel\n\n        Args:\n            *args: and\n            **kwargs: Arguments passing to pandas.read_excel()\n        \"\"\"\n        return pandas.read_excel(*args, **kwargs)\n\n    @classmethodDOCS\n    def from_table(cls, *args, **kwargs):\n        \"\"\"Create a channel from a table file.\n\n        Uses pandas.read_table() to create a channel\n\n        Args:\n            *args: and\n            **kwargs: Arguments passing to pandas.read_table()\n        \"\"\"\n        return pandas.read_table(*args, **kwargs)\n\n\n# ----------------------------------------------------------------\n# Verbs\n@register_verb(DataFrame)DOCS\ndef expand_dir(\n    data: DataFrame,\n    col: str | int = 0,\n    pattern: str = \"*\",\n    ftype: str = \"any\",\n    sortby: str = \"name\",\n    reverse: bool = False,\n) -&gt; DataFrame:\n    \"\"\"Expand a Channel according to the files in &lt;col&gt;,\n    other cols will keep the same.\n\n    This is only applicable to a 1-row channel.\n\n    Examples:\n        &gt;&gt;&gt; ch = channel.create([('./', 1)])\n        &gt;&gt;&gt; ch &gt;&gt; expand()\n        &gt;&gt;&gt; [['./a', 1], ['./b', 1], ['./c', 1]]\n\n    Args:\n        col: the index or name of the column used to expand\n        pattern: use a pattern to filter the files/dirs, default: `*`\n        ftype: the type of the files/dirs to include\n            - 'dir', 'file', 'link' or 'any' (default)\n        sortby:  how the list is sorted\n            - 'name' (default), 'mtime', 'size'\n        reverse: reverse sort.\n\n    Returns:\n        The expanded channel\n    \"\"\"\n    assert data.shape[0] == 1, \"Can only expand a single row DataFrame.\"\n    col_loc = col if isinstance(col, int) else data.columns.get_loc(col)\n    full_pattern = f\"{data.iloc[0, col_loc]}/{pattern}\"\n    expanded = Channel.from_glob(\n        full_pattern,\n        ftype,\n        sortby,\n        reverse,\n    ).iloc[:, 0]\n    ret = pandas.concat([data] * expanded.size, axis=0, ignore_index=True)\n    ret.iloc[:, col_loc] = expanded.values\n    return ret.reset_index(drop=True)\n\n\n@register_verb(DataFrame)DOCS\ndef collapse_files(data: DataFrame, col: str | int = 0) -&gt; DataFrame:\n    \"\"\"Collapse a Channel according to the files in &lt;col&gt;,\n    other cols will use the values in row 0.\n\n    Note that other values in other rows will be discarded.\n\n    Examples:\n        &gt;&gt;&gt; ch = channel.create([['./a', 1], ['./b', 1], ['./c', 1]])\n        &gt;&gt;&gt; ch &gt;&gt; collapse()\n        &gt;&gt;&gt; [['.', 1]]\n\n    Args:\n        data: The original channel\n        col: the index or name of the column used to collapse on\n\n    Returns:\n        The collapsed channel\n    \"\"\"\n    assert data.shape[0] &gt; 0, \"Cannot collapse on an empty DataFrame.\"\n    col_loc = col if isinstance(col, int) else data.columns.get_loc(col)\n    paths = list(data.iloc[:, col_loc])\n    compx = path.dirname(path.commonprefix(paths))\n    ret = data.iloc[[0], :].copy()\n    ret.iloc[0, col_loc] = compx\n    return ret\n</code></pre>"},{"location":"api/source/pipen.cli.help/","title":"pipen.cli.help","text":""},{"location":"api/source/pipen.cli.help/","title":"SOURCE CODE pipen.cli.help DOCS","text":"<pre><code>\"\"\"Print help for commands\"\"\"\nfrom __future__ import annotations\nfrom typing import TYPE_CHECKING\n\nfrom ._hooks import CLIPlugin\n\nif TYPE_CHECKING:\n    from argx import ArgumentParser\n    from argparse import Namespace\n\n__all__ = (\"CLIHelpPlugin\",)\n\n\nclass CLIHelpPlugin(CLIPlugin):DOCS\n    \"\"\"Print help for commands\"\"\"\n\n    name = \"help\"\n\n    def __init__(self, parser: ArgumentParser, subparser: ArgumentParser):\n        super().__init__(parser, subparser)\n        subparser.add_argument(\n            \"cmd\",\n            nargs=\"?\",\n            choices=[\n                n\n                for n in parser._subparsers._group_actions[0].choices\n                if n != \"help\"\n            ],\n            help=\"The command to show help for\",\n        )\n\n    def exec_command(self, args: Namespace) -&gt; None:DOCS\n        \"\"\"Run the command\"\"\"\n\n        if not args.cmd:\n            self.parser.parse_args([\"--help\"])\n        else:\n            self.parser.parse_args([args.cmd, \"--help\"])\n</code></pre>"},{"location":"api/source/pipen.cli/","title":"pipen.cli","text":""},{"location":"api/source/pipen.cli/","title":"SOURCE CODE pipen.cli DOCS","text":"<pre><code>\"\"\"Provide CLI for pipen\"\"\"\n\nfrom ._hooks import CLIPlugin\nfrom ._main import main\n</code></pre>"},{"location":"api/source/pipen.cli.plugins/","title":"pipen.cli.plugins","text":""},{"location":"api/source/pipen.cli.plugins/","title":"SOURCE CODE pipen.cli.plugins DOCS","text":"<pre><code>\"\"\"List plugins\"\"\"\nfrom __future__ import annotations\nfrom typing import TYPE_CHECKING, Any, Iterable, List, Tuple\n\nfrom rich import print\n\nfrom ._hooks import CLIPlugin\nfrom ..defaults import (\n    CLI_ENTRY_GROUP,\n    SCHEDULER_ENTRY_GROUP,\n    TEMPLATE_ENTRY_GROUP,\n)\nfrom ..utils import load_entrypoints\n\nif TYPE_CHECKING:\n    from argx import ArgumentParser\n    from argparse import Namespace\n\n\nCOMMAND = \"plugins\"\nGROUPS = [\n    \"pipen\",\n    SCHEDULER_ENTRY_GROUP,\n    TEMPLATE_ENTRY_GROUP,\n    CLI_ENTRY_GROUP,\n]\nGROUP_NAMES = {\n    \"pipen\": \"Pipen\",\n    SCHEDULER_ENTRY_GROUP: \"Scheduler\",\n    TEMPLATE_ENTRY_GROUP: \"Template\",\n    CLI_ENTRY_GROUP: \"CLI\",\n}\n\n__all__ = (\"CliPluginsPlugin\",)\n\n\ndef _get_plugins_by_group(group: str) -&gt; Iterable[Tuple[str, Any]]:\n    \"\"\"Get plugins from entry points by group name\n\n    Args:\n        group: The name of the group\n\n    Returns:\n        A list of tuples with the plugin name and the plugin itself\n    \"\"\"\n    for name, obj in load_entrypoints(group):\n        yield name, obj\n\n\ndef _list_group_plugins(\n    group: str,\n    plugins: List[Tuple[str, Any]],\n) -&gt; None:\n    \"\"\"List plugins in a single group\n\n    Args:\n        group: The group of the plugins\n        plugins: A list of tuples with name and plugin\n    \"\"\"\n    print(\"\")\n    print(f\"[bold][u]{GROUP_NAMES[group]} plugins:[/u][/bold]\")\n    namelen = max(len(name) for name, _ in plugins) if plugins else 0\n    for name, plugin in plugins:\n        try:\n            ver = plugin.version\n        except AttributeError:\n            try:\n                ver = plugin.__version__\n            except AttributeError:\n                ver = \"unknown\"\n        print(f\"- {name.ljust(namelen)}: (version: {ver})\")\n\n\ndef _list_plugins(plugins: List[Tuple[str, str, Any]]) -&gt; None:\n    \"\"\"List plugins\n\n    Args:\n        plugins: A list of tuples with group, name and plugin\n    \"\"\"\n    pipen_plugins = [\n        (name, plugin) for group, name, plugin in plugins if group == \"pipen\"\n    ]\n    sched_plugins = [\n        (name, plugin)\n        for group, name, plugin in plugins\n        if group == SCHEDULER_ENTRY_GROUP\n    ]\n    tpl_plugins = [\n        (name, plugin)\n        for group, name, plugin in plugins\n        if group == TEMPLATE_ENTRY_GROUP\n    ]\n    cli_plugins = [\n        (name, plugin)\n        for group, name, plugin in plugins\n        if group == CLI_ENTRY_GROUP\n    ]\n    _list_group_plugins(\"pipen\", pipen_plugins)\n    _list_group_plugins(SCHEDULER_ENTRY_GROUP, sched_plugins)\n    _list_group_plugins(TEMPLATE_ENTRY_GROUP, tpl_plugins)\n    _list_group_plugins(CLI_ENTRY_GROUP, cli_plugins)\n\n\nclass CliPluginsPlugin(CLIPlugin):DOCS\n    \"\"\"List installed plugins\"\"\"\n\n    name = \"plugins\"\n\n    def __init__(\n        self,\n        parser: ArgumentParser,\n        subparser: ArgumentParser,\n    ) -&gt; None:\n        super().__init__(parser, subparser)\n        subparser.add_argument(\n            \"-g\",\n            \"--group\",\n            choices=GROUPS + [\"all\"],\n            default=\"all\",\n            help=\"The name of the entry point group. Show all if not provided\",\n        )\n\n    def exec_command(self, args: Namespace) -&gt; None:DOCS\n        \"\"\"Execute the command\"\"\"\n        from ..version import __version__\n        print(\"Pipen version:\", __version__)\n\n        plugins: List[Tuple[str, str, Any]] = []\n\n        if args.group and args.group != \"all\":\n            for name, plugin in _get_plugins_by_group(args.group):\n                plugins.append((args.group, name, plugin))\n\n        else:  # args.name\n            for group in GROUPS:\n                for name, plugin in _get_plugins_by_group(group):\n                    plugins.append((group, name, plugin))\n\n        _list_plugins(plugins)\n</code></pre>"},{"location":"api/source/pipen.cli.profile/","title":"pipen.cli.profile","text":""},{"location":"api/source/pipen.cli.profile/","title":"SOURCE CODE pipen.cli.profile DOCS","text":"<pre><code>\"\"\"List available profiles.\"\"\"\nfrom __future__ import annotations\nfrom typing import TYPE_CHECKING\n\nfrom rich import print\nfrom rich.panel import Panel\nfrom rich.syntax import Syntax\nfrom simpleconf import ProfileConfig\n\nfrom ._hooks import CLIPlugin\nfrom ..defaults import CONFIG, CONFIG_FILES\n\nif TYPE_CHECKING:\n    from argx import ArgumentParser\n    from argparse import Namespace\n\n__all__ = (\"CLIProfilePlugin\",)\n\n\nclass CLIProfilePlugin(CLIPlugin):DOCS\n    \"\"\"List available profiles.\"\"\"\n\n    name = \"profile\"\n\n    def __init__(\n        self,\n        parser: ArgumentParser,\n        subparser: ArgumentParser,\n    ) -&gt; None:\n        super().__init__(parser, subparser)\n        subparser.add_argument(\n            \"-n\",\n            \"--name\",\n            default=\"\",\n            help=\"The name of the profile to show. Show all if not provided.\",\n        )\n        subparser.add_argument(\n            \"-l\",\n            \"--list\",\n            action=\"store_true\",\n            default=False,\n            help=\"List the names of all available profiles (-n won't work).\",\n        )\n\n    def exec_command(self, args: Namespace) -&gt; None:DOCS\n        \"\"\"Run the command\"\"\"\n\n        config = ProfileConfig.load(\n            {\"default\": CONFIG},\n            *CONFIG_FILES,\n            ignore_nonexist=True,\n        )\n\n        if args.list:\n            print(\"\\n\".join(ProfileConfig.profiles(config)))\n            return\n\n        print(\"Configurations loaded from:\")\n        print(\"- pipen.defaults.CONFIG (python dictionary)\")\n        for conffile in reversed(CONFIG_FILES):\n            print(f\"- {conffile}\")\n        print(\"\")\n\n        print(\"Note:\")\n        print(\n            \"- The same profile from different configuration files \"\n            \"are inherited.\"\n        )\n        print(\n            \"- These configurations can still be overriden by \"\n            \"Pipen constructor and process definition.\"\n        )\n        print(\"\")\n\n        if not args.name:\n            for profile in ProfileConfig.profiles(config):\n                with ProfileConfig.with_profile(config, profile):\n                    conf = ProfileConfig.detach(config)\n                    print(\n                        Panel(\n                            Syntax(conf.to_toml(), \"toml\"),\n                            title=f\"Profile: {profile}\",\n                            title_align=\"left\",\n                        )\n                    )\n\n        else:\n            if not ProfileConfig.has_profile(config, args.name):\n                raise ValueError(f\"No such profile: {args.name}\")\n\n            ProfileConfig.use_profile(config, args.name)\n            conf = ProfileConfig.detach(config)\n            print(\n                Panel(\n                    Syntax(conf.to_toml(), \"toml\"),\n                    title=f\"Profile: {args.name}\",\n                    title_align=\"left\",\n                )\n            )\n</code></pre>"},{"location":"api/source/pipen.cli.version/","title":"pipen.cli.version","text":""},{"location":"api/source/pipen.cli.version/","title":"SOURCE CODE pipen.cli.version DOCS","text":"<pre><code>\"\"\"Print help for commands\"\"\"\nfrom __future__ import annotations\nfrom typing import TYPE_CHECKING\n\nfrom rich import print\n\nfrom ._hooks import CLIPlugin\n\nif TYPE_CHECKING:\n    from argparse import Namespace\n\n__all__ = (\"CLIVersionPlugin\",)\n\n\nclass CLIVersionPlugin(CLIPlugin):DOCS\n    \"\"\"Print versions of pipen and its dependencies\"\"\"\n\n    name = \"version\"\n\n    def exec_command(self, args: Namespace) -&gt; None:DOCS\n        \"\"\"Run the command\"\"\"\n        import sys\n        from importlib.metadata import version\n        from .. import __version__\n\n        versions = {\"python\": sys.version, \"pipen\": __version__}\n\n        for pkg in (\n            \"liquidpy\",\n            \"pandas\",\n            \"enlighten\",\n            \"argx\",\n            \"xqute\",\n            \"python-simpleconf\",\n            \"pipda\",\n            \"varname\",\n        ):\n            versions[pkg] = version(pkg)\n\n        keylen = max(map(len, versions))\n        for key in versions:\n            ver = versions[key]\n            verlines = ver.splitlines()\n            print(f\"{key.ljust(keylen)}: {verlines.pop(0)}\")\n            for verline in verlines:  # pragma: no cover\n                print(f\"{' ' * keylen}  {verline}\")\n</code></pre>"},{"location":"api/source/pipen.defaults/","title":"pipen.defaults","text":""},{"location":"api/source/pipen.defaults/","title":"SOURCE CODE pipen.defaults DOCS","text":"<pre><code>\"\"\"Provide some default values/objects\"\"\"\nfrom pathlib import Path\nfrom typing import ClassVar\n\nfrom diot import Diot\nfrom xqute import JobErrorStrategy\nfrom xqute.utils import logger as xqute_logger\n\n# Remove the rich handler\n_xqute_handlers = xqute_logger.handlers\nif _xqute_handlers:\n    # The very first handler is the rich handler\n    xqute_logger.removeHandler(_xqute_handlers[0])\n\nLOGGER_NAME = \"core\"\nCONFIG_FILES = (\n    Path(\"~/.pipen.toml\").expanduser(),\n    \"./.pipen.toml\",\n    \"PIPEN.osenv\",\n)\nCONFIG = Diot(\n    # pipeline level: The logging level\n    loglevel=\"info\",\n    # process level: The cache option, True/False/export\n    cache=True,\n    # process level: Whether expand directory to check signature\n    dirsig=1,\n    # process level:\n    # How to deal with the errors\n    # retry, ignore, halt\n    # halt to halt the whole pipeline, no submitting new jobs\n    # terminate to just terminate the job itself\n    error_strategy=JobErrorStrategy.IGNORE,\n    # process level:\n    # How many times to retry to jobs once error occurs\n    num_retries=3,\n    # process level:\n    # The directory to export the output files\n    forks=1,\n    # process level: Default shell/language\n    lang=\"bash\",\n    # process level:\n    # How many jobs to be submitted in a batch\n    submission_batch=8,\n    # pipeline level:\n    # The working directory for the pipeline\n    workdir=\"./.pipen\",\n    # process level: template engine\n    template=\"liquid\",\n    # process level: template options\n    template_opts={},\n    # process level: scheduler\n    scheduler=\"local\",\n    # process level: scheduler options\n    scheduler_opts={},\n    # pipeline level: plugins\n    plugins=None,\n    # pipeline level: plugin opts\n    plugin_opts={},\n)\n\n# Just the total width of the terminal\n# when logging with a rich.Panel()\nCONSOLE_WIDTH_WITH_PANEL = 100\n# The width of the terminal when the width cannot be detected,\n# we are probably logging into a file\nCONSOLE_DEFAULT_WIDTH = 2048\n# [05/16/22 11:46:40] I\n# v0.3.4:\n# 05-16 11:11:11 I\n# The markup code is included\n# Don't modify this unless the logger formatter is changed\nCONSOLE_WIDTH_SHIFT = 25\n# For pipen scheduler plugins\nSCHEDULER_ENTRY_GROUP = \"pipen_sched\"\n# For pipen template plugins\nTEMPLATE_ENTRY_GROUP = \"pipen_tpl\"\n# For pipen template cli plugins\nCLI_ENTRY_GROUP = \"pipen_cli\"\n\n\nclass ProcInputType:DOCS\n    \"\"\"Types for process inputs\"\"\"\n\n    VAR: ClassVar[str] = \"var\"\n    FILE: ClassVar[str] = \"file\"\n    DIR: ClassVar[str] = \"dir\"\n    FILES: ClassVar[str] = \"files\"\n    DIRS: ClassVar[str] = \"dirs\"\n\n\nclass ProcOutputType:DOCS\n    \"\"\"Types for process outputs\"\"\"\n\n    VAR: ClassVar[str] = \"var\"\n    DIR: ClassVar[str] = \"dir\"\n    FILE: ClassVar[str] = \"file\"\n</code></pre>"},{"location":"api/source/pipen.exceptions/","title":"pipen.exceptions","text":""},{"location":"api/source/pipen.exceptions/","title":"SOURCE CODE pipen.exceptions DOCS","text":"<pre><code>\"\"\"Provide exception classes\"\"\"\n\n\nclass PipenException(Exception):DOCS\n    \"\"\"Base exception class for pipen\"\"\"\n\n\nclass PipenSetDataError(PipenException, ValueError):DOCS\n    \"\"\"When trying to set input data to processes with input_data already set\n    using Pipen.set_data().\"\"\"\n\n\nclass ProcInputTypeError(PipenException, TypeError):DOCS\n    \"\"\"When an unsupported input type is provided\"\"\"\n\n\nclass ProcInputKeyError(PipenException, KeyError):DOCS\n    \"\"\"When an unsupported input key is provided\"\"\"\n\n\nclass ProcInputValueError(PipenException, ValueError):DOCS\n    \"\"\"When an unsupported input value is provided\"\"\"\n\n\nclass ProcScriptFileNotFound(PipenException, FileNotFoundError):DOCS\n    \"\"\"When script file specified as 'file://' cannot be found\"\"\"\n\n\nclass ProcOutputNameError(PipenException, NameError):DOCS\n    \"\"\"When no name or malformatted output is provided\"\"\"\n\n\nclass ProcOutputTypeError(PipenException, TypeError):DOCS\n    \"\"\"When an unsupported output type is provided\"\"\"\n\n\nclass ProcOutputValueError(PipenException, ValueError):DOCS\n    \"\"\"When a malformatted output value is provided\"\"\"\n\n\nclass ProcDependencyError(PipenException):DOCS\n    \"\"\"When there is something wrong the process dependencies\"\"\"\n\n\nclass NoSuchSchedulerError(PipenException):DOCS\n    \"\"\"When specified scheduler cannot be found\"\"\"\n\n\nclass WrongSchedulerTypeError(PipenException, TypeError):DOCS\n    \"\"\"When specified scheduler is not a subclass of Scheduler\"\"\"\n\n\nclass NoSuchTemplateEngineError(PipenException):DOCS\n    \"\"\"When specified template engine cannot be found\"\"\"\n\n\nclass WrongTemplateEnginTypeError(PipenException, TypeError):DOCS\n    \"\"\"When specified tempalte engine is not a subclass of Scheduler\"\"\"\n\n\nclass TemplateRenderingError(PipenException):DOCS\n    \"\"\"Failed to render a template\"\"\"\n\n\nclass ConfigurationError(PipenException):DOCS\n    \"\"\"When something wrong set as configuration\"\"\"\n\n\nclass PipenOrProcNameError(PipenException):DOCS\n    \"\"\" \"When more than one processes are sharing the same workdir\"\"\"\n</code></pre>"},{"location":"api/source/pipen.job/","title":"pipen.job","text":""},{"location":"api/source/pipen.job/","title":"SOURCE CODE pipen.job DOCS","text":"<pre><code>\"\"\"Provide the Job class\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport shlex\nfrom collections.abc import Iterable\nfrom functools import cached_property\nfrom os import PathLike\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, Dict, Mapping\n\nfrom yunpath import AnyPath, CloudPath\nfrom diot import OrderedDiot\nfrom xqute import Job as XquteJob\nfrom xqute.path import SpecPath, MountedPath\n\nfrom ._job_caching import JobCaching\nfrom .defaults import ProcInputType, ProcOutputType\nfrom .exceptions import (\n    ProcInputTypeError,\n    ProcOutputNameError,\n    ProcOutputTypeError,\n    ProcOutputValueError,\n    TemplateRenderingError,\n)\nfrom .template import Template\nfrom .utils import logger, strsplit, path_is_symlink, path_symlink_to\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .proc import Proc\n\n\ndef _process_input_file_or_dir(\n    inkey: str,\n    intype: str,\n    inval: Any,\n    index: int | None = None,\n    proc_name: str | None = None,\n) -&gt; CloudPath | MountedPath:\n    \"\"\"Process the input value for file or dir\"\"\"\n    if inval is None or not isinstance(inval, (str, PathLike, Path, CloudPath)):\n        msg = (\n            f\"[{proc_name}] Got &lt;{type(inval).__name__}&gt; instead of \"\n            f\"PathLike object for input: {inkey + ':' + intype!r}\"\n        )\n        if index is not None:\n            msg = f\"{msg} at index {index}\"\n\n        raise ProcInputTypeError(msg)\n\n    if isinstance(inval, MountedPath):\n        return inval\n\n    if isinstance(inval, SpecPath):\n        return inval.mounted\n\n    if isinstance(inval, CloudPath):  # pragma: no cover\n        return MountedPath(inval)\n\n    if not isinstance(inval, str):  # other PathLike types, should be all local\n        return MountedPath(Path(inval).expanduser().absolute())\n\n    # str\n    # Let's see if it a path in str format, which is path1:path2\n    # However, there is also a colon in cloud paths\n    colon_count = inval.count(\":\")\n    if colon_count == 0:  # a/b\n        return MountedPath(Path(inval).expanduser().absolute())\n\n    if colon_count &gt; 3:  # a:b:c:d\n        msg = (\n            f\"[{proc_name}] Invalid input value: {inkey + ':' + intype!r} \"\n            \"(too many ':')\"\n        )\n        if index is not None:\n            msg = f\"{msg} at index {index}\"\n\n        raise ProcInputTypeError(msg)\n\n    if colon_count == 1:  # gs://a/b or a/b:c/d\n        if isinstance(AnyPath(inval), CloudPath):  # gs://a/b\n            return MountedPath(inval)\n\n        path1, path2 = inval.split(\":\")\n\n    elif inval.count(\":\") == 3:  # gs://a/b:gs://c/d\n        p1, p2, path2 = inval.split(\":\", 2)\n        path1 = p1 + \":\" + p2\n\n    else:  # gs://a/b:c/d or a/b:gs://c/d\n        p1, p2, p3 = inval.split(\":\", 2)\n        path1, path2 = p1 + \":\" + p2, p3\n        if not isinstance(AnyPath(path1), CloudPath):\n            path1, path2 = p1, p2 + \":\" + p3\n\n    path1 = AnyPath(path1)  # type: ignore\n    path2 = AnyPath(path2)  # type: ignore\n    if isinstance(path1, Path):\n        path1 = path1.expanduser().absolute()\n    if isinstance(path2, Path):\n        path2 = path2.expanduser().absolute()\n\n    return MountedPath(path2, spec=path1)\n\n\nclass Job(XquteJob, JobCaching):DOCS\n    \"\"\"The job for pipen\"\"\"\n\n    __slots__ = XquteJob.__slots__ + (\"proc\", \"_output_types\", \"_outdir\")\n\n    def __init__(\n        self,\n        *args: Any,\n        **kwargs: Any,\n    ) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.proc: Proc = None\n        self._output_types: Dict[str, str] = {}\n        # Where the real output directory is\n        self._outdir: SpecPath = None\n\n    async def prepare(self, proc: Proc) -&gt; None:DOCS\n        \"\"\"Prepare the job by given process\n\n        Primarily prepare the script, and provide cmd to the job for xqute\n        to wrap and run\n\n        Args:\n            proc: the process object\n        \"\"\"\n        # Attach the process\n        self.proc = proc\n\n        # Where the jobs of \"export\" process should put their outputs\n        export_outdir = proc.pipeline.outdir / proc.name  # type: ignore\n        # Where the jobs of \"export\" process should put their outputs\n        # (in the mounted filesystem)\n        sched_mounted_outdir = getattr(proc.xqute.scheduler, \"MOUNTED_OUTDIR\", None)\n        if sched_mounted_outdir is not None:  # pragma: no cover\n            if (\n                isinstance(proc.pipeline.outdir, SpecPath)\n                and proc.pipeline.outdir.mounted.is_mounted()\n            ):\n                raise ValueError(\n                    \"The pipeline outdir is a SpecPath, \"\n                    \"but the MOUNTED_OUTDIR is provided by the scheduler \"\n                    f\"&lt;{proc.xqute.scheduler.__class__.__name__}&gt;. \"\n                )\n\n            mounted_outdir = Path(sched_mounted_outdir) / proc.name\n\n        elif isinstance(proc.pipeline.outdir, SpecPath):  # pragma: no cover\n            # In the case it is modified by a plugin\n            # A dual path can not be specified as outdir of a pipeline\n            mounted_outdir = proc.pipeline.outdir.mounted / proc.name  # type: ignore\n\n        else:\n            mounted_outdir = None\n\n        if self.proc.export:\n            # Don't put index if it is a single-job process\n            self._outdir = SpecPath(export_outdir, mounted=mounted_outdir)\n\n            # Put job output in a subdirectory with index\n            # if it is a multi-job process\n            if len(self.proc.jobs) &gt; 1:\n                self._outdir = self._outdir / str(self.index)  # type: ignore\n\n            if sched_mounted_outdir is None:\n                # Create the output directory if it is not mounted by the scheduler\n                self._outdir.mounted.mkdir(parents=True, exist_ok=True)\n\n        else:\n            # For non-export process, the output directory is the metadir\n            self._outdir = self.metadir / \"output\"\n\n        if not proc.script:\n            self.cmd = (\"true\", )\n            return\n\n        try:\n            script = proc.script.render(self.template_data)\n        except Exception as exc:\n            raise TemplateRenderingError(\n                f\"[{self.proc.name}] Failed to render script.\"\n            ) from exc\n\n        if self.script_file.is_file() and self.script_file.read_text() != script:\n            self.log(\"debug\", \"Job script updated.\")\n            self.script_file.write_text(script)\n        elif not self.script_file.is_file():\n            self.script_file.write_text(script)\n\n        lang = proc.lang or proc.pipeline.config.lang\n        self.cmd = tuple(shlex.split(lang) + [self.script_file.mounted.fspath])\n\n    @propertyDOCS\n    def script_file(self) -&gt; SpecPath:\n        \"\"\"Get the path to script file\n\n        Returns:\n            The path to the script file\n        \"\"\"\n        return self.metadir / \"job.script\"\n\n    @cached_property\n    def outdir(self) -&gt; SpecPath:\n        \"\"\"Get the path to the output directory.\n\n        When proc.export is True, the output directory is based on the\n        pipeline.outdir and the process name. Otherwise, it is based on\n        the metadir.\n\n        When the job is running in a detached system (a VM, typically),\n        this will return the mounted path to the output directory.\n\n        To access the real path, use self._outdir\n\n        Returns:\n            The path to the job output directory\n        \"\"\"\n        # if ret is a dead link\n        # when switching a proc from end/nonend to nonend/end\n        # if path_is_symlink(self._outdir) and not self._outdir.exists():\n        if path_is_symlink(self._outdir) and (  # type: ignore\n            # A local deak link\n            not self._outdir.exists()\n            # A cloud fake link\n            or isinstance(getattr(self._outdir, \"path\", self._outdir), CloudPath)\n        ):\n            self._outdir.unlink()  # pragma: no cover\n\n        self._outdir.mkdir(parents=True, exist_ok=True)\n        # If it is somewhere else, make a symbolic link to the metadir\n        metaout = self.metadir / \"output\"\n        if self._outdir != metaout:\n            if path_is_symlink(metaout) or metaout.is_file():\n                metaout.unlink()\n            elif metaout.is_dir():\n                metaout.rmtree()\n\n            path_symlink_to(metaout, self._outdir)  # type: ignore\n\n        return self._outdir\n\n    @cached_property\n    def input(self) -&gt; Mapping[str, Any]:\n        \"\"\"Get the input data for this job\n\n        Returns:\n            A key-value map, where keys are the input keys\n        \"\"\"\n        import pandas\n\n        ret = self.proc.input.data.iloc[self.index, :].to_dict()\n        # check types\n        for inkey, intype in self.proc.input.type.items():\n\n            if intype == ProcInputType.VAR or ret[inkey] is None:\n                continue  # pragma: no cover, covered actually\n\n            if intype in (ProcInputType.FILE, ProcInputType.DIR):\n                ret[inkey] = _process_input_file_or_dir(\n                    inkey, intype, ret[inkey], None, self.proc.name\n                )\n\n            if intype in (ProcInputType.FILES, ProcInputType.DIRS):\n                if isinstance(ret[inkey], pandas.DataFrame):  # pragma: no cover\n                    # // todo: nested dataframe\n                    ret[inkey] = ret[inkey].iloc[0, 0]\n\n                if isinstance(ret[inkey], (str, PathLike, Path, CloudPath)):\n                    # if a single file, convert to list\n                    ret[inkey] = [ret[inkey]]\n\n                if not isinstance(ret[inkey], Iterable):\n                    raise ProcInputTypeError(\n                        f\"[{self.proc.name}] Expected an iterable for input: \"\n                        f\"{inkey + ':' + intype!r}, got {type(ret[inkey])}\"\n                    )\n\n                for i, file in enumerate(ret[inkey]):\n                    ret[inkey][i] = _process_input_file_or_dir(\n                        inkey, intype, file, i, self.proc.name\n                    )\n\n        return ret\n\n    @cached_property\n    def output(self) -&gt; Mapping[str, Any]:\n        \"\"\"Get the output data of the job\n\n        Returns:\n            The key-value map where the keys are the output keys\n        \"\"\"\n        output_template = self.proc.output\n        if not output_template:\n            return {}\n\n        data = {\n            \"job\": dict(\n                index=self.index,\n                metadir=self.metadir.mounted,\n                outdir=self.outdir.mounted,\n                stdout_file=self.stdout_file.mounted,\n                stderr_file=self.stderr_file.mounted,\n                jid_file=self.jid_file.mounted,\n            ),\n            \"in\": self.input,\n            \"in_\": self.input,\n            \"proc\": self.proc,\n            \"envs\": self.proc.envs,\n        }\n        try:\n            if isinstance(output_template, Template):\n                # // TODO: check ',' in output value?\n                outputs = strsplit(output_template.render(data), \",\")\n            else:\n                outputs = [oput.render(data) for oput in output_template]\n        except Exception as exc:\n            raise TemplateRenderingError(\n                f\"[{self.proc.name}] Failed to render output.\"\n            ) from exc\n\n        ret = OrderedDiot()\n        for oput in outputs:\n            if \":\" not in oput:\n                raise ProcOutputNameError(\n                    f\"[{self.proc.name}] No name given in output.\"\n                )\n\n            if oput.count(\":\") == 1:\n                output_name, output_value = oput.split(\":\")\n                output_type = ProcOutputType.VAR\n            else:\n                output_name, output_type, output_value = oput.split(\":\", 2)\n                if output_type not in ProcOutputType.__dict__.values():\n                    raise ProcOutputTypeError(\n                        f\"[{self.proc.name}] \" f\"Unsupported output type: {output_type}\"\n                    )\n\n            self._output_types[output_name] = output_type\n\n            if output_type == ProcOutputType.VAR:\n                ret[output_name] = output_value\n            else:\n                ov = AnyPath(output_value)\n                if isinstance(ov, CloudPath) or (\n                    isinstance(ov, Path) and ov.is_absolute()\n                ):\n                    raise ProcOutputValueError(\n                        f\"[{self.proc.name}] \"\n                        f\"output path must be a segment: {output_value}\"\n                    )\n\n                out = self.outdir / output_value  # type: ignore\n                if output_type == ProcOutputType.DIR:\n                    out.mkdir(parents=True, exist_ok=True)\n\n                ret[output_name] = out.mounted\n\n        return ret\n\n    @cached_property\n    def template_data(self) -&gt; Mapping[str, Any]:\n        \"\"\"Get the data for template rendering\n\n        Returns:\n            The data for template rendering\n        \"\"\"\n        return {\n            \"job\": dict(\n                index=self.index,\n                metadir=self.metadir.mounted,\n                outdir=self.outdir.mounted,\n                stdout_file=self.stdout_file.mounted,\n                stderr_file=self.stderr_file.mounted,\n                jid_file=self.jid_file.mounted,\n            ),\n            \"in\": self.input,\n            \"in_\": self.input,\n            \"out\": self.output,\n            \"proc\": self.proc,\n            \"envs\": self.proc.envs,\n        }\n\n    def log(DOCS\n        self,\n        level: int | str,\n        msg: str,\n        *args,\n        limit: int = 3,\n        limit_indicator: bool = True,\n        logger: logging.LoggerAdapter = logger,\n    ) -&gt; None:\n        \"\"\"Log message for the jobs\n\n        Args:\n            level: The log level of the record\n            msg: The message to log\n            *args: The arguments to format the message\n            limit: limitation of the log (don't log for all jobs)\n            limit_indicator: Whether to show an indicator saying the log\n                has been limited (the level of the indicator will be DEBUG)\n            logger: The logger used to log\n        \"\"\"\n        if self.index &gt; limit:\n            return\n\n        if self.index == limit:\n            if limit_indicator:\n                msg = f\"{msg} (not showing similar logs)\"\n\n        if self.proc.size == 1:\n            job_index_indicator = \"\"\n        else:\n            job_index_indicator = \"[%s/%s] \" % (\n                str(self.index).zfill(len(str(self.proc.size - 1))),\n                self.proc.size - 1,\n            )\n\n        self.proc.log(level, job_index_indicator + msg, *args, logger=logger)\n</code></pre>"},{"location":"api/source/pipen/","title":"pipen","text":""},{"location":"api/source/pipen/","title":"SOURCE CODE pipen DOCS","text":"<pre><code>\"\"\"A pipeline framework for python\"\"\"\nfrom .pipen import Pipen, run\nfrom .proc import Proc\nfrom .procgroup import ProcGroup\n\n# Use from pipen.channel import Channel instead of\n# from pipen import Channel\n# This slows down import\n# from .channel import Channel\nfrom .pluginmgr import plugin\nfrom .version import __version__\n</code></pre>"},{"location":"api/source/pipen.pipen/","title":"pipen.pipen","text":""},{"location":"api/source/pipen.pipen/","title":"SOURCE CODE pipen.pipen DOCS","text":"<pre><code>\"\"\"Main entry module, provide the Pipen class\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nfrom os import PathLike\nfrom pathlib import Path\nfrom typing import TYPE_CHECKING, Any, ClassVar, Iterable, List, Sequence, Type\n\nfrom diot import Diot\nfrom rich import box\nfrom rich.panel import Panel\nfrom rich.text import Text\nfrom simpleconf import ProfileConfig\nfrom varname import varname, VarnameException\nfrom yunpath import AnyPath\n\nfrom .defaults import CONFIG, CONFIG_FILES\nfrom .exceptions import (\n    PipenOrProcNameError,\n    ProcDependencyError,\n    PipenSetDataError,\n)\nfrom .pluginmgr import plugin\nfrom .proc import Proc\nfrom .progressbar import PipelinePBar\nfrom .utils import (\n    copy_dict,\n    desc_from_docstring,\n    get_logpanel_width,\n    is_valid_name,\n    log_rich_renderable,\n    logger,\n    pipen_banner,\n)\n\nif TYPE_CHECKING:\n    from xqute.path import PathType\n\n\nclass Pipen:DOCS\n    \"\"\"The Pipen class provides interface to assemble and run the pipeline\n\n    Attributes:\n        name: The name of the pipeline\n        desc: The description of the pipeline\n        outdir: The output directory of the results\n        procs: The processes\n        pbar: The progress bar\n        starts: The start processes\n        config: The configurations\n        workdir: The workdir for the pipeline\n        profile: The profile of the configurations to run the pipeline\n        _kwargs: The extra configrations passed to overwrite the default ones\n\n        PIPELINE_COUNT: How many pipelines are loaded\n        SETUP: Whether the one-time setup hook is called\n\n    Args:\n        name: The name of the pipeline\n        desc: The description of the pipeline\n        outdir: The output directory of the results\n        **kwargs: Other configurations\n    \"\"\"\n\n    PIPELINE_COUNT: ClassVar[int] = 0\n    SETUP: ClassVar[bool] = False\n\n    name: str | None = None\n    desc: str | None = None\n    outdir: str | PathLike = None\n    starts: Type[Proc] | List[Type[Proc]] = []\n    data: Iterable | None = None\n    # other configs\n\n    def __init__(\n        self,\n        name: str | None = None,\n        desc: str | None = None,\n        outdir: str | PathLike = None,\n        **kwargs,\n    ) -&gt; None:\n        \"\"\"Constructor\"\"\"\n        self.procs: List[Type[Proc]] = None\n        self.pbar: PipelinePBar = None\n        if name is not None:\n            self.name = name\n        elif self.__class__.name is not None:\n            self.name = self.__class__.name\n        else:\n            try:\n                self.name = varname()  # type: ignore\n            except VarnameException:\n                if self.__class__.PIPELINE_COUNT == 0:\n                    self.name = self.__class__.__name__\n                else:\n                    self.name = (\n                        f\"{self.__class__.__name__}-\" f\"{self.__class__.PIPELINE_COUNT}\"\n                    )\n\n        if not is_valid_name(self.name):\n            raise PipenOrProcNameError(\n                rf\"Invalid pipeline name: {self.name}, expecting '^[\\w.-]$'\"\n            )\n\n        self.desc = (\n            desc or self.__class__.desc or desc_from_docstring(self.__class__, Pipen)\n        )\n        self.outdir: PathType = AnyPath(  # type: ignore\n            outdir or self.__class__.outdir or f\"./{self.name}-output\"\n        )\n        if isinstance(self.outdir, Path):\n            self.outdir = self.outdir.absolute()\n\n        self.workdir: PathType | None = None\n        self.profile: str = \"default\"\n\n        self.starts: List[Type[Proc]] = self.__class__.starts\n        if self.starts and not isinstance(self.starts, (tuple, list)):\n            self.starts = [self.starts]\n\n        self.config = Diot(copy_dict(CONFIG, 3))\n        # We shouldn't update the config here, since we don't know\n        # the profile yet\n        self._kwargs = {\n            key: value\n            for key, value in self.__class__.__dict__.items()\n            if key in self.config\n        }\n        self._kwargs.setdefault(\"plugin_opts\", {}).update(kwargs.pop(\"plugin_opts\", {}))\n        self._kwargs.setdefault(\"template_opts\", {}).update(\n            kwargs.pop(\"template_opts\", {})\n        )\n        self._kwargs.setdefault(\"scheduler_opts\", {}).update(\n            kwargs.pop(\"scheduler_opts\", {})\n        )\n        self._kwargs.update(kwargs)\n        # Initialize the workdir, as workdir is created before _init()\n        # But the config is updated in _init()\n        # Here we hack it to have the workdir passed in.\n        if \"workdir\" in kwargs:\n            self.config.workdir = kwargs[\"workdir\"]\n\n        if not self.__class__.SETUP:  # pragma: no cover\n            # Load plugins from entrypotins at runtime to avoid\n            # cyclic imports\n            plugin.load_entrypoints()\n\n        plugins = self._kwargs.get(\"plugins\", None)\n        if plugins is None:\n            plugins = self.config.plugins\n        self.plugin_context = plugin.plugins_context(plugins)\n        self.plugin_context.__enter__()\n\n        # make sure core plugin is enabled\n        plugin.get_plugin(\"core\").enable()\n\n        if not Pipen.SETUP:  # pragma: no cover\n            plugin.hooks.on_setup(self)\n            Pipen.SETUP = True\n\n        self.__class__.PIPELINE_COUNT += 1\n\n        if self.__class__.data is not None:\n            self.set_data(*self.__class__.data)\n\n    def __init_subclass__(cls) -&gt; None:DOCS\n        cls.PIPELINE_COUNT = 0\n\n    async def async_run(self, profile: str = \"default\") -&gt; bool:DOCS\n        \"\"\"Run the processes one by one\n\n        Args:\n            profile: The default profile to use for the run\n\n        Returns:\n            True if the pipeline ends successfully else False\n        \"\"\"\n        self.profile = profile\n        self.workdir = AnyPath(str(self.config.workdir)) / self.name  # type: ignore\n\n        succeeded = True\n        await self._init()\n        logger.setLevel(self.config.loglevel.upper())\n        log_rich_renderable(pipen_banner(), \"magenta\", logger.info)\n        try:\n            self.build_proc_relationships()\n            self._log_pipeline_info()\n            logger.info(\"Initializing plugins ...\")\n            await plugin.hooks.on_start(self)\n            for proc in self.procs:\n                self.pbar.update_proc_running()\n                proc_obj = proc(self)  # type: ignore\n                if proc in self.starts and proc.input_data is None:  # type: ignore\n                    proc_obj.log(\n                        \"warning\",\n                        \"This is a start process, but no 'input_data' specified.\",\n                    )\n                await proc_obj.init()\n                await proc_obj.run()\n                if proc_obj.succeeded:\n                    self.pbar.update_proc_done()\n                else:\n                    self.pbar.update_proc_error()\n                    succeeded = False\n                    break\n                proc_obj.gc()\n\n            logger.info(\"\")\n        except Exception:\n            raise\n        else:\n            await plugin.hooks.on_complete(self, succeeded)\n        finally:\n            self.plugin_context.__exit__()\n            if self.pbar:\n                self.pbar.done()\n\n        return succeeded\n\n    def run(DOCS\n        self,\n        profile: str = \"default\",\n    ) -&gt; bool:\n        \"\"\"Run the pipeline with the given profile\n        This is just a sync wrapper for the async `async_run` function using\n        `asyncio.run()`\n\n        Args:\n            profile: The default profile to use for the run\n\n        Returns:\n            True if the pipeline ends successfully else False\n        \"\"\"\n        return asyncio.run(self.async_run(profile))\n\n    def set_data(self, *indata: Any) -&gt; Pipen:DOCS\n        \"\"\"Set the input_data for start processes\n\n        Args:\n            *indata: The input data for the start processes\n                The data will set for the processes in the order determined by\n                `set_starts()`.\n                If a process has input_data set, an error will be raised.\n                To use that input_data, set None here in the corresponding\n                position for the process\n\n        Raises:\n            ProcInputDataError: When trying to set input data to\n                processes with input_data already set\n\n        Returns:\n            `self` to chain the operations\n        \"\"\"\n        for start, data in zip(self.starts, indata):  # type: ignore\n            if data is None:\n                continue\n            if start.input_data is not None:\n                raise PipenSetDataError(\n                    f\"`input_data` has already set for {start}. \"\n                    \"If you want to use it, set `None` at the position of \"\n                    \"this process for `Pipen.set_data()`.\"\n                )\n            start.input_data = data\n        return self\n\n    def set_starts(DOCS\n        self,\n        *procs: Type[Proc] | Sequence[Type[Proc]],\n        clear: bool = True,\n    ):\n        \"\"\"Set the starts\n\n        Args:\n            *procs: The processes to set as starts of the pipeline.\n            clear: Wether to clear previous set starts\n\n        Raises:\n            ProcDependencyError: When processes set as starts repeatedly\n\n        Returns:\n            `self` to chain the operations\n        \"\"\"\n        if clear:\n            self.starts = []\n            self.procs = None\n\n        for proc in procs:\n            if isinstance(proc, (list, tuple)):\n                self.set_starts(*proc, clear=False)\n            elif not isinstance(proc, type) or not issubclass(proc, Proc):\n                raise ProcDependencyError(\n                    f\"{proc!r} is not a subclass of 'pipen.Proc'.\"\n                )\n            elif proc not in self.starts:  # type: ignore\n                self.starts.append(proc)  # type: ignore\n            else:\n                raise ProcDependencyError(f\"{proc} is already a start process.\")\n        return self\n\n    # In case people forget the \"s\"\n    set_start = set_starts\n\n    def _log_pipeline_info(self) -&gt; None:\n        \"\"\"Print the information of the pipeline\"\"\"\n        logger.info(\"\")\n        # Pipeline line and description\n        log_rich_renderable(\n            Panel(\n                self.desc or Text(self.name.upper(), justify=\"center\"),\n                width=get_logpanel_width(),\n                # padding=(0, 1),\n                box=box.DOUBLE_EDGE,\n                title=self.name.upper() if self.desc else None,\n            ),\n            \"magenta\",\n            logger.info,\n        )\n        fmt = \"[bold][magenta]%-16s:[/magenta][/bold] %s\"\n        enabled_plugins = (\n            \"{name} [cyan]{version}[/cyan]\".format(\n                name=name,\n                version=(f\"v{plg.version}\" if plg.version else \"\"),\n            )\n            for name, plg in plugin.get_enabled_plugins().items()\n            if name != \"core\"\n        )\n        for i, plug in enumerate(enabled_plugins):\n            logger.info(fmt, \"plugins\" if i == 0 else \"\", plug)\n        logger.info(fmt, \"# procs\", len(self.procs))\n        logger.info(fmt, \"profile\", self.profile)\n        logger.info(fmt, \"outdir\", self.outdir)\n        logger.info(fmt, \"cache\", self.config.cache)\n        logger.info(fmt, \"dirsig\", self.config.dirsig)\n        logger.info(fmt, \"error_strategy\", self.config.error_strategy)\n        logger.info(fmt, \"forks\", self.config.forks)\n        logger.info(fmt, \"lang\", self.config.lang)\n        logger.info(fmt, \"loglevel\", self.config.loglevel)\n        logger.info(fmt, \"num_retries\", self.config.num_retries)\n        logger.info(fmt, \"scheduler\", self.config.scheduler)\n        logger.info(fmt, \"submission_batch\", self.config.submission_batch)\n        logger.info(fmt, \"template\", self.config.template)\n        logger.info(fmt, \"workdir\", self.workdir)\n        for i, (key, val) in enumerate(self.config.plugin_opts.items()):\n            logger.info(fmt, \"plugin_opts\" if i == 0 else \"\", f\"{key}={val}\")\n        for i, (key, val) in enumerate(self.config.scheduler_opts.items()):\n            logger.info(fmt, \"scheduler_opts\" if i == 0 else \"\", f\"{key}={val}\")\n        for i, (key, val) in enumerate(self.config.template_opts.items()):\n            logger.info(fmt, \"template_opts\" if i == 0 else \"\", f\"{key}={val}\")\n\n    async def _init(self) -&gt; None:\n        \"\"\"Compute the configurations for the pipeline based on the priorities\n\n        Configurations (priority from low to high)\n        1. The default config in .defaults\n        2. The plugin_opts defined in plugins (via on_setup() hook)\n           (see __init__())\n        3. Configuration files\n        4. **kwargs from Pipen(..., **kwargs)\n        5. Those defined in each Proc class\n        \"\"\"\n        # Then load the configurations from config files\n        config = ProfileConfig.load(\n            {\"default\": self.config},\n            *CONFIG_FILES,\n            ignore_nonexist=True,\n        )\n        self.config = ProfileConfig.use_profile(config, self.profile, copy=True)\n\n        # configs from files and CONFIG are loaded\n        # allow plugins to change the default configs\n        await plugin.hooks.on_init(self)\n        # Then load the extra configurations passed from __init__(**kwargs)\n        # Make sure dict options get inherited\n        self.config.template_opts.update(self._kwargs.pop(\"template_opts\", {}))\n        self.config.scheduler_opts.update(self._kwargs.pop(\"scheduler_opts\", {}))\n        self.config.plugin_opts.update(self._kwargs.pop(\"plugin_opts\", {}))\n        self.config.update(self._kwargs)\n\n        if \"workdir\" in self._kwargs:\n            self.workdir = AnyPath(self._kwargs[\"workdir\"]) / self.name  # type: ignore\n\n        self.workdir.mkdir(parents=True, exist_ok=True)\n\n    def build_proc_relationships(self) -&gt; None:DOCS\n        \"\"\"Build the proc relationships for the pipeline\"\"\"\n        if self.procs:\n            return\n\n        if not self.starts:\n            raise ProcDependencyError(\n                \"No start processes specified. \"\n                \"Did you forget to call `Pipen.set_starts()`?\"\n            )\n\n        # build proc relationships\n        # Allow starts to be set as a tuple\n        self.procs = list(self.starts)  # type: ignore\n        nexts = set(sum((proc.nexts or [] for proc in self.procs), []))  # type: ignore\n        logger.debug(\"\")\n        logger.debug(\"Building process relationships:\")\n        logger.debug(\"- Start processes: %s\", self.procs)\n        while nexts:\n            logger.debug(\"- Next processes: %s\", nexts)\n            # pick up one that can be added to procs\n            for proc in sorted(nexts, key=lambda prc: (prc.order or 0, prc.name)):\n                if proc in self.procs:\n                    raise ProcDependencyError(f\"Cyclic dependency: {proc.name}\")\n\n                if proc.name in [p.name for p in self.procs]:\n                    raise PipenOrProcNameError(\n                        f\"'{proc.name}' is already used by another process.\"\n                    )\n\n                # Add proc to self.procs if all their requires\n                # are added to self.procs\n                # Then remove proc from nexts\n                # If there are still procs in nexts\n                # meaning some requires of those procs cannot run before\n                # those procs.\n                if not set(proc.requires) - set(self.procs):  # type: ignore\n                    self.procs.append(proc)  # type: ignore\n                    nexts.remove(proc)\n                    nexts |= set(proc.nexts or ())\n                    break\n            else:\n                if nexts:\n                    raise ProcDependencyError(\n                        f\"No available next processes for {nexts}. \"\n                        \"Did you forget to start with their \"\n                        \"required processes?\"\n                    )\n\n        self.pbar = PipelinePBar(len(self.procs), self.name.upper())\n\n\ndef run(DOCS\n    name: str,\n    starts: Type[Proc] | List[Type[Proc]],\n    data: Iterable = None,\n    *,\n    desc: str = None,\n    outdir: PathType | None = None,\n    profile: str = \"default\",\n    **kwargs,\n) -&gt; bool:\n    \"\"\"Shortcut to run a pipeline\n\n    Args:\n        name: The name of the pipeline\n        starts: The start processes\n        data: The input data for the start processes\n        desc: The description of the pipeline\n        outdir: The output directory of the results\n        profile: The profile to use\n        **kwargs: Other options pass to Pipen to create the pipeline\n\n    Returns:\n        True if the pipeline ends successfully else False\n    \"\"\"\n    pipeline = Pipen(\n        name=name,\n        desc=desc,\n        outdir=outdir,\n        **kwargs,\n    )\n    pipeline.set_starts(starts).set_data(data)\n    return pipeline.run(profile)\n</code></pre>"},{"location":"api/source/pipen.pluginmgr/","title":"pipen.pluginmgr","text":""},{"location":"api/source/pipen.pluginmgr/","title":"SOURCE CODE pipen.pluginmgr DOCS","text":"<pre><code>\"\"\"Define hooks specifications and provide plugin manager\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom simplug import Simplug, SimplugResult\nfrom xqute import JobStatus, Scheduler\n\nfrom .defaults import ProcOutputType\n\n\nif TYPE_CHECKING:  # pragma: no cover\n    import signal\n    from xqute import Xqute\n    from .job import Job\n    from .proc import Proc\n    from .pipen import Pipen\n\nplugin = Simplug(\"pipen\")\n\n\n@plugin.specDOCS\ndef on_setup(pipen: Pipen) -&gt; None:\n    \"\"\"Setup for plugins, primarily used for the plugins to\n    setup some default configurations.\n\n    This is only called once for all pipelines.\n\n    Args:\n        pipen: The Pipen object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_init(pipen: Pipen) -&gt; None:\n    \"\"\"When the pipeline is initialized, and default configs are loaded\n\n    Args:\n        pipen: The Pipen object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_start(pipen: Pipen) -&gt; None:\n    \"\"\"Right before the pipeline starts running.\n\n    Process relationships are inferred.\n\n    Args:\n        pipen: The Pipen object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_complete(pipen: Pipen, succeeded: bool):\n    \"\"\"The the pipeline is completed.\n\n    Args:\n        pipen: The Pipen object\n        succeeded: Whether the pipeline has successfully completed.\n    \"\"\"\n\n\n@plugin.specDOCS\ndef on_proc_create(proc: Proc):\n    \"\"\"Called Proc constructor when a process is created.\n\n    Enables plugins to modify the default attributes of processes\n\n    Args:\n        proc: The Proc object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_proc_init(proc: Proc):\n    \"\"\"Called when a process is initialized.\n\n    Allows plugins to modify the process attributes after initialization, but\n    before the jobs are initialized.\n\n    Args:\n        proc: The Proc object\n    \"\"\"\n\n\n@plugin.specDOCS\ndef on_proc_input_computed(proc: Proc):\n    \"\"\"Called after process input data is computed.\n\n    Args:\n        proc: The Proc object\n    \"\"\"\n\n\n@plugin.specDOCS\ndef on_proc_script_computed(proc: Proc):\n    \"\"\"Called after process script is computed.\n\n    The script is computed as a string that is about to compiled into a\n    template.\n\n    Args:\n        proc: The Proc object\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_proc_start(proc: Proc):\n    \"\"\"When a process is starting\n\n    Args:\n        proc: The process\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\ndef on_proc_shutdown(proc: Proc, sig: signal.Signals) -&gt; None:\n    \"\"\"When pipeline is shutting down, by Ctrl-c for example.\n\n    Return False to stop shutting down, but you have to shut it down\n    by yourself, for example, `proc.xqute.task.cancel()`\n\n    Only the first return value will be used.\n\n    Args:\n        pipen: The xqute object\n        sig: The signal. `None` means a natural shutdown\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_proc_done(proc: Proc, succeeded: bool | str) -&gt; None:\n    \"\"\"When a process is done\n\n    Args:\n        proc: The process\n        succeeded: Whether the process succeeded or not. 'cached' if all jobs\n            are cached.\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_init(job: Job):\n    \"\"\"When a job is initialized\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_queued(job: Job):\n    \"\"\"When a job is queued in xqute. Note it might not be queued yet in\n    the scheduler system.\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\nasync def on_job_submitting(job: Job) -&gt; bool:\n    \"\"\"When a job is submitting.\n\n    The first plugin (based on priority) have this hook return False will\n    cancel the submission\n\n    Args:\n        job: The job\n\n    Returns:\n        False to cancel submission\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_submitted(job: Job):\n    \"\"\"When a job is submitted in the scheduler system.\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_started(job: Job):\n    \"\"\"When a job starts to run in then scheduler system.\n\n    Note that the job might not be running yet in the scheduler system.\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_polling(job: Job, counter: int):\n    \"\"\"When status of a job is being polled.\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.TRY_ALL_FIRST_AVAIL)DOCS\nasync def on_job_killing(job: Job) -&gt; bool:\n    \"\"\"When a job is being killed.\n\n    The first plugin (based on priority) have this hook return False will\n    cancel the killing\n\n    Args:\n        job: The job\n\n    Returns:\n        False to cancel killing\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_killed(job: Job):\n    \"\"\"When a job is killed\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_succeeded(job: Job):\n    \"\"\"When a job completes successfully.\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_cached(job: Job):\n    \"\"\"When a job is cached.\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.specDOCS\nasync def on_job_failed(job: Job):\n    \"\"\"When a job is done but failed.\n\n    Args:\n        job: The job\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_init(job: Job) -&gt; str:\n    \"\"\"When the job command wrapper script is initialized before the prescript is run\n\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n\n    The code will replace the `#![jobcmd_init]` placeholder in the wrapped job script.\n    See also &lt;https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95&gt;\n\n    Args:\n        job: The job object\n\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_prep(job: Job) -&gt; str:\n    \"\"\"When the job command right about to be run\n\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n\n    The bash variable `$cmd` is accessible in the context. It is also possible to\n    modify the `cmd` variable. Just remember to assign the modified value to `cmd`.\n\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n    Keep in mind that the `$cmd` may be modified by other plugins.\n\n    The code will replace the `#![jobcmd_prep]` placeholder in the wrapped job script.\n    See also &lt;https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95&gt;\n\n    Args:\n        job: The job object\n\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\n@plugin.spec(result=SimplugResult.ALL_AVAILS)DOCS\ndef on_jobcmd_end(job: Job) -&gt; str:\n    \"\"\"When the job command finishes and after the postscript is run\n\n    This should return a piece of bash code to be inserted in the wrapped job\n    script (template), which is a python template string, with the following\n    variables available: `status` and `job`. `status` is the class `JobStatus` from\n    `xqute.defaults.py` and `job` is the `Job` instance.\n\n    The bash variable `$rc` is accessible in the context, which is the return code\n    of the job command.\n\n    For multiple plugins, the code will be inserted in the order of the plugin priority.\n\n    The code will replace the `#![jobcmd_end]` placeholder in the wrapped job script.\n    See also &lt;https://github.com/pwwang/xqute/blob/master/xqute/defaults.py#L95&gt;\n\n    Args:\n        job: The job object\n\n    Returns:\n        The bash code to be inserted\n    \"\"\"\n\n\nclass PipenMainPlugin:DOCS\n    \"\"\"The builtin core plugin, used to update the progress bar and\n    cache the job\"\"\"\n\n    name = \"core\"\n    # The priority is set to -1000 to make sure it is the first plugin\n    # to be called\n    priority = -1000\n\n    @plugin.impl\n    def on_proc_shutdown(proc: Proc, sig: signal.Signals):\n        \"\"\"When a process is shutting down\"\"\"\n        if sig:  # pragma: no cover\n            proc.log(\n                \"warning\",\n                \"Got signal %r, trying a graceful shutdown ...\",\n                sig.name,\n            )\n\n    @plugin.impl\n    async def on_job_submitted(job: Job):\n        \"\"\"Update the progress bar when a job is submitted\"\"\"\n        job.proc.pbar.update_job_submitted()\n\n    @plugin.impl\n    async def on_job_started(job: Job):\n        \"\"\"Update the progress bar when a job starts to run\"\"\"\n        job.proc.pbar.update_job_running()\n\n    @plugin.impl\n    async def on_job_cached(job: Job):\n        \"\"\"Update the progress bar when a job is cached\"\"\"\n        job.proc.pbar.update_job_submitted()\n        job.proc.pbar.update_job_running()\n        job.proc.pbar.update_job_succeeded()\n        job.status = JobStatus.FINISHED\n\n    @plugin.impl\n    async def on_job_succeeded(job: Job):\n        \"\"\"Cache the job and update the progress bar when a job is succeeded\"\"\"\n        # now the returncode is 0, however, we need to check if output files\n        # have been created or not, this makes sure job.cache not fail\n        for outkey, outtype in job._output_types.items():\n            if outtype == ProcOutputType.VAR:\n                continue\n\n            path = job.output[outkey].spec\n            output_exists = path.exists()\n            if outtype == ProcOutputType.DIR:\n                output_exists = len(list(path.iterdir())) &gt; 0\n\n            if not output_exists:\n                job.status = JobStatus.FAILED\n                job.proc.pbar.update_job_failed()\n                try:\n                    # in case the stderr file in the cloud not being synced yet\n                    stderr = job.stderr_file.read_text()\n                except Exception:  # pragma: no cover\n                    stderr = \"\"\n\n                stderr = f\"{stderr}\\n\\nOutput {outtype} {outkey!r} is not generated\"\n                if outtype == ProcOutputType.DIR:\n                    stderr += \" or is empty.\"\n                else:\n                    stderr += \".\"\n                job.stderr_file.write_text(stderr)\n                break\n        else:\n            await job.cache()\n            job.proc.pbar.update_job_succeeded()\n\n    @plugin.impl\n    async def on_job_failed(job: Job):\n        \"\"\"Update the progress bar when a job is failed\"\"\"\n        job.proc.pbar.update_job_failed()\n        if job.status == JobStatus.RETRYING:\n            job.log(\"debug\", \"Retrying #%s\", job.trial_count + 1)\n            job.proc.pbar.update_job_retrying()\n\n    @plugin.impl\n    async def on_job_killed(job: Job):\n        \"\"\"Update the status of a killed job\"\"\"\n        # instead of FINISHED to force the whole pipeline to quit\n        job.status = JobStatus.FAILED  # pragma: no cover\n\n\nplugin.register(PipenMainPlugin)\n\nxqute_plugin = Simplug(\"xqute\")\n\n\nclass XqutePipenPlugin:DOCS\n    \"\"\"The plugin for xqute working as proxy for pipen plugin hooks\"\"\"\n\n    name = \"xqute.pipen\"\n\n    @xqute_plugin.impl\n    def on_shutdown(xqute: Xqute, sig: signal.Signals):\n        \"\"\"When a process is shutting down\"\"\"\n        return plugin.hooks.on_proc_shutdown(xqute.proc, sig)\n\n    @xqute_plugin.impl\n    async def on_job_init(scheduler: Scheduler, job: Job):\n        \"\"\"When a job is initialized\"\"\"\n        await plugin.hooks.on_job_init(job)\n\n    @xqute_plugin.impl\n    async def on_job_queued(scheduler: Scheduler, job: Job):\n        \"\"\"When a job is queued\"\"\"\n        await plugin.hooks.on_job_queued(job)\n\n    @xqute_plugin.impl\n    async def on_job_submitting(scheduler: Scheduler, job: Job):\n        \"\"\"When a job is being submitted\"\"\"\n        return await plugin.hooks.on_job_submitting(job)\n\n    @xqute_plugin.impl\n    async def on_job_submitted(scheduler: Scheduler, job: Job):\n        \"\"\"When a job is submitted\"\"\"\n        await plugin.hooks.on_job_submitted(job)\n\n    @xqute_plugin.impl\n    async def on_job_started(scheduler: Scheduler, job: Job):\n        \"\"\"When a job starts to run\"\"\"\n        await plugin.hooks.on_job_started(job)\n\n    @xqute_plugin.impl\n    async def on_job_polling(scheduler: Scheduler, job: Job, counter: int):\n        \"\"\"When a job starts to run\"\"\"\n        await plugin.hooks.on_job_polling(job, counter)\n\n    @xqute_plugin.impl\n    async def on_job_killing(scheduler: Scheduler, job: Job):\n        \"\"\"When a job is being killed\"\"\"\n        return await plugin.hooks.on_job_killing(job)  # pragma: no cover\n\n    @xqute_plugin.impl\n    async def on_job_killed(scheduler: Scheduler, job: Job):\n        \"\"\"When a job is killed\"\"\"\n        await plugin.hooks.on_job_killed(job)  # pragma: no cover\n\n    @xqute_plugin.impl\n    async def on_job_succeeded(scheduler: Scheduler, job: Job):\n        \"\"\"When a job is succeeded\"\"\"\n        await plugin.hooks.on_job_succeeded(job)\n\n    @xqute_plugin.impl\n    async def on_job_failed(scheduler: Scheduler, job: Job):\n        \"\"\"When a job is failed\"\"\"\n        await plugin.hooks.on_job_failed(job)\n\n    @xqute_plugin.impl\n    def on_jobcmd_init(scheduler: Scheduler, job: Job):\n        \"\"\"When the job command wrapper script is initialized\"\"\"\n        codes = plugin.hooks.on_jobcmd_init(job)\n        if not codes:\n            return None\n        return \"\\n\\n\".join(codes)\n\n    @xqute_plugin.impl\n    def on_jobcmd_prep(scheduler: Scheduler, job: Job):\n        \"\"\"When the job command is about to be run\"\"\"\n        codes = plugin.hooks.on_jobcmd_prep(job)\n        if not codes:\n            return None\n        return \"\\n\\n\".join(codes)\n\n    @xqute_plugin.impl\n    def on_jobcmd_end(scheduler: Scheduler, job: Job):\n        \"\"\"When the job command finishes\"\"\"\n        codes = plugin.hooks.on_jobcmd_end(job)\n        if not codes:\n            return None\n        return \"\\n\\n\".join(codes)\n\n\nxqute_plugin.register(XqutePipenPlugin)\n</code></pre>"},{"location":"api/source/pipen.proc/","title":"pipen.proc","text":""},{"location":"api/source/pipen.proc/","title":"SOURCE CODE pipen.proc DOCS","text":"<pre><code>\"\"\"Provides the process class: Proc\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport inspect\nimport logging\nfrom abc import ABC, ABCMeta\nfrom functools import cached_property\nfrom os import PathLike\nfrom pathlib import Path\nfrom typing import (\n    Any,\n    Dict,\n    List,\n    Mapping,\n    Sequence,\n    Type,\n    TYPE_CHECKING,\n)\n\nfrom diot import Diot\nfrom rich import box\nfrom rich.panel import Panel\nfrom varname import VarnameException, varname\nfrom yunpath import AnyPath\nfrom xqute import JobStatus, Xqute\n\nfrom .defaults import ProcInputType\nfrom .exceptions import (\n    ProcInputKeyError,\n    ProcInputTypeError,\n    ProcScriptFileNotFound,\n    PipenOrProcNameError,\n)\nfrom .pluginmgr import plugin\nfrom .scheduler import get_scheduler\nfrom .template import Template, get_template_engine\nfrom .utils import (\n    brief_list,\n    copy_dict,\n    desc_from_docstring,\n    get_logpanel_width,\n    ignore_firstline_dedent,\n    is_subclass,\n    is_valid_name,\n    log_rich_renderable,\n    logger,\n    make_df_colnames_unique_inplace,\n    strsplit,\n    update_dict,\n    get_shebang,\n    get_base,\n)\n\nif TYPE_CHECKING:  # pragma: no cover\n    from .pipen import Pipen\n    from .scheduler import Scheduler\n\n\nclass ProcMeta(ABCMeta):DOCS\n    \"\"\"Meta class for Proc\"\"\"\n\n    _INSTANCES: Dict[Type, Proc] = {}\n\n    def __repr__(cls) -&gt; str:DOCS\n        \"\"\"Representation for the Proc subclasses\"\"\"\n        return f\"&lt;Proc:{cls.name}&gt;\"\n\n    def __setattr__(cls, name: str, value: Any) -&gt; None:\n        if name == \"requires\":\n            value = cls._compute_requires(value)\n        return super().__setattr__(name, value)\n\n    def __call__(cls, *args: Any, **kwds: Any) -&gt; Proc:DOCS\n        \"\"\"Make sure Proc subclasses are singletons\n\n        Args:\n            *args: and\n            **kwds: Arguments for the constructor\n\n        Returns:\n            The Proc instance\n        \"\"\"\n        if cls not in cls._INSTANCES:\n            cls._INSTANCES[cls] = super().__call__(*args, **kwds)\n\n        return cls._INSTANCES[cls]\n\n\nclass Proc(ABC, metaclass=ProcMeta):DOCS\n    \"\"\"The abstract class for processes.\n\n    It's an abstract class. You can't instantise a process using it directly.\n    You have to subclass it. The subclass itself can be used as a process\n    directly.\n\n    Each subclass is a singleton, so to intantise a new process, each subclass\n    an existing `Proc` subclass, or use `Proc.from_proc()`.\n\n    Never use the constructor directly. The Proc is designed\n    as a singleton class, and is instansiated internally.\n\n    Attributes:\n        name: The name of the process. Will use the class name by default.\n        desc: The description of the process. Will use the summary from\n            the docstring by default.\n        envs: The arguments that are job-independent, useful for common options\n            across jobs.\n        envs_depth: How deep to update the envs when subclassed.\n        cache: Should we detect whether the jobs are cached?\n        dirsig: When checking the signature for caching, whether should we walk\n            through the content of the directory? This is sometimes\n            time-consuming if the directory is big.\n        export: When True, the results will be exported to `&lt;pipeline.outdir&gt;`\n            Defaults to None, meaning only end processes will export.\n            You can set it to True/False to enable or disable exporting\n            for processes\n        error_strategy: How to deal with the errors\n            - retry, ignore, halt\n            - halt to halt the whole pipeline, no submitting new jobs\n            - terminate to just terminate the job itself\n        num_retries: How many times to retry to jobs once error occurs\n        template: Define the template engine to use.\n            This could be either a template engine or a dict with key `engine`\n            indicating the template engine and the rest the arguments passed\n            to the constructor of the `pipen.template.Template` object.\n            The template engine could be either the name of the engine,\n            currently jinja2 and liquidpy are supported, or a subclass of\n            `pipen.template.Template`.\n            You can subclass `pipen.template.Template` to use your own template\n            engine.\n        forks: How many jobs to run simultaneously?\n        input: The keys for the input channel\n        input_data: The input data (will be computed for dependent processes)\n        lang: The language for the script to run. Should be the path to the\n            interpreter if `lang` is not in `$PATH`.\n        order: The execution order for this process. The bigger the number\n            is, the later the process will be executed. Default: 0.\n            Note that the dependent processes will always be executed first.\n            This doesn't work for start processes either, whose orders are\n            determined by `Pipen.set_starts()`\n        output: The output keys for the output channel\n            (the data will be computed)\n        plugin_opts: Options for process-level plugins\n        requires: The dependency processes\n        scheduler: The scheduler to run the jobs\n        scheduler_opts: The options for the scheduler\n        script: The script template for the process\n        submission_batch: How many jobs to be submited simultaneously\n\n        nexts: Computed from `requires` to build the process relationships\n        output_data: The output data (to pass to the next processes)\n    \"\"\"\n\n    name: str = None\n    desc: str = None\n    envs: Mapping[str, Any] = None\n    envs_depth: int = None\n    cache: bool = None\n    dirsig: bool = None\n    export: bool = None\n    error_strategy: str = None\n    num_retries: int = None\n    template: str | Type[Template] = None\n    template_opts: Mapping[str, Any] = None\n    forks: int = None\n    input: str | Sequence[str] = None\n    input_data: Any = None\n    lang: str = None\n    order: int = None\n    output: str | Sequence[str] = None\n    plugin_opts: Mapping[str, Any] = None\n    requires: Type[Proc] | Sequence[Type[Proc]] = None\n    scheduler: str = None\n    scheduler_opts: Mapping[str, Any] = None\n    script: str = None\n    submission_batch: int = None\n\n    nexts: Sequence[Type[Proc]] = None\n    output_data: Any = None\n    workdir: PathLike = None\n    # metadata that marks the process\n    # Can also be used for plugins\n    # It's not inheirted\n    __meta__: Mapping[str, Any] = None\n\n    @classmethodDOCS\n    def from_proc(\n        cls,\n        proc: Type[Proc],\n        name: str = None,\n        desc: str = None,\n        envs: Mapping[str, Any] = None,\n        envs_depth: int = None,\n        cache: bool = None,\n        export: bool = None,\n        error_strategy: str = None,\n        num_retries: int = None,\n        forks: int = None,\n        input_data: Any = None,\n        order: int = None,\n        plugin_opts: Mapping[str, Any] = None,\n        requires: Sequence[Type[Proc]] = None,\n        scheduler: str = None,\n        scheduler_opts: Mapping[str, Any] = None,\n        submission_batch: int = None,\n    ) -&gt; Type[Proc]:\n        \"\"\"Create a subclass of Proc using another Proc subclass or Proc itself\n\n        Args:\n            proc: The Proc subclass\n            name: The new name of the process\n            desc: The new description of the process\n            envs: The arguments of the process, will overwrite parent one\n                The items that are specified will be inherited\n            envs_depth: How deep to update the envs when subclassed.\n            cache: Whether we should check the cache for the jobs\n            export: When True, the results will be exported to\n                `&lt;pipeline.outdir&gt;`\n                Defaults to None, meaning only end processes will export.\n                You can set it to True/False to enable or disable exporting\n                for processes\n            error_strategy: How to deal with the errors\n                - retry, ignore, halt\n                - halt to halt the whole pipeline, no submitting new jobs\n                - terminate to just terminate the job itself\n            num_retries: How many times to retry to jobs once error occurs\n            forks: New forks for the new process\n            input_data: The input data for the process. Only when this process\n                is a start process\n            order: The order to execute the new process\n            plugin_opts: The new plugin options, unspecified items will be\n                inherited.\n            requires: The required processes for the new process\n            scheduler: The new shedular to run the new process\n            scheduler_opts: The new scheduler options, unspecified items will\n                be inherited.\n            submission_batch: How many jobs to be submited simultaneously\n\n        Returns:\n            The new process class\n        \"\"\"\n        if not name:\n            try:\n                name = varname()  # type: ignore\n            except VarnameException as vexc:  # pragma: no cover\n                raise ValueError(\n                    \"Process name cannot be detected from assignment, \"\n                    \"pass one explicitly to `Proc.from_proc(..., name=...)`\"\n                ) from vexc\n\n        kwargs: Dict[str, Any] = {\n            \"name\": name,\n            \"export\": export,\n            \"input_data\": input_data,\n            \"requires\": requires,\n            \"nexts\": None,\n            \"output_data\": None,\n        }\n\n        locs = locals()\n        for key in (\n            \"desc\",\n            \"envs\",\n            \"envs_depth\",\n            \"cache\",\n            \"forks\",\n            \"order\",\n            \"plugin_opts\",\n            \"scheduler\",\n            \"scheduler_opts\",\n            \"error_strategy\",\n            \"num_retries\",\n            \"submission_batch\",\n        ):\n            if locs[key] is not None:\n                kwargs[key] = locs[key]\n\n        kwargs[\"__doc__\"] = proc.__doc__\n        out = type(name, (proc,), kwargs)\n        return out\n\n    def __init_subclass__(cls) -&gt; None:DOCS\n        \"\"\"Do the requirements inferring since we need them to build up the\n        process relationship\n        \"\"\"\n        base = [\n            mro\n            for mro in cls.__mro__\n            if issubclass(mro, Proc) and mro is not Proc and mro is not cls\n        ]\n        parent = base[0] if base else None\n        # cls.requires = cls._compute_requires()\n        # triggers cls.__setattr__() to compute requires\n        cls.nexts = []\n        cls.requires = cls.requires\n\n        if cls.name is None or (parent and cls.name == parent.name):\n            cls.name = cls.__name__\n\n        if not is_valid_name(cls.name):\n            raise PipenOrProcNameError(\n                f\"{cls.name} is not a valid process name, expecting \" r\"'^[\\w.-]+$'\"\n            )\n\n        envs = update_dict(\n            parent.envs if parent else None,\n            cls.envs,\n            depth=0 if not parent or parent.envs_depth is None else parent.envs_depth,\n        )\n        # So values can be accessed like Proc.envs.a.b\n        cls.envs = envs if isinstance(envs, Diot) else Diot(envs or {})\n        cls.plugin_opts = update_dict(\n            parent.plugin_opts if parent else None,\n            cls.plugin_opts,\n            try_list=True,\n        )\n        cls.scheduler_opts = update_dict(\n            parent.scheduler_opts if parent else {},\n            cls.scheduler_opts,\n            try_list=True,\n        )\n        cls.__meta__ = {\"procgroup\": None}\n\n    def __init__(self, pipeline: Pipen = None) -&gt; None:\n        \"\"\"Constructor\n\n        This is called only at runtime.\n\n        Args:\n            pipeline: The Pipen object\n        \"\"\"\n        # instance properties\n        self.pipeline = pipeline\n\n        self.pbar = None\n        self.jobs: List[Any] = []\n        self.xqute: Xqute | None = None\n        self.__class__.workdir = (\n            AnyPath(self.pipeline.workdir) / self.name  # type: ignore\n        )\n        # plugins can modify some default attributes\n        plugin.hooks.on_proc_create(self)\n\n        # Compute the properties\n        # otherwise, the property can be accessed directly from class vars\n        if self.desc is None:\n            self.desc: str = desc_from_docstring(self.__class__, Proc)\n\n        if self.export is None:\n            self.export = bool(not self.nexts)\n\n        # log the basic information\n        self._log_info()\n\n        # template\n        self.template = get_template_engine(\n            self.template or self.pipeline.config.template\n        )\n        template_opts = copy_dict(self.pipeline.config.template_opts)\n        template_opts.update(self.template_opts or {})\n        self.template_opts = template_opts\n\n        plugin_opts = copy_dict(self.pipeline.config.plugin_opts)\n        plugin_opts.update(self.plugin_opts or {})\n        self.plugin_opts = plugin_opts\n\n        # input\n        self.input = self._compute_input()  # type: ignore\n        # output\n        self.output = self._compute_output()\n        plugin.hooks.on_proc_input_computed(self)\n        # scheduler\n        self.scheduler: Type[Scheduler] = get_scheduler(  # type: ignore\n            self.scheduler or self.pipeline.config.scheduler\n        )\n        # script\n        self.script = self._compute_script()  # type: ignore\n        self.workdir.mkdir(exist_ok=True)\n\n        if self.submission_batch is None:\n            self.submission_batch = self.pipeline.config.submission_batch\n\n    async def init(self) -&gt; None:DOCS\n        \"\"\"Init all other properties and jobs\"\"\"\n        import pandas\n\n        scheduler_opts = copy_dict(self.pipeline.config.scheduler_opts or {}, -1)\n        scheduler_opts = update_dict(\n            scheduler_opts,\n            self.scheduler_opts or {},\n            try_list=True,\n        )\n\n        self.xqute = Xqute(\n            self.scheduler,\n            workdir=self.workdir,\n            submission_batch=self.submission_batch,\n            error_strategy=self.error_strategy or self.pipeline.config.error_strategy,\n            num_retries=(\n                self.pipeline.config.num_retries\n                if self.num_retries is None\n                else self.num_retries\n            ),\n            forks=self.forks or self.pipeline.config.forks,\n            jobname_prefix=self.name,\n            scheduler_opts=scheduler_opts,\n        )\n        self.xqute.scheduler.post_init(self)\n        # for the plugin hooks to access\n        self.xqute.proc = self\n\n        await plugin.hooks.on_proc_init(self)\n        await self._init_jobs()\n        self.__class__.output_data = pandas.DataFrame((job.output for job in self.jobs))\n\n    def gc(self):DOCS\n        \"\"\"GC process for the process to save memory after it's done\"\"\"\n        del self.xqute.jobs[:]\n        self.xqute.jobs = []\n\n        del self.xqute\n        self.xqute = None\n\n        del self.jobs[:]\n        self.jobs = []\n\n        del self.pbar\n        self.pbar = None\n\n    def log(DOCS\n        self,\n        level: int | str,\n        msg: str,\n        *args,\n        logger: logging.LoggerAdapter = logger,\n    ) -&gt; None:\n        \"\"\"Log message for the process\n\n        Args:\n            level: The log level of the record\n            msg: The message to log\n            *args: The arguments to format the message\n            logger: The logging logger\n        \"\"\"\n        msg = msg % args\n        if not isinstance(level, int):\n            level = logging.getLevelName(level.upper())\n        logger.log(\n            level,  # type: ignore\n            \"[cyan]%s:[/cyan] %s\",\n            self.name,\n            msg,\n        )\n\n    async def run(self) -&gt; None:DOCS\n        \"\"\"Run the process\"\"\"\n        # init pbar\n        self.pbar = self.pipeline.pbar.proc_bar(self.size, self.name)\n\n        await plugin.hooks.on_proc_start(self)\n\n        cached_jobs = []\n        for job in self.jobs:\n            if await job.cached:\n                cached_jobs.append(job.index)\n                await plugin.hooks.on_job_cached(job)\n            else:\n                envs = {\n                    \"PIPEN_JOB_INDEX\": job.index,\n                    \"PIPEN_JOB_METADIR_SPEC\": str(job.metadir),\n                    \"PIPEN_JOB_OUTDIR_SPEC\": str(job._outdir),\n                    \"PIPEN_JOB_METADIR\": str(job.metadir.mounted),\n                    \"PIPEN_JOB_OUTDIR\": str(job._outdir.mounted),\n                }\n                await self.xqute.put(job, envs=envs)\n        if cached_jobs:\n            self.log(\"info\", \"Cached jobs: [%s]\", brief_list(cached_jobs))\n        await self.xqute.run_until_complete()\n        self.pbar.done()\n        await plugin.hooks.on_proc_done(\n            self,\n            (\n                False\n                if not self.succeeded\n                else \"cached\" if len(cached_jobs) == self.size else True\n            ),\n        )\n\n    # properties\n    @cached_property\n    def size(self) -&gt; int:\n        \"\"\"The size of the process (# of jobs)\"\"\"\n        return len(self.jobs)\n\n    @cached_property\n    def succeeded(self) -&gt; bool:\n        \"\"\"Check if the process is succeeded (all jobs succeeded)\"\"\"\n        return all(job.status == JobStatus.FINISHED for job in self.jobs)\n\n    # Private methods\n    @classmethod\n    def _compute_requires(\n        cls,\n        requires: Type[Proc] | Sequence[Type[Proc]] = None,\n    ) -&gt; Sequence[Type[Proc]]:\n        \"\"\"Compute the required processes and fill the nexts\n\n        Args:\n            requires: The required processes. If None, will use `cls.requires`\n\n        Returns:\n            None or sequence of Proc subclasses\n        \"\"\"\n        if requires is None:\n            requires = cls.requires\n\n        if requires is None:\n            return requires\n\n        if is_subclass(requires, Proc):\n            requires = [requires]  # type: ignore\n\n        # if req is in cls.__bases__, then cls.nexts will be affected by\n        # req.nexts\n        my_nexts = None if cls.nexts is None else cls.nexts[:]\n        for req in requires:  # type: ignore\n            if not req.nexts:\n                req.nexts = [cls]\n            else:\n                req.nexts.append(cls)  # type: ignore\n        cls.nexts = my_nexts\n\n        return requires  # type: ignore\n\n    async def _init_job(self, worker_id: int) -&gt; None:\n        \"\"\"A worker to initialize jobs\n\n        Args:\n            worker_id: The worker id\n        \"\"\"\n        for job in self.jobs:\n            if job.index % self.submission_batch != worker_id:\n                continue\n            await job.prepare(self)\n\n    async def _init_jobs(self) -&gt; None:\n        \"\"\"Initialize all jobs\n\n        Args:\n            config: The pipeline configuration\n        \"\"\"\n        for i in range(self.input.data.shape[0]):\n            job = self.xqute.scheduler.create_job(i, \"\")\n            self.jobs.append(job)\n\n        await asyncio.gather(*(self._init_job(i) for i in range(self.submission_batch)))\n\n    def _compute_input(self) -&gt; Mapping[str, Mapping[str, Any]]:\n        \"\"\"Calculate the input based on input and input data\n\n        Returns:\n            A dict with type and data\n        \"\"\"\n        import pandas\n        from .channel import Channel\n\n        # split input keys into keys and types\n        input_keys = self.input\n        if input_keys and isinstance(input_keys, str):\n            input_keys = strsplit(input_keys, \",\")\n\n        if not input_keys:\n            raise ProcInputKeyError(f\"[{self.name}] No input provided\")\n\n        out = Diot(type={}, data=None)\n        for input_key_type in input_keys:\n            if \":\" not in input_key_type:\n                out.type[input_key_type] = ProcInputType.VAR\n                continue\n\n            input_key, input_type = strsplit(input_key_type, \":\", 1)\n            if input_type not in ProcInputType.__dict__.values():\n                raise ProcInputTypeError(\n                    f\"[{self.name}] Unsupported input type: {input_type}\"\n                )\n            out.type[input_key] = input_type\n\n        # get the data\n        if not self.requires and self.input_data is None:\n            out.data = pandas.DataFrame([[None] * len(out.type)])\n        elif not self.requires:\n            out.data = Channel.create(self.input_data)\n        elif callable(self.input_data):\n            out.data = Channel.create(\n                self.__class__.input_data(\n                    *(req.output_data for req in self.requires)  # type: ignore\n                )\n            )\n        else:\n            if self.input_data:\n                self.log(\n                    \"warning\",\n                    \"Ignoring input data, this is not a start process.\",\n                )\n\n            out.data = pandas.concat(\n                (req.output_data for req in self.requires),  # type: ignore\n                axis=1,\n            ).ffill()\n\n        make_df_colnames_unique_inplace(out.data)\n\n        # try match the column names\n        # if none matched, use the first columns\n        # rest_cols = out.data.columns.difference(out.type, False)\n        rest_cols = [col for col in out.data.columns if col not in out.type]\n        len_rest_cols = len(rest_cols)\n        # matched_cols = out.data.columns.intersection(out.type)\n        matched_cols = [col for col in out.data.columns if col in out.type]\n        needed_cols = [col for col in out.type if col not in matched_cols]\n        len_needed_cols = len(needed_cols)\n\n        if len_rest_cols &gt; len_needed_cols:\n            self.log(\n                \"warning\",\n                \"Wasted %s column(s) of input data.\",\n                len_rest_cols - len_needed_cols,\n            )\n        elif len_rest_cols &lt; len_needed_cols:\n            self.log(\n                \"warning\",\n                \"No data column for input: %s, using None.\",\n                needed_cols[len_rest_cols:],\n            )\n            # Add None\n            # Use loop to keep order\n            for needed_col in needed_cols[len_rest_cols:]:\n                out.data.insert(out.data.shape[1], needed_col, None)\n            len_needed_cols = len_rest_cols\n\n        out.data = out.data.rename(\n            columns=dict(zip(rest_cols[:len_needed_cols], needed_cols))\n        ).loc[:, list(out.type)]\n\n        return out\n\n    def _compute_output(self) -&gt; str | List[str]:\n        \"\"\"Compute the output for jobs to render\"\"\"\n        if not self.output:\n            return None\n\n        if isinstance(self.output, (list, tuple)):\n            return [\n                self.template(oput, **self.template_opts)  # type: ignore\n                for oput in self.output\n            ]\n\n        return self.template(self.output, **self.template_opts)  # type: ignore\n\n    def _compute_script(self) -&gt; Template:\n        \"\"\"Compute the script for jobs to render\"\"\"\n        if not self.script:\n            self.log(\"warning\", \"No script specified.\")\n            return None\n\n        script = self.script\n        if script.startswith(\"file://\"):\n            script_file = Path(script[7:])\n            if not script_file.is_absolute():\n                base = get_base(\n                    self.__class__,\n                    Proc,\n                    script,\n                    lambda klass: getattr(klass, \"script\", None),\n                )\n                script_file = Path(inspect.getfile(base)).parent / script_file\n            if not script_file.is_file():\n                raise ProcScriptFileNotFound(f\"No such script file: {script_file}\")\n            script = script_file.read_text()\n\n        self.script = ignore_firstline_dedent(script)\n        if not self.lang:\n            self.lang = get_shebang(self.script)\n\n        plugin.hooks.on_proc_script_computed(self)\n        return self.template(self.script, **self.template_opts)  # type: ignore\n\n    def _log_info(self):\n        \"\"\"Log some basic information of the process\"\"\"\n        title = (\n            f\"{self.__meta__['procgroup'].name}/{self.name}\"\n            if self.__meta__[\"procgroup\"]\n            else self.name\n        )\n        panel = Panel(\n            self.desc or \"Undescribed\",\n            title=title,\n            box=(\n                box.Box(\n                    \"\u256d\u2550\u252c\u256e\\n\"\n                    \"\u2551 \u2551\u2551\\n\"\n                    \"\u251c\u2550\u253c\u2524\\n\"\n                    \"\u2551 \u2551\u2551\\n\"\n                    \"\u251c\u2550\u253c\u2524\\n\"\n                    \"\u251c\u2550\u253c\u2524\\n\"\n                    \"\u2551 \u2551\u2551\\n\"\n                    \"\u2570\u2550\u2534\u256f\\n\"\n                )\n                if self.export\n                else box.ROUNDED\n            ),\n            width=get_logpanel_width(),\n        )\n\n        logger.info(\"\")\n        log_rich_renderable(panel, \"cyan\", logger.info)\n        self.log(\"info\", \"workdir: %r\", str(self.workdir))\n        self.log(\n            \"info\",\n            \"[yellow]&lt;&lt;&lt;[/yellow] %s\",\n            [proc.name for proc in self.requires] if self.requires else \"[START]\",\n        )\n        self.log(\n            \"info\",\n            \"[yellow]&gt;&gt;&gt;[/yellow] %s\",\n            [proc.name for proc in self.nexts] if self.nexts else \"[END]\",\n        )\n</code></pre>"},{"location":"api/source/pipen.procgroup/","title":"pipen.procgroup","text":""},{"location":"api/source/pipen.procgroup/","title":"SOURCE CODE pipen.procgroup DOCS","text":"<pre><code>\"\"\"Process group that contains a set of processes.\n\nIt can be easily used to create a pipeline that runs independently or\nintegrated into a larger pipeline.\n\nRuns directly:\n&gt;&gt;&gt; proc_group = ProcGroup(&lt;options&gt;)\n&gt;&gt;&gt; proc_group.as_pipen(&lt;pipeline options&gt;).set_data(&lt;data&gt;).run()\n\nIntegrated into a larger pipeline\n&gt;&gt;&gt; proc_group = ProcGroup(&lt;options&gt;)\n&gt;&gt;&gt; # proc could be a process within the larger pipeline\n&gt;&gt;&gt; proc.requires = prog_group.&lt;proc&gt;\n\nTo add a process to the proc group, use the `add_proc` method:\n&gt;&gt;&gt; class MyProcGroup(ProcGroup):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt;\n&gt;&gt;&gt; proc_group = MyProcGroup(...)\n&gt;&gt;&gt; @proc_group.add_proc\n&gt;&gt;&gt; class MyProc(Proc):\n&gt;&gt;&gt;     ...\n\nOr add a process at runtime:\n&gt;&gt;&gt; class MyProcGroup(ProcGroup):\n&gt;&gt;&gt;     ...\n&gt;&gt;&gt;\n&gt;&gt;&gt;     @ProcGroup.add_proc\n&gt;&gt;&gt;     def my_proc(self):\n&gt;&gt;&gt;         class MyProc(Proc):\n&gt;&gt;&gt;             # You may use self.options here\n&gt;&gt;&gt;             ...\n&gt;&gt;&gt;         return MyProc\n&gt;&gt;&gt; proc_group = MyProcGroup(...)\n\"\"\"\nfrom __future__ import annotations\n\nfrom os import PathLike\nfrom functools import wraps, cached_property\nfrom typing import Any, Callable, Mapping, Type, List\nfrom abc import ABC, ABCMeta\nfrom diot import Diot\n\nfrom .pipen import Pipen\nfrom .proc import Proc\n\n\nclass ProcGropuMeta(ABCMeta):DOCS\n    \"\"\"Meta class for ProcGroup\"\"\"\n\n    _INST = None\n\n    def __call__(cls, *args, **kwds):DOCS\n        \"\"\"Make sure Proc subclasses are singletons\n\n        Args:\n            *args: and\n            **kwds: Arguments for the constructor\n\n        Returns:\n            The Proc instance\n        \"\"\"\n        if cls._INST is None:\n            cls._INST = super().__call__(*args, **kwds)\n\n        return cls._INST\n\n\nclass ProcGroup(ABC, metaclass=ProcGropuMeta):DOCS\n    \"\"\"A group of processes that can be run independently or\n    integrated into a larger pipeline.\n    \"\"\"\n\n    name: str | None = None\n    __meta__: Mapping[str, Any] = {}\n    DEFAULTS = Diot()\n    PRESERVED = {\n        \"opts\",\n        \"name\",\n        \"add_proc\",\n        \"as_pipen\",\n        \"procs\",\n        \"starts\",\n        \"DEFAULTS\",\n        \"PRESERVED\",\n        \"_INST\",\n    }\n\n    def __init_subclass__(cls) -&gt; None:DOCS\n        # Clear the meta\n        cls.__meta__ = {}\n\n    def __init__(self, **opts) -&gt; None:\n        self.opts = Diot(self.__class__.DEFAULTS or {}) | (opts or {})\n        self.name = self.__class__.name or self.__class__.__name__\n        self.starts: List[Type[Proc]] = []\n        self.procs = Diot()\n\n        self._load_runtime_procs()\n\n    def _load_runtime_procs(self):\n        \"\"\"Load all processes that are added at runtime\"\"\"\n        # Load all processes if they are decorated by ProcGroup.add_proc\n        for name, attr in self.__class__.__dict__.items():\n            if isinstance(attr, cached_property):\n                getattr(self, name)\n            elif isinstance(attr, type) and issubclass(attr, Proc):\n                self.add_proc(attr)\n\n    def add_proc(DOCS\n        self_or_method: ProcGroup | Callable[[ProcGroup], Type[Proc]],\n        proc: Type[Proc] | None = None,\n    ) -&gt; Type[Proc] | cached_property:\n        \"\"\"Add a process to the proc group\n\n        It works either as a decorator to the process directly or as a\n        decorator to a method that returns the process.\n\n        Args:\n            self_or_method: The proc group instance or a method that\n                returns the process\n            proc: The process class if `self_or_method` is the proc group\n\n        Returns:\n            The process class if `self_or_method` is the proc group, or\n            a cached property that returns the process class\n        \"\"\"\n        if isinstance(self_or_method, ProcGroup):\n            # Called as self.add_proc or pg.add_proc\n            if proc is None:\n                return self_or_method.add_proc  # type: ignore\n\n            if proc.name in self_or_method.__class__.PRESERVED:\n                raise ValueError(\n                    f\"Process name `{proc.name}` is reserved for ProcGroup\"\n                )\n\n            setattr(self_or_method, proc.name, proc)\n            proc.__meta__[\"procgroup\"] = self_or_method  # type: ignore\n            if not proc.requires and proc not in self_or_method.starts:\n                self_or_method.starts.append(proc)\n            self_or_method.procs[proc.name] = proc\n            return proc\n\n        @wraps(self_or_method)\n        def wrapper(self):\n            proc = self_or_method(self)\n\n            if proc is None:\n                return None\n\n            if (not isinstance(proc, type) or not issubclass(proc, Proc)):\n                raise ValueError(f\"`{proc}` is not a Proc subclass\")\n\n            proc.__meta__[\"procgroup\"] = self\n            if not proc.requires and proc not in self.starts:\n                self.starts.append(proc)\n            self.procs[proc.name] = proc\n            return proc\n\n        return cached_property(wrapper)\n\n    def as_pipen(DOCS\n        self,\n        name: str | None = None,\n        desc: str | None = None,\n        outdir: str | PathLike | None = None,\n        **kwargs,\n    ) -&gt; Pipen:\n        \"\"\"Convert the pipeline to a Pipen instance\n\n        Args:\n            name: The name of the pipeline\n            desc: The description of the pipeline\n            outdir: The output directory of the pipeline\n            **kwargs: The keyword arguments to pass to Pipen\n\n        Returns:\n            The Pipen instance\n        \"\"\"\n        name = name or self.__class__.__name__\n        if self.__doc__:\n            desc = desc or self.__doc__.lstrip().splitlines()[0]\n\n        pipe = Pipen(name=name, desc=desc, outdir=outdir, **kwargs)\n        pipe.set_start(self.starts)\n        return pipe\n</code></pre>"},{"location":"api/source/pipen.progressbar/","title":"pipen.progressbar","text":""},{"location":"api/source/pipen.progressbar/","title":"SOURCE CODE pipen.progressbar DOCS","text":"<pre><code>\"\"\"Provide the PipelinePBar and ProcPBar classes\"\"\"\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom .utils import truncate_text\n\nif TYPE_CHECKING:  # pragma: no cover\n    import enlighten\n\n# [12/02/20 12:44:06] I core\n#                 pipeline: 100%|\n# |        desc_len      |\nPBAR_DESC_LEN = 24\n\n\nclass ProcPBar:DOCS\n    \"\"\"The progress bar for processes\"\"\"\n\n    def __init__(\n        self, manager: enlighten.Manager, proc_size: int, proc_name: str\n    ) -&gt; None:\n        self.submitted_counter = manager.counter(\n            total=proc_size,\n            color=\"cyan\",\n            desc=proc_name,\n            unit=\"jobs\",\n            leave=False,\n        )\n        self.running_counter = self.submitted_counter.add_subcounter(\"yellow\")\n        self.success_counter = self.submitted_counter.add_subcounter(\"green\")\n        self.failure_counter = self.submitted_counter.add_subcounter(\"red\")\n\n    def update_job_submitted(self):DOCS\n        \"\"\"Update the progress bar when a job is submitted\"\"\"\n        self.submitted_counter.update()\n\n    def update_job_retrying(self):DOCS\n        \"\"\"Update the progress bar when a job is retrying\"\"\"\n        # self.running_counter.count -= 1\n        self.failure_counter.update(-1)\n\n    def update_job_running(self):DOCS\n        \"\"\"Update the progress bar when a job is running\"\"\"\n        try:\n            self.running_counter.update_from(self.submitted_counter)\n        except ValueError:  # pragma: no cover\n            pass\n\n    def update_job_succeeded(self):DOCS\n        \"\"\"Update the progress bar when a job is succeeded\"\"\"\n        try:\n            self.success_counter.update_from(self.running_counter)\n        except ValueError:  # pragma: no cover\n            try:\n                self.success_counter.update_from(self.submitted_counter)\n            except ValueError:  # pragma: no cover\n                pass\n        except:  # noqa: E722  # pragma: no cover\n            pass\n\n    def update_job_failed(self):DOCS\n        \"\"\"Update the progress bar when a job is failed\"\"\"\n        try:\n            self.failure_counter.update_from(self.running_counter)\n        except ValueError:  # pragma: no cover\n            try:\n                self.failure_counter.update_from(self.submitted_counter)\n            except ValueError:  # pragma: no cover\n                pass\n        except:  # noqa: E722  # pragma: no cover\n            pass\n\n    def done(self):DOCS\n        \"\"\"The process is done\"\"\"\n        try:\n            self.submitted_counter.close()\n        except:  # noqa: E722  # pragma: no cover\n            pass\n\n\nclass PipelinePBar:DOCS\n    \"\"\"Progress bar for the pipeline\"\"\"\n\n    def __init__(self, n_procs: int, ppln_name: str) -&gt; None:\n        \"\"\"Initialize progress bar for pipeline\"\"\"\n        import enlighten\n\n        desc_len = PBAR_DESC_LEN\n        ppln_name = truncate_text(ppln_name, desc_len)\n        self.manager = enlighten.get_manager()\n        self.running_counter = self.manager.counter(\n            total=n_procs,\n            color=\"yellow\",\n            desc=f\"{ppln_name:&gt;{desc_len}}:\",\n            unit=\"procs\",\n        )\n        self.success_counter = self.running_counter.add_subcounter(\"green\")\n        self.failure_counter = self.running_counter.add_subcounter(\"red\")\n        self.desc_len = desc_len\n\n    def proc_bar(self, proc_size: int, proc_name: str) -&gt; ProcPBar:DOCS\n        \"\"\"Get the progress bar for a process\n\n        Args:\n            proc_size: The size of the process\n            proc_name: The name of the process\n\n        Returns:\n            The progress bar for the given process\n        \"\"\"\n        proc_name = truncate_text(proc_name, self.desc_len)\n        proc_name = f\"{proc_name:&gt;{self.desc_len}}:\"\n        return ProcPBar(self.manager, proc_size, proc_name)\n\n    def update_proc_running(self):DOCS\n        \"\"\"Update the progress bar when a process is running\"\"\"\n        self.running_counter.update()\n\n    def update_proc_done(self):DOCS\n        \"\"\"Update the progress bar when a process is done\"\"\"\n        self.success_counter.update_from(self.running_counter)\n\n    def update_proc_error(self):DOCS\n        \"\"\"Update the progress bar when a process is errored\"\"\"\n        self.failure_counter.update_from(self.running_counter)\n\n    def done(self) -&gt; None:DOCS\n        \"\"\"When the pipeline is done\"\"\"\n        try:\n            self.running_counter.close()\n            self.manager.stop()\n        except:  # noqa: E722  # pragma: no cover\n            pass\n</code></pre>"},{"location":"api/source/pipen.scheduler/","title":"pipen.scheduler","text":""},{"location":"api/source/pipen.scheduler/","title":"SOURCE CODE pipen.scheduler DOCS","text":"<pre><code>\"\"\"Provide builting schedulers\"\"\"\n\nfrom __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Type\n\nfrom diot import Diot\n\n# Use cloudpathlib.GSPath instead of yunpath.GSPath,\n# the latter is a subclass of the former.\n# (_GSPath is cloudpathlib.GSPath)\nfrom yunpath.patch import _GSPath\nfrom xqute import Scheduler\nfrom xqute.schedulers.local_scheduler import LocalScheduler as XquteLocalScheduler\nfrom xqute.schedulers.sge_scheduler import SgeScheduler as XquteSgeScheduler\nfrom xqute.schedulers.slurm_scheduler import SlurmScheduler as XquteSlurmScheduler\nfrom xqute.schedulers.ssh_scheduler import SshScheduler as XquteSshScheduler\nfrom xqute.schedulers.gbatch_scheduler import (\n    GbatchScheduler as XquteGbatchScheduler,\n    DEFAULT_MOUNTED_ROOT,\n)\nfrom xqute.schedulers.container_scheduler import (\n    ContainerScheduler as XquteContainerScheduler,\n)\nfrom xqute.path import SpecPath\n\nfrom .defaults import SCHEDULER_ENTRY_GROUP\nfrom .exceptions import NoSuchSchedulerError, WrongSchedulerTypeError\nfrom .job import Job\nfrom .utils import is_subclass, load_entrypoints\n\nif TYPE_CHECKING:\n    from .proc import Proc\n\n\nclass SchedulerPostInit:DOCS\n    \"\"\"Provides post init function for all schedulers\"\"\"\n\n    job_class = Job\n\n    MOUNTED_METADIR: str\n    MOUNTED_OUTDIR: str\n\n    def post_init(self, proc: Proc) -&gt; None: ...  # noqa: E704\n\n\nclass LocalScheduler(SchedulerPostInit, XquteLocalScheduler):  # type: ignore[misc]DOCS\n    \"\"\"Local scheduler\"\"\"\n\n\nclass SgeScheduler(SchedulerPostInit, XquteSgeScheduler):  # type: ignore[misc]DOCS\n    \"\"\"SGE scheduler\"\"\"\n\n\nclass SlurmScheduler(SchedulerPostInit, XquteSlurmScheduler):  # type: ignore[misc]DOCS\n    \"\"\"Slurm scheduler\"\"\"\n\n\nclass SshScheduler(SchedulerPostInit, XquteSshScheduler):  # type: ignore[misc]DOCS\n    \"\"\"SSH scheduler\"\"\"\n\n\nclass GbatchScheduler(SchedulerPostInit, XquteGbatchScheduler):  # type: ignore[misc]DOCS\n    \"\"\"Google Cloud Batch scheduler\n\n    Args:\n        *args: Positional arguments for the base class\n        project: Google Cloud project ID\n        location: Google Cloud region or zone\n        mount: GCS path to mount (e.g. gs://my-bucket:/mnt/my-bucket)\n            You can pass a list of mounts.\n        service_account: GCP service account email (e.g. test-account@example.com)\n        network: GCP network (e.g. default-network)\n        subnetwork: GCP subnetwork (e.g. regions/us-central1/subnetworks/default)\n        no_external_ip_address: Whether to disable external IP address\n        machine_type: GCP machine type (e.g. e2-standard-4)\n        provisioning_model: GCP provisioning model (e.g. SPOT)\n        image_uri: Container image URI (e.g. ubuntu-2004-lts)\n        entrypoint: Container entrypoint (e.g. /bin/bash)\n        commands: The command list to run in the container.\n            There are three ways to specify the commands:\n            1. If no entrypoint is specified, the final command will be\n            [commands, wrapped_script], where the entrypoint is the wrapper script\n            interpreter that is determined by `JOBCMD_WRAPPER_LANG` (e.g. /bin/bash),\n            commands is the list you provided, and wrapped_script is the path to the\n            wrapped job script.\n            2. You can specify something like \"-c\", then the final command\n            will be [\"-c\", \"wrapper_script_interpreter, wrapper_script\"]\n            3. You can use the placeholders `{lang}` and `{script}` in the commands\n            list, where `{lang}` will be replaced with the interpreter (e.g. /bin/bash)\n            and `{script}` will be replaced with the path to the wrapped job script.\n            For example, you can specify [\"{lang} {script}\"] and the final command\n            will be [\"wrapper_interpreter, wrapper_script\"]\n        runnables: Additional runnables to run before or after the main job.\n            Each runnable should be a dictionary that follows the\n            [GCP Batch API specification](https://cloud.google.com/batch/docs/reference/rest/v1/projects.locations.jobs#runnable).\n            You can also specify an \"order\" key in the dictionary to control the\n            execution order of the runnables. Runnables with negative order\n            will be executed before the main job, and those with non-negative\n            order will be executed after the main job. The main job runnable\n            will always be executed in the order it is defined in the list.\n        **kwargs: Keyword arguments for the configuration of a job (e.g. taskGroups).\n            See more details at &lt;https://cloud.google.com/batch/docs/get-started&gt;.\n    \"\"\"  # noqa: E501\n\n    MOUNTED_METADIR: str = f\"{DEFAULT_MOUNTED_ROOT}/pipen-pipeline/workdir\"\n    MOUNTED_OUTDIR: str = f\"{DEFAULT_MOUNTED_ROOT}/pipen-pipeline/outdir\"\n\n    def post_init(self, proc: Proc):\n        super().post_init(proc)\n\n        # Check if pipeline outdir is a GSPath\n        if not isinstance(proc.pipeline.outdir, _GSPath):\n            raise ValueError(\n                \"'gbatch' scheduler requires google cloud storage 'outdir'.\"\n            )\n\n        mounted_workdir = f\"{self.MOUNTED_METADIR}/{proc.name}\"\n        self.workdir = SpecPath(\n            self.workdir,  # type: ignore\n            mounted=mounted_workdir,\n        )\n\n        # update the mounted metadir\n        # instead of mounting the workdir of this specific proc,\n        # we mount the parent dir (the pipeline workdir), because the procs\n        # of the pipeline may share files (e.g. input files from output of other procs)\n        self.config[\"taskGroups\"][0][\"taskSpec\"][\"volumes\"][0][\"gcs\"][\n            \"remotePath\"\n        ] = self.workdir.parent._no_prefix\n        self.config[\"taskGroups\"][0][\"taskSpec\"][\"volumes\"][0][\n            \"mountPath\"\n        ] = self.MOUNTED_METADIR\n\n        # update the config to map the outdir to vm\n        self.config[\"taskGroups\"][0][\"taskSpec\"][\"volumes\"].append(\n            Diot(\n                {\n                    \"gcs\": {\"remotePath\": proc.pipeline.outdir._no_prefix},\n                    \"mountPath\": self.MOUNTED_OUTDIR,\n                }\n            )\n        )\n\n        # add labels\n        self.config[\"labels\"][\"pipeline\"] = proc.pipeline.name.lower()\n        self.config[\"labels\"][\"proc\"] = proc.name.lower()\n\n\nclass ContainerScheduler(  # type: ignore[misc]DOCS\n    SchedulerPostInit,\n    XquteContainerScheduler,\n):\n    \"\"\"Scheduler to run jobs via containers (Docker/Podman/Apptainer)\"\"\"\n\n    MOUNTED_METADIR: str = f\"{DEFAULT_MOUNTED_ROOT}/pipen-pipeline/workdir\"\n    MOUNTED_OUTDIR: str = f\"{DEFAULT_MOUNTED_ROOT}/pipen-pipeline/outdir\"\n\n    def post_init(self, proc: Proc):\n        super().post_init(proc)\n\n        mounted_workdir = f\"{self.MOUNTED_METADIR}/{proc.name}\"\n        self.workdir = SpecPath(\n            str(self.workdir),  # ignore the mounted_workdir by xqute\n            mounted=mounted_workdir,\n        )\n        self.volumes[-1] = f\"{self.workdir}:{self.workdir.mounted}\"  # type: ignore\n        proc.pipeline.outdir.mkdir(parents=True, exist_ok=True)  # type: ignore\n        self.volumes.append(f\"{proc.pipeline.outdir}:{self.MOUNTED_OUTDIR}\")\n\n\ndef get_scheduler(scheduler: str | Type[Scheduler]) -&gt; Type[Scheduler]:DOCS\n    \"\"\"Get the scheduler by name of the scheduler class itself\n\n    Args:\n        scheduler: The scheduler class or name\n\n    Returns:\n        The scheduler class\n    \"\"\"\n    if is_subclass(scheduler, Scheduler):\n        return scheduler  # type: ignore\n\n    if scheduler == \"local\":\n        return LocalScheduler\n\n    if scheduler == \"sge\":\n        return SgeScheduler\n\n    if scheduler == \"slurm\":\n        return SlurmScheduler\n\n    if scheduler == \"ssh\":\n        return SshScheduler\n\n    if scheduler == \"gbatch\":\n        return GbatchScheduler\n\n    if scheduler == \"container\":\n        return ContainerScheduler\n\n    for n, obj in load_entrypoints(SCHEDULER_ENTRY_GROUP):  # pragma: no cover\n        if n == scheduler:\n            if not is_subclass(obj, Scheduler):\n                raise WrongSchedulerTypeError(\n                    \"Scheduler should be a subclass of \" \"pipen.scheduler.Scheduler.\"\n                )\n            return obj\n\n    raise NoSuchSchedulerError(str(scheduler))\n</code></pre>"},{"location":"api/source/pipen.template/","title":"pipen.template","text":""},{"location":"api/source/pipen.template/","title":"SOURCE CODE pipen.template DOCS","text":"<pre><code>\"\"\"Template adaptor for pipen\"\"\"\nfrom __future__ import annotations\n\nfrom abc import ABC, abstractmethod\nfrom typing import Any, Mapping, Type\n\nfrom liquid import Liquid\n\nfrom .defaults import TEMPLATE_ENTRY_GROUP\nfrom .exceptions import NoSuchTemplateEngineError, WrongTemplateEnginTypeError\nfrom .utils import is_subclass, load_entrypoints\n\n__all__ = [\n    \"Template\",\n    \"TemplateLiquid\",\n    \"TemplateJinja2\",\n    \"get_template_engine\",\n]\n\n\nclass Template(ABC):DOCS\n    \"\"\"Base class wrapper to wrap template for pipen\"\"\"\n\n    def __init__(\n        self,\n        source: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Template construct\"\"\"\n        self.engine: Any = None\n\n    def render(self, data: Mapping[str, Any] = None) -&gt; str:DOCS\n        \"\"\"\n        Render the template\n        @parmas:\n            data (dict): The data used to render\n        \"\"\"\n        return self._render(data or {})\n\n    @abstractmethod\n    def _render(self, data: Mapping[str, Any]) -&gt; str:\n        \"\"\"Implement rendering\"\"\"\n\n\nclass TemplateLiquid(Template):DOCS\n    \"\"\"Liquidpy template wrapper.\"\"\"\n\n    name = \"liquid\"\n\n    def __init__(\n        self,\n        source: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Initiate the engine with source and envs\n\n        Args:\n            source: The souce text\n            envs: The env data\n            **kwargs: Other arguments for Liquid\n        \"\"\"\n        super().__init__(source)\n        self.engine = Liquid(\n            source,\n            from_file=False,\n            mode=\"wild\",\n            **kwargs,\n        )\n\n    def _render(self, data: Mapping[str, Any]) -&gt; str:\n        \"\"\"Render the template\n\n        Args:\n            data: The data used for rendering\n\n        Returns\n            The rendered string\n        \"\"\"\n        return self.engine.render(data)\n\n\nclass TemplateJinja2(Template):DOCS\n    \"\"\"Jinja2 template wrapper\"\"\"\n\n    name = \"jinja2\"\n\n    def __init__(\n        self,\n        source: Any,\n        **kwargs: Any,\n    ):\n        \"\"\"Initiate the engine with source and envs\n\n        Args:\n            source: The souce text\n            envs: The env data\n            **kwargs: Other arguments for jinja2.Template\n        \"\"\"\n        import jinja2\n\n        super().__init__(source)\n        filters = kwargs.pop(\"filters\", {})\n        envs = kwargs.pop(\"globals\", {})\n        filters = kwargs.pop(\"filters\", {})\n        self.engine = jinja2.Template(source, **kwargs)\n        self.engine.globals.update(envs)\n        self.engine.environment.filters.update(filters)\n\n    def _render(self, data: Mapping[str, Any]) -&gt; str:\n        \"\"\"Render the template\n\n        Args:\n            data: The data used for rendering\n\n        Retuens:\n            The rendered string\n        \"\"\"\n        return self.engine.render(data)\n\n\ndef get_template_engine(template: str | Type[Template]) -&gt; Type[Template]:DOCS\n    \"\"\"Get the template engine by name or the template engine itself\n\n    Args:\n        template: The name of the template engine or the template engine itself\n\n    Returns:\n        The template engine\n    \"\"\"\n    if is_subclass(template, Template):\n        return template  # type: ignore\n\n    if template == \"liquid\":\n        return TemplateLiquid\n\n    if template == \"jinja2\":\n        return TemplateJinja2\n\n    for name, obj in load_entrypoints(\n        TEMPLATE_ENTRY_GROUP\n    ):  # pragma: no cover\n        if name == template:\n            if not is_subclass(obj, Template):\n                raise WrongTemplateEnginTypeError(\n                    \"Template engine should be a subclass of \"\n                    \"pipen.templates.Template.\"\n                )\n            return obj\n\n    raise NoSuchTemplateEngineError(str(template))\n</code></pre>"},{"location":"api/source/pipen.utils/","title":"pipen.utils","text":""},{"location":"api/source/pipen.utils/","title":"SOURCE CODE pipen.utils DOCS","text":"<pre><code>\"\"\"Provide some utilities\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport sys\nimport importlib\nimport importlib.util\nimport logging\nimport textwrap\nimport typing\nfrom copy import deepcopy\nfrom itertools import groupby\nfrom operator import itemgetter\nfrom io import StringIO\nfrom os import PathLike, get_terminal_size, environ\nfrom collections import defaultdict\nfrom pathlib import Path\nfrom typing import (\n    TYPE_CHECKING,\n    Any,\n    Callable,\n    DefaultDict,\n    Iterable,\n    List,\n    Mapping,\n    Sequence,\n    Tuple,\n    Type,\n)\n\nimport diot\nimport simplug\nfrom yunpath import AnyPath, CloudPath\nfrom rich.console import Console\nfrom rich.logging import RichHandler as _RichHandler\nfrom rich.table import Table\nfrom rich.text import Text\n\nfrom .defaults import (\n    CONSOLE_DEFAULT_WIDTH,\n    CONSOLE_WIDTH_WITH_PANEL,\n    CONSOLE_WIDTH_SHIFT,\n    LOGGER_NAME,\n)\nfrom .version import __version__\n\nfrom importlib import metadata as importlib_metadata\n\nif TYPE_CHECKING:  # pragma: no cover\n    import pandas\n    from rich.segment import Segment\n    from rich.console import RenderableType\n\n    from .pipen import Pipen\n    from .proc import Proc\n    from .procgroup import ProcGroup\n\nLOADING_ARGV0 = \"@pipen\"\n\n\nclass RichHandler(_RichHandler):DOCS\n    \"\"\"Subclass of rich.logging.RichHandler, showing log levels as a single\n    character\"\"\"\n\n    def get_level_text(self, record: logging.LogRecord) -&gt; Text:DOCS\n        \"\"\"Get the level name from the record.\n\n        Args:\n            record: LogRecord instance.\n\n        Returns:\n            Text: A tuple of the style and level name.\n        \"\"\"\n        level_name = record.levelname\n        level_text = Text.styled(\n            level_name[0].upper(), f\"logging.level.{level_name.lower()}\"\n        )\n        return level_text\n\n\nclass RichConsole(Console):DOCS\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        try:\n            self._width = get_terminal_size().columns\n        except (AttributeError, ValueError, OSError):  # maybe not a terminal\n            if environ.get(\"JUPYTER_COLUMNS\") is not None:  # pragma: no cover\n                self._width = int(environ.get(\"JUPYTER_COLUMNS\"))\n            elif environ.get(\"COLUMNS\") is not None:  # pragma: no cover\n                self._width = int(environ.get(\"COLUMNS\"))\n            else:\n                self._width = CONSOLE_DEFAULT_WIDTH\n\n    def _render_buffer(self, buffer: Iterable[Segment]) -&gt; str:\n        out = super()._render_buffer(buffer)\n        return out.rstrip() + \"\\n\"\n\n\nlogging.lastResort = logging.NullHandler()  # type: ignore\nlogger_console = RichConsole()\n_logger_handler = RichHandler(\n    show_path=False,\n    show_level=True,\n    console=logger_console,\n    rich_tracebacks=True,\n    omit_repeated_times=False,  # rich 10+\n    markup=True,\n    log_time_format=\"%m-%d %H:%M:%S\",\n    tracebacks_extra_lines=0,\n    tracebacks_suppress=[simplug, diot, typing],\n)\n_logger_handler.setFormatter(\n    logging.Formatter(\"[purple]%(plugin_name)-7s[/purple] %(message)s\")\n)\n\n\ndef _excepthook(\n    type_: Type[BaseException],\n    value: BaseException,\n    traceback: Any,\n) -&gt; None:\n    \"\"\"The excepthook for pipen, to show rich traceback\"\"\"\n    if issubclass(type_, KeyboardInterrupt):  # pragma: no cover\n        logger.error(\"\")\n        logger.error(\"Interrupted by user\")\n        return\n\n    print(\"\", file=sys.stderr)\n    _excepthook.oldhook(type_, value, traceback)\n\n\n_excepthook.oldhook = sys.excepthook\nsys.excepthook = _excepthook\n\n\ndef get_logger(DOCS\n    name: str = LOGGER_NAME,\n    level: str | int = None,\n) -&gt; logging.LoggerAdapter:\n    \"\"\"Get the logger by given plugin name\n\n    Args:\n        level: The initial level of the logger\n\n    Returns:\n        The logger\n    \"\"\"\n    log = logging.getLogger(f\"pipen.{name}\")\n    log.addHandler(_logger_handler)\n\n    if level is not None:\n        log.setLevel(level.upper() if isinstance(level, str) else level)\n\n    return logging.LoggerAdapter(log, {\"plugin_name\": name})\n\n\nlogger = get_logger()\n\n\ndef desc_from_docstring(DOCS\n    obj: Type[Pipen | Proc],\n    base: Type[Pipen | Proc],\n) -&gt; str:\n    \"\"\"Get the description from docstring\n\n    Only extract the summary.\n\n    Args:\n        obj: The object with docstring\n\n    Returns:\n        The summary as desc\n    \"\"\"\n    if not obj.__doc__:\n        # If the docstring is empty, use the base's docstring\n        # Get the base from mro\n        bases = [\n            cls\n            for cls in obj.__mro__\n            if is_subclass(cls, base) and cls != base and cls != obj\n        ]\n        if not bases:\n            return None\n\n        return desc_from_docstring(bases[0], base)\n\n    started: bool = False\n    out: List[str] = []\n    for line in obj.__doc__.splitlines():\n        line = line.strip()\n        if not started and not line:\n            continue\n        if not started:\n            out.append(line)\n            started = True\n        elif line:\n            out.append(line)\n        else:\n            break\n\n    return \" \".join(out)\n\n\ndef update_dict(DOCS\n    parent: Mapping[str, Any],\n    new: Mapping[str, Any],\n    depth: int = 0,\n    try_list: bool = False,\n) -&gt; Mapping[str, Any]:\n    \"\"\"Update the new dict to the parent, but make sure parent does not change\n\n    Args:\n        parent: The parent dictionary\n        new: The new dictionary\n        depth: The depth to be copied. 0 for updating to the deepest level.\n        try_list: If True, try to also update the dict in the list\n\n    Examples:\n        &gt;&gt;&gt; parent = {\"a\": {\"b\": 1}}\n        &gt;&gt;&gt; new = {\"a\": {\"c\": 2}}\n        &gt;&gt;&gt; update_dict(parent, new)\n        &gt;&gt;&gt; # {\"a\": {\"b\": 1, \"c\": 2}}\n        &gt;&gt;&gt; parent = {\"a\": [{\"b\": 1}]}\n        &gt;&gt;&gt; new = {\"a\": [{\"c\": 2}]}\n        &gt;&gt;&gt; update_dict(parent, new, try_list=True)\n        &gt;&gt;&gt; # {\"a\": [{\"b\": 1, \"c\": 2}]}\n\n    Returns:\n        The updated dictionary or None if both parent and new are None.\n    \"\"\"\n    if parent is None and new is None:\n        return None\n\n    out = (parent or {}).copy()\n    for key, val in (new or {}).items():\n        if (\n            try_list\n            and isinstance(out.get(key), list)\n            and isinstance(val, list)\n            and depth != 1\n        ):\n            # If the value is a list, try to update the dict in the list\n            for i, item in enumerate(val):\n                if (\n                    isinstance(item, dict)\n                    and i &lt; len(out[key])\n                    and isinstance(out[key][i], dict)\n                ):\n                    out[key][i] = update_dict(out[key][i], item, depth - 1, True)\n                elif i &lt; len(out[key]):\n                    out[key][i] = item\n                else:\n                    out[key].append(item)\n            continue\n\n        if (\n            key not in out\n            or not isinstance(val, dict)\n            or not isinstance(out[key], dict)\n            or depth == 1\n        ):\n            out[key] = val\n        else:\n            out[key] = update_dict(out[key], val, depth - 1)\n\n    return out\n\n\ndef copy_dict(dic: Mapping[str, Any], depth: int = 1) -&gt; Mapping[str, Any]:DOCS\n    \"\"\"Deep copy a dict\n\n    Args:\n        dic: The dict to be copied\n        depth: The depth to be deep copied\n\n    Returns:\n        The deep-copied dict\n    \"\"\"\n    if depth &lt;= 0:\n        return deepcopy(dic)\n\n    if depth &lt;= 1:\n        return dic.copy()\n\n    return {\n        key: copy_dict(val, depth - 1) if isinstance(val, dict) else val\n        for key, val in dic.items()\n    }\n\n\ndef strsplit(DOCS\n    string: str,\n    sep: str,\n    maxsplit: int = -1,\n    trim: str = \"both\",\n) -&gt; List[str]:\n    \"\"\"Split the string, with the ability to trim each part.\"\"\"\n    parts = string.split(sep, maxsplit=maxsplit)\n    if trim is None:\n        return parts\n    if trim == \"left\":\n        return [part.lstrip() for part in parts]\n    if trim == \"right\":\n        return [part.rstrip() for part in parts]\n\n    return [part.strip() for part in parts]\n\n\ndef get_shebang(script: str) -&gt; str:DOCS\n    \"\"\"Get the shebang of the script\n\n    Args:\n        script: The script string\n\n    Returns:\n        None if the script does not contain a shebang, otherwise the shebang\n        without `#!` prefix\n    \"\"\"\n    script = script.lstrip()\n    if not script.startswith(\"#!\"):\n        return None\n\n    if \"\\n\" not in script:\n        return script[2:].strip()\n\n    shebang_line, _ = strsplit(script, \"\\n\", 1)\n    return shebang_line[2:].strip()\n\n\ndef ignore_firstline_dedent(text: str) -&gt; str:DOCS\n    \"\"\"Like textwrap.dedent(), but ignore first empty lines\n\n    Args:\n        text: The text the be dedented\n\n    Returns:\n        The dedented text\n    \"\"\"\n    out = []\n    started = False\n    for line in text.splitlines():\n        if not started and not line.strip():\n            continue\n        if not started:\n            started = True\n        out.append(line)\n\n    return textwrap.dedent(\"\\n\".join(out))\n\n\ndef get_logpanel_width() -&gt; int:DOCS\n    \"\"\"Get the width of the log content\n\n    Args:\n        max_width: The maximum width to return\n            Note that it's not the console width. With console width, you\n            have to subtract the width of the log meta info\n            (CONSOLE_WIDTH_SHIFT).\n\n    Returns:\n        The width of the log content\n    \"\"\"\n    return (\n        min(\n            logger_console.width,\n            CONSOLE_WIDTH_WITH_PANEL,\n        )\n        - CONSOLE_WIDTH_SHIFT\n    )\n\n\ndef log_rich_renderable(DOCS\n    renderable: RenderableType,\n    color: str | None,\n    logfunc: Callable,\n    *args: Any,\n    **kwargs: Any,\n) -&gt; None:\n    \"\"\"Log a rich renderable to logger\n\n    Args:\n        renderable: The rich renderable\n        splitline: Whether split the lines or log the entire message\n        logfunc: The log function, if message is not the first argument,\n            use functools.partial to wrap it\n        *args: The arguments to the log function\n        **kwargs: The keyword arguments to the log function\n    \"\"\"\n    console = Console(\n        file=StringIO(),\n        width=logger_console.width - CONSOLE_WIDTH_SHIFT,\n    )\n    console.print(renderable)\n\n    for line in console.file.getvalue().splitlines():\n        logfunc(\n            f\"[{color}]{line}[/{color}]\" if color else line,\n            *args,\n            **kwargs,\n        )\n\n\ndef brief_list(blist: List[int]) -&gt; str:DOCS\n    \"\"\"Briefly show an integer list, combine the continuous numbers.\n\n    Args:\n        blist: The list\n\n    Returns:\n        The string to show for the briefed list.\n    \"\"\"\n    ret = []\n    for _, g in groupby(enumerate(blist), lambda x: x[0] - x[1]):\n        list_group = list(map(itemgetter(1), g))\n        if len(list_group) &gt; 1:\n            ret.append(f\"{list_group[0]}-{list_group[-1]}\")\n        else:\n            ret.append(str(list_group[0]))\n    return \", \".join(ret)\n\n\ndef pipen_banner() -&gt; RenderableType:DOCS\n    \"\"\"The banner for pipen\n\n    Returns:\n        The banner renderable\n    \"\"\"\n    table = Table(\n        width=get_logpanel_width(),\n        show_header=False,\n        show_edge=False,\n        show_footer=False,\n        show_lines=False,\n        caption=f\"version: {__version__}\",\n    )\n    table.add_column(justify=\"center\")\n    table.add_row(r\"   _____________________________________   __\")\n    table.add_row(r\"   ___  __ \\___  _/__  __ \\__  ____/__  | / /\")\n    table.add_row(r\"  __  /_/ /__  / __  /_/ /_  __/  __   |/ / \")\n    table.add_row(r\" _  ____/__/ /  _  ____/_  /___  _  /|  /  \")\n    table.add_row(r\"/_/     /___/  /_/     /_____/  /_/ |_/   \")\n    table.add_row(\"\")\n\n    return table\n\n\ndef get_mtime(DOCS\n    path: str | PathLike | CloudPath,\n    dir_depth: int = 1,\n) -&gt; float:\n    \"\"\"Get the modification time of a path.\n    If path is a directory, try to get the last modification time of the\n    contents in the directory at given dir_depth\n    Args:\n        dir_depth: The depth of the directory to check the\n            last modification time\n    Returns:\n        The last modification time of path\n    \"\"\"\n    path = getattr(path, \"path\", path)\n\n    mtime = 0.0\n    path: Path | CloudPath = AnyPath(path)  # type: ignore[assignment]\n    if not path.exists():\n        return mtime\n\n    if not path_is_symlink(path):\n        if dir_depth == 0 or not path.is_dir():\n            return path.stat().st_mtime\n\n        for file in path.iterdir():\n            mtime = max(mtime, get_mtime(file, dir_depth - 1))\n\n        return mtime\n\n    # Is it a real symlink or fake\n    if isinstance(path, Path) and path.is_symlink():\n        if dir_depth == 0 or not path.is_dir():\n            return path.lstat().st_mtime\n\n        for file in path.iterdir():\n            mtime = max(mtime, get_mtime(file, dir_depth - 1))\n\n        return mtime\n\n    # Fake symlink\n    dest = path.read_text().removeprefix(\"symlink:\").removeprefix(\"pipen-symlink:\")\n    dpath = AnyPath(dest)\n    if dir_depth == 0 or not dpath.is_dir():\n        try:\n            return dpath.stat().st_mtime\n        except Exception:\n            return path.stat().st_mtime\n\n    for file in dpath.iterdir():\n        mtime = max(mtime, get_mtime(file, dir_depth - 1))\n    return mtime\n\n\ndef is_subclass(obj: Any, cls: type) -&gt; bool:DOCS\n    \"\"\"Tell if obj is a subclass of cls\n    Differences with issubclass is that we don't raise Type error if obj\n    is not a class\n\n    Args:\n        obj: The object to check\n        cls: The class to check\n\n    Returns:\n        True if obj is a subclass of cls otherwise False\n    \"\"\"\n    try:\n        return issubclass(obj, cls)\n    except TypeError:\n        return False\n\n\ndef load_entrypoints(group: str) -&gt; Iterable[Tuple[str, Any]]:  # pragma: no coverDOCS\n    \"\"\"Load objects from setuptools entrypoints by given group name\n\n    Args:\n        group: The group name of the entrypoints\n\n    Returns:\n        An iterable of tuples with name and the loaded object\n    \"\"\"\n    try:\n        eps = importlib_metadata.entry_points(group=group)\n    except TypeError:\n        eps = importlib_metadata.entry_points().get(group, [])  # type: ignore\n\n    yield from ((ep.name, ep.load()) for ep in eps)\n\n\ndef truncate_text(text: str, width: int, end: str = \"\u2026\") -&gt; str:DOCS\n    \"\"\"Truncate a text not based on words/whitespaces\n    Otherwise, we could use textwrap.shorten.\n\n    Args:\n        text: The text to be truncated\n        width: The max width of the the truncated text\n        end: The end string of the truncated text\n    Returns:\n        The truncated text with end appended.\n    \"\"\"\n    if len(text) &lt;= width:\n        return text\n\n    return text[: (width - len(end))] + end\n\n\ndef make_df_colnames_unique_inplace(thedf: pandas.DataFrame) -&gt; None:DOCS\n    \"\"\"Make the columns of a data frame unique\n\n    Args:\n        thedf: The data frame\n    \"\"\"\n    col_counts: DefaultDict = defaultdict(lambda: 0)\n    new_cols = []\n    for col in thedf.columns:\n        if col_counts[col] == 0:\n            new_cols.append(col)\n        else:\n            new_cols.append(f\"{col}_{col_counts[col]}\")\n        col_counts[col] += 1\n    thedf.columns = new_cols\n\n\ndef get_base(DOCS\n    klass: Type,\n    abc_base: Type,\n    value: Any,\n    value_getter: Callable,\n) -&gt; Type:\n    \"\"\"Get the base class where the value was first defined\n\n    Args:\n        klass: The class\n        abc_base: The very base class to check in __bases__\n        value: The value to check\n        value_getter: How to get the value from the class\n\n    Returns:\n        The base class\n    \"\"\"\n    bases = [\n        base\n        for base in klass.__bases__\n        if issubclass(base, abc_base) and value_getter(base) == value\n    ]\n    if not bases:\n        return klass\n\n    return get_base(bases[0], abc_base, value, value_getter)\n\n\ndef mark(**kwargs) -&gt; Callable[[type], type]:DOCS\n    \"\"\"Mark a class (e.g. Proc) with given kwargs as metadata\n\n    These marks will not be inherited by the subclasses if the class is\n    a subclass of `Proc` or `ProcGroup`.\n\n    Args:\n        **kwargs: The kwargs to mark the proc\n\n    Returns:\n        The decorator\n    \"\"\"\n\n    def decorator(cls: type) -&gt; type:\n        if not getattr(cls, \"__meta__\", None):\n            cls.__meta__ = {}\n\n        cls.__meta__.update(kwargs)\n        return cls\n\n    return decorator\n\n\ndef get_marked(cls: type, mark_name: str, default: Any = None) -&gt; Any:DOCS\n    \"\"\"Get the marked value from a proc\n\n    Args:\n        cls: The proc\n        mark_name: The mark name\n        default: The default value if the mark is not found\n\n    Returns:\n        The marked value\n    \"\"\"\n    if not getattr(cls, \"__meta__\", None):\n        return default\n\n    return cls.__meta__.get(mark_name, default)\n\n\ndef is_valid_name(name: str) -&gt; bool:DOCS\n    \"\"\"Check if a name is valid for a proc or pipen\n\n    Args:\n        name: The name to check\n\n    Returns:\n        True if valid, otherwise False\n    \"\"\"\n    return re.match(r\"^[\\w.-]+$\", name) is not None\n\n\ndef _get_obj_from_spec(spec: str) -&gt; Any:\n    \"\"\"Get the object from a spec like `&lt;module[.submodule]&gt;:name` or\n    `/path/to/script.py:name`\n\n    Args:\n        spec: The spec\n\n    Returns:\n        The object\n\n    Raises:\n        AttributeError: If name cannot be found in the module\n    \"\"\"\n    modpath, sep, name = spec.rpartition(\":\")\n    if sep != \":\":\n        raise ValueError(\n            f\"Invalid specification: {spec}.\\n\"\n            \"It must be in the format '&lt;module[.submodule]&gt;:name' or \\n\"\n            \"'/path/to/spec.py:name'\"\n        )\n\n    path = Path(modpath)\n    if path.is_file():\n        mspec = importlib.util.spec_from_file_location(path.stem, modpath)\n        module = importlib.util.module_from_spec(mspec)\n        mspec.loader.exec_module(module)\n    else:\n        module = importlib.import_module(modpath)\n\n    return getattr(module, name)\n\n\nasync def load_pipeline(DOCS\n    obj: str | Type[Proc] | Type[ProcGroup] | Type[Pipen] | Pipen,\n    argv0: str | None = None,\n    argv1p: Sequence[str] | None = None,\n    **kwargs: Any,\n) -&gt; Pipen:\n    \"\"\"Load a pipeline from a Pipen, Proc or ProcGroup object\n\n    It does not only load the Pipen object or convert the Proc/ProcGroup\n    object to Pipen, but also build the process relationships. So that we\n    can access `pipeline.procs` and `requires/nexts` of each proc.\n\n    To avoid running the pipeline and notify the plugins that this is just\n    for loading the pipeline, `sys.argv[0]` is set to `@pipen`.\n\n    Args:\n        obj: The Pipen, Proc or ProcGroup object. It can also be a string in\n            the format of `part1:part2` to load the pipeline, where part1 is\n            a path to a python file or package directory, and part2 is the name\n            of the proc, procgroup or pipeline to load.\n            It should be able to be loaded by `getattr(module, part2)`, where\n            module is loaded from `part1`.\n        argv0: The value to replace sys.argv[0]. \"@pipen\" will be used\n            by default.\n        argv1p: The values to replace sys.argv[1:]. Do not replace by default.\n        kwargs: The kwargs to pass to the Pipen constructor\n\n    Returns:\n        The loaded Pipen object\n\n    Raises:\n        TypeError: If obj or loaded obj is not a Pipen, Proc or ProcGroup\n        object\n    \"\"\"\n    from .pipen import Pipen\n    from .proc import Proc\n    from .procgroup import ProcGroup\n\n    old_argv = sys.argv\n    if argv0 is None:\n        # Set it at runtime to allow LOADING_ARGV0 to be monkey-patched\n        argv0 = LOADING_ARGV0\n    if argv1p is None:\n        # Set it at runtime to adopt sys.argv changes\n        argv1p = sys.argv[1:]\n    sys.argv = [argv0] + list(argv1p)\n\n    try:\n        if isinstance(obj, str):\n            obj = _get_obj_from_spec(obj)\n        if isinstance(obj, Pipen) or (\n            isinstance(obj, type) and issubclass(obj, (Pipen, Proc, ProcGroup))\n        ):\n            pass\n        else:\n            raise TypeError(\n                \"Expected a Pipen, Proc, ProcGroup class, or a Pipen object, \"\n                f\"got {type(obj)}\"\n            )\n\n        pipeline = obj\n        if isinstance(obj, type) and issubclass(obj, Proc):\n            kwargs.setdefault(\"name\", f\"{obj.name}Pipeline\")\n            pipeline = Pipen(**kwargs).set_starts(obj)\n\n        elif isinstance(obj, type) and issubclass(obj, ProcGroup):\n            pipeline = obj().as_pipen(**kwargs)  # type: ignore\n\n        elif isinstance(obj, type) and issubclass(obj, Pipen):\n            # Avoid \"pipeline\" to be used as pipeline name by varname\n            (pipeline,) = (obj(**kwargs),)  # type: ignore\n\n        elif isinstance(obj, Pipen):\n            pipeline._kwargs.update(kwargs)  # type: ignore\n\n        # Initialize the pipeline so that the arguments definied by\n        # other plugins (i.e. pipen-args) to take in place.\n        pipeline.workdir = Path(pipeline.config.workdir).joinpath(  # type: ignore\n            kwargs.get(\"name\", pipeline.name)\n        )\n        await pipeline._init()  # type: ignore\n        pipeline.workdir.mkdir(parents=True, exist_ok=True)  # type: ignore\n        pipeline.build_proc_relationships()  # type: ignore\n    finally:\n        sys.argv = old_argv\n\n    return pipeline  # type: ignore\n\n\ndef is_loading_pipeline(*flags: str, argv: Sequence[str] | None = None) -&gt; bool:DOCS\n    \"\"\"Check if we are loading the pipeline. Works only when\n    `argv0` is \"@pipen\" while loading the pipeline.\n\n    Note if you are using this function at compile time, make\n    sure you load your pipeline using the string form (`part1:part2`)\n    See more with `load_pipline()`.\n\n    Args:\n        *flags: Additional flags to check in sys.argv (e.g. \"-h\", \"--help\")\n            to determine if we are loading the pipeline\n        argv: The arguments to check. sys.argv is used by default.\n            Note that the first argument should be included in the check.\n            You could typically pass `[sys.argv[0], *your_args]` to this if you want\n            to check if `sys.argv[0]` is \"@pipen\" or `your_args` contains some flags.\n\n    Returns:\n        True if we are loading the pipeline (argv[0] == \"@pipen\"),\n        otherwise False\n    \"\"\"\n    if argv is None:\n        argv = sys.argv\n\n    if len(argv) &gt; 0 and argv[0] == LOADING_ARGV0:\n        return True\n\n    if flags:\n        return any(flag in argv for flag in flags)\n\n    return False  # pragma: no cover\n\n\ndef path_is_symlink(path: Path | CloudPath) -&gt; bool:DOCS\n    \"\"\"Check if a path is a symlink.\n\n    CloudPath.is_symlink() is not implemented yet, so we need to check\n    it manually.\n\n    Args:\n        path: The path to check\n\n    Returns:\n        True if the path is a symlink, otherwise False\n    \"\"\"\n    path = getattr(path, \"path\", path)\n    if isinstance(path, Path):\n        if path.is_symlink():\n            return True\n\n    if not path.exists():\n        return False\n\n    # Check if the path is a fake symlink file\n    try:\n        with path.open(\"rb\") as f:\n            prefix = f.read(14)\n            return prefix == b\"pipen-symlink:\" or prefix.startswith(b\"symlink:\")\n    except Exception:\n        # If we cannot read the file, it is not a symlink\n        return False\n\n\ndef path_symlink_to(DOCS\n    src: Path | CloudPath,\n    dst: Path | CloudPath,\n    target_is_directory: bool = False,\n) -&gt; None:\n    \"\"\"Create a symbolic link pointing to src named dst.\n\n    Args:\n        src: The source path\n        dst: The destination path\n        target_is_directory: If True, the symbolic link will be to a directory.\n    \"\"\"\n    src = getattr(src, \"path\", src)\n    dst = getattr(dst, \"path\", dst)\n    if isinstance(dst, CloudPath) or isinstance(src, CloudPath):\n        # Create a fake symlink file for cloud paths\n        src.write_text(f\"pipen-symlink:{dst}\")\n    else:\n        src.symlink_to(dst, target_is_directory=target_is_directory)\n</code></pre>"},{"location":"api/source/pipen.version/","title":"pipen.version","text":""},{"location":"api/source/pipen.version/","title":"SOURCE CODE pipen.version DOCS","text":"<pre><code>\"\"\"Provide version of pipen\"\"\"\n\n__version__ = \"0.17.24\"\n</code></pre>"}]}